
AVRASM ver. 2.1.52  bf.asm Sat Oct 17 14:26:16 2015

bf.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega169\device.asm'
../../avr8/devices/atmega169\device.asm(6): Including file '../../avr8/Atmel/Appnotes2\m169def.inc'
bf.asm(8): Including file '../../avr8\drivers/usart.asm'
../../avr8\drivers/usart.asm(30): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(5): Including file '../../avr8\drivers/usart-isr-rx.asm'
../../avr8\drivers/usart_common.asm(17): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(22): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(23): Including file '../../avr8\words/usart.asm'
bf.asm(10): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(13): Including file '../../avr8\dict/appl_2k.inc'
../../avr8\dict/appl_2k.inc(1): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/appl_2k.inc(2): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/appl_2k.inc(3): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/appl_2k.inc(4): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/appl_2k.inc(5): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/appl_2k.inc(6): Including file '../../avr8\words/d-equal.asm'
../../avr8\dict/appl_2k.inc(7): Including file '../../common\words/u-dot.asm'
../../avr8\dict/appl_2k.inc(8): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/appl_2k.inc(10): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/appl_2k.inc(11): Including file '../../common\words/words.asm'
../../avr8\dict/appl_2k.inc(12): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(2): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(3): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(4): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(8): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/appl_2k.inc(14): Including file '../../common\words/pick.asm'
../../avr8\dict/appl_2k.inc(15): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/appl_2k.inc(16): Including file '../../common\words/squote.asm'
../../avr8\dict/appl_2k.inc(18): Including file '../../avr8\words/fill.asm'
../../avr8\dict/appl_2k.inc(19): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/newest.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/do-create.asm'
../../avr8\dict/compiler1.inc(5): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(9): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(10): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(17): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(33): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(38): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../common\words/create.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../common\words/reveal.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(53): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../common\words/recurse.asm'
../../avr8\dict/compiler1.inc(56): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(61): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(67): Including file '../../common\words/get-order.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(70): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\dict/appl_2k.inc(21): Including file '../../avr8\words/environment.asm'
../../avr8\dict/appl_2k.inc(22): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/appl_2k.inc(23): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/appl_2k.inc(24): Including file '../../common\words/env-slashhold.asm'
../../avr8\dict/appl_2k.inc(25): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/appl_2k.inc(26): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/appl_2k.inc(27): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/appl_2k.inc(28): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/appl_2k.inc(29): Including file '../../common\words/env-usersize.asm'
../../avr8\dict/appl_2k.inc(31): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/appl_2k.inc(32): Including file '../../avr8\words/state.asm'
../../avr8\dict/appl_2k.inc(33): Including file '../../common\words/base.asm'
../../avr8\dict/appl_2k.inc(35): Including file '../../avr8\words/cells.asm'
../../avr8\dict/appl_2k.inc(36): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/appl_2k.inc(38): Including file '../../common\words/2dup.asm'
../../avr8\dict/appl_2k.inc(39): Including file '../../common\words/2drop.asm'
../../avr8\dict/appl_2k.inc(41): Including file '../../common\words/tuck.asm'
../../avr8\dict/appl_2k.inc(43): Including file '../../common\words/to-in.asm'
../../avr8\dict/appl_2k.inc(44): Including file '../../common\words/pad.asm'
../../avr8\dict/appl_2k.inc(45): Including file '../../common\words/emit.asm'
../../avr8\dict/appl_2k.inc(46): Including file '../../common\words/emitq.asm'
../../avr8\dict/appl_2k.inc(47): Including file '../../common\words/key.asm'
../../avr8\dict/appl_2k.inc(48): Including file '../../common\words/keyq.asm'
../../avr8\dict/appl_2k.inc(50): Including file '../../avr8\words/dp.asm'
../../avr8\dict/appl_2k.inc(51): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/appl_2k.inc(52): Including file '../../avr8\words/here.asm'
../../avr8\dict/appl_2k.inc(53): Including file '../../avr8\words/allot.asm'
../../avr8\dict/appl_2k.inc(55): Including file '../../common\words/bin.asm'
../../avr8\dict/appl_2k.inc(56): Including file '../../common\words/decimal.asm'
../../avr8\dict/appl_2k.inc(57): Including file '../../common\words/hex.asm'
../../avr8\dict/appl_2k.inc(58): Including file '../../common\words/bl.asm'
../../avr8\dict/appl_2k.inc(60): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/appl_2k.inc(62): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/appl_2k.inc(63): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/appl_2k.inc(64): Including file '../../avr8\words/negate.asm'
../../avr8\dict/appl_2k.inc(65): Including file '../../common\words/slash.asm'
../../avr8\dict/appl_2k.inc(66): Including file '../../common\words/mod.asm'
../../avr8\dict/appl_2k.inc(67): Including file '../../avr8\words/abs.asm'
../../avr8\dict/appl_2k.inc(68): Including file '../../common\words/min.asm'
../../avr8\dict/appl_2k.inc(69): Including file '../../common\words/max.asm'
../../avr8\dict/appl_2k.inc(70): Including file '../../common\words/within.asm'
../../avr8\dict/appl_2k.inc(72): Including file '../../common\words/to-upper.asm'
../../avr8\dict/appl_2k.inc(73): Including file '../../common\words/to-lower.asm'
../../avr8\dict/appl_2k.inc(75): Including file '../../avr8\words/hld.asm'
../../avr8\dict/appl_2k.inc(76): Including file '../../common\words/hold.asm'
../../avr8\dict/appl_2k.inc(77): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/appl_2k.inc(78): Including file '../../common\words/sharp.asm'
../../avr8\dict/appl_2k.inc(79): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/appl_2k.inc(80): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/appl_2k.inc(81): Including file '../../common\words/sign.asm'
../../avr8\dict/appl_2k.inc(82): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/appl_2k.inc(83): Including file '../../common\words/dot-r.asm'
../../avr8\dict/appl_2k.inc(84): Including file '../../common\words/d-dot.asm'
../../avr8\dict/appl_2k.inc(85): Including file '../../common\words/dot.asm'
../../avr8\dict/appl_2k.inc(86): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/appl_2k.inc(87): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/appl_2k.inc(88): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/appl_2k.inc(89): Including file '../../common\words/digit-q.asm'
../../avr8\dict/appl_2k.inc(91): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/appl_2k.inc(92): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/appl_2k.inc(93): Including file '../../avr8\words/itype.asm'
../../avr8\dict/appl_2k.inc(94): Including file '../../avr8\words/icount.asm'
../../avr8\dict/appl_2k.inc(95): Including file '../../common\words/cr.asm'
../../avr8\dict/appl_2k.inc(96): Including file '../../common\words/space.asm'
../../avr8\dict/appl_2k.inc(97): Including file '../../common\words/spaces.asm'
../../avr8\dict/appl_2k.inc(98): Including file '../../common\words/type.asm'
../../avr8\dict/appl_2k.inc(99): Including file '../../common\words/tick.asm'
../../avr8\dict/appl_2k.inc(101): Including file '../../common\words/handler.asm'
../../avr8\dict/appl_2k.inc(102): Including file '../../common\words/catch.asm'
../../avr8\dict/appl_2k.inc(103): Including file '../../common\words/throw.asm'
../../avr8\dict/appl_2k.inc(105): Including file '../../common\words/cskip.asm'
../../avr8\dict/appl_2k.inc(106): Including file '../../common\words/cscan.asm'
../../avr8\dict/appl_2k.inc(107): Including file '../../common\words/accept.asm'
../../avr8\dict/appl_2k.inc(108): Including file '../../common\words/refill.asm'
../../avr8\dict/appl_2k.inc(109): Including file '../../common\words/char.asm'
../../avr8\dict/appl_2k.inc(110): Including file '../../common\words/number.asm'
../../avr8\dict/appl_2k.inc(111): Including file '../../common\words/q-sign.asm'
../../avr8\dict/appl_2k.inc(112): Including file '../../common\words/set-base.asm'
../../avr8\dict/appl_2k.inc(113): Including file '../../common\words/to-number.asm'
../../avr8\dict/appl_2k.inc(114): Including file '../../common\words/parse.asm'
../../avr8\dict/appl_2k.inc(115): Including file '../../common\words/source.asm'
../../avr8\dict/appl_2k.inc(116): Including file '../../common\words/slash-string.asm'
../../avr8\dict/appl_2k.inc(117): Including file '../../common\words/parse-name.asm'
../../avr8\dict/appl_2k.inc(118): Including file '../../common\words/find-name.asm'
../../avr8\dict/appl_2k.inc(120): Including file '../../common\words/quit.asm'
../../avr8\dict/appl_2k.inc(121): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/appl_2k.inc(122): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/appl_2k.inc(123): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/appl_2k.inc(124): Including file '../../avr8\words/pause.asm'
../../avr8\dict/appl_2k.inc(125): Including file '../../avr8\words/cold.asm'
../../avr8\dict/appl_2k.inc(126): Including file '../../common\words/warm.asm'
../../avr8\dict/appl_2k.inc(128): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/appl_2k.inc(129): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/appl_2k.inc(130): Including file '../../common\words/depth.asm'
../../avr8\dict/appl_2k.inc(131): Including file '../../common\words/do-recognizer.asm'
../../avr8\dict/appl_2k.inc(132): Including file '../../common\words/interpret.asm'
../../avr8\dict/appl_2k.inc(133): Including file '../../common\words/r-intnumber.asm'
../../avr8\dict/appl_2k.inc(134): Including file '../../common\words/r-word.asm'
../../avr8\dict/appl_2k.inc(135): Including file '../../common\words/r-fail.asm'
../../avr8\dict/appl_2k.inc(137): Including file '../../common\words/q-stack.asm'
../../avr8\dict/appl_2k.inc(138): Including file '../../common\words/ver.asm'
../../avr8\dict/appl_2k.inc(140): Including file '../../common\words/noop.asm'
../../avr8\dict/appl_2k.inc(141): Including file '../../avr8\words/unused.asm'
../../avr8\dict/appl_2k.inc(143): Including file '../../common\words/to.asm'
../../avr8\dict/appl_2k.inc(144): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/appl_2k.inc(146): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/appl_2k.inc(147): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/appl_2k.inc(148): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/appl_2k.inc(149): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/appl_2k.inc(150): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/appl_2k.inc(151): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/appl_2k.inc(152): Including file '../../common\words/defer-store.asm'
../../avr8\dict/appl_2k.inc(153): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/appl_2k.inc(154): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/appl_2k.inc(156): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/appl_2k.inc(157): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/appl_2k.inc(158): Including file '../../common\words/name2string.asm'
../../avr8\dict/appl_2k.inc(159): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/appl_2k.inc(160): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/appl_2k.inc(162): Including file '../../common\words/star.asm'
../../avr8\dict/appl_2k.inc(163): Including file '../../avr8\words/j.asm'
../../avr8\dict/appl_2k.inc(165): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/appl_2k.inc(166): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/appl_2k.inc(167): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/appl_2k.inc(168): Including file '../../common\words/2swap.asm'
../../avr8\dict/appl_2k.inc(170): Including file '../../common\words/tib.asm'
../../avr8\dict/appl_2k.inc(172): Including file '../../avr8\words/init-ram.asm'
../../avr8\dict/appl_2k.inc(173): Including file '../../common\words/bounds.asm'
../../avr8\dict/appl_2k.inc(174): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/appl_2k.inc(175): Including file '../../avr8\words/to-body.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(5): Including file 'words/applturnkey.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(36): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(41): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(45): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(46): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(48): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(55): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(62): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(88): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(92): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(96): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(98): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(105): Including file '../../avr8\dict/core_2k.inc'
../../avr8\dict/nrww.inc(111): Including file '../../common\words/2literal.asm'
../../avr8\dict/nrww.inc(112): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(113): Including file '../../common\words/num-constants.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot      = r10
                   .def erase_counter = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; Built using part description XML file version 300
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  $100
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 
                 ; the following definitions are shortcuts for the respective forth source segments if set to 1
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_CPU = 0
                 .set WANT_EEPROM = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_JTAG = 0
                 .set WANT_LCD = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_PORTG = 0
                 .set WANT_SPI = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_USART0 = 0
                 .set WANT_USI = 0
                 .set WANT_WATCHDOG = 0
                 
                 
                 .ifndef SPMEN
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef EEPE
                  .equ EEPE = EEWE
                 .endif
                 
                 .ifndef EEMPE
                  .equ EEMPE = EEMWE
                 .endif
                 .equ intvecsize = 2 ; please verify; flash size: 16384 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .equ INTVECTORS = 23
                 .org $002
000002 d0c1      	 rcall isr ; External Interrupt Request 0
                 .org $004
000004 d0bf      	 rcall isr ; Pin Change Interrupt Request 0
                 .org $006
000006 d0bd      	 rcall isr ; Pin Change Interrupt Request 1
                 .org $008
000008 d0bb      	 rcall isr ; Timer/Counter2 Compare Match
                 .org $00A
00000a d0b9      	 rcall isr ; Timer/Counter2 Overflow
                 .org $00C
00000c d0b7      	 rcall isr ; Timer/Counter1 Capture Event
                 .org $00E
00000e d0b5      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org $010
000010 d0b3      	 rcall isr ; Timer/Counter Compare Match B
                 .org $012
000012 d0b1      	 rcall isr ; Timer/Counter1 Overflow
                 .org $014
000014 d0af      	 rcall isr ; Timer/Counter0 Compare Match
                 .org $016
000016 d0ad      	 rcall isr ; Timer/Counter0 Overflow
                 .org $018
000018 d0ab      	 rcall isr ; SPI Serial Transfer Complete
                 .org $01A
00001a d0a9      	 rcall isr ; USART0, Rx Complete
                 .org $01C
00001c d0a7      	 rcall isr ; USART0 Data register Empty
                 .org $01E
00001e d0a5      	 rcall isr ; USART0, Tx Complete
                 .org $020
000020 d0a3      	 rcall isr ; USI Start Condition
                 .org $022
000022 d0a1      	 rcall isr ; USI Overflow
                 .org $024
000024 d09f      	 rcall isr ; Analog Comparator
                 .org $026
000026 d09d      	 rcall isr ; ADC Conversion Complete
                 .org $028
000028 d09b      	 rcall isr ; EEPROM Ready
                 .org $02A
00002a d099      	 rcall isr ; Store Program Memory Read
                 .org $02C
00002c d097      	 rcall isr ; LCD Start of Frame
                 .nooverlap
                 mcu_info:
                 mcu_ramsize:
00002d 0400      	.dw 1024
                 mcu_eepromsize:
00002e 0200      	.dw 512
                 mcu_maxdp:
00002f 1c00      	.dw 7168 ; minimum of 0x1C00 (from XML) and 0xffff
                 mcu_numints:
000030 0017      	.dw 23
                 mcu_name:
000031 0009      	.dw  9
000032 5441
000033 656d
000034 6167
000035 3631
000036 0039      	.db "ATmega169",0
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; receiving is asynchron, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 
                 .equ F_CPU = 8000000
                 .include "drivers/usart.asm"
                 
                 .equ BAUDRATE_LOW = UBRRL+$20
                 .equ BAUDRATE_HIGH = UBRRH+$20
                 .equ USART_C = UCSRC+$20
                 .equ USART_B = UCSRB+$20
                 .equ USART_A = UCSRA+$20
                 .equ USART_DATA = UDR+$20
                 .equ bm_USARTC_en   = 1 << 7
                 
                 ; some generic constants
                 .equ bm_USART_RXRD = 1 << RXC
                 .equ bm_USART_TXRD = 1 << UDRE
                 .equ bm_ENABLE_TX  = 1 << TXEN
                 .equ bm_ENABLE_RX  = 1 << RXEN
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE
                 .equ bm_ENABLE_INT_TX = 1<<UDRE
                 
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_data: .byte usart_rx_size+2
000112           usart_rx_in: .byte 2
000114           usart_rx_out: .byte 2
                 
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
000037 93af        push xl
000038 b7af        in xl, SREG
000039 93af        push xl
00003a 93bf        push xh
00003b 93ef        push zl
00003c 93ff        push zh
                 
00003d 91b0 00e6   lds xh, USART_DATA
                 usart_rx_store:
00003f 91a0 0112   lds xl, usart_rx_in
000041 e0e0        ldi zl, low(usart_rx_data)
000042 e0f1        ldi zh, high(usart_rx_data)
000043 0fea        add zl, xl
000044 1df3        adc zh, zeroh
000045 83b0        st Z, xh
                 
000046 95a3        inc xl
000047 70af        andi xl,usart_rx_mask
                 
000048 93a0 0112   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
00004a 91ff        pop zh
00004b 91ef        pop zl
00004c 91bf        pop xh
00004d 91af        pop xl
00004e bfaf        out SREG, xl
00004f 91af        pop xl
000050 9518        reti
                 
                 .set usartpc = pc
                 .org URXCaddr
00001a c01c        jmp_ usart_rx_isr
                 .org usartpc
                 
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000051 1c00        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
000052 1d4e        .dw XT_ZERO
000053 1c37        .dw XT_DOLITERAL
000054 0112        .dw usart_rx_in
000055 1c87        .dw XT_CSTORE
000056 1d4e        .dw XT_ZERO
000057 1c37        .dw XT_DOLITERAL
000058 0114        .dw usart_rx_out
000059 1c87        .dw XT_CSTORE
                 
00005a 1c1a        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
00005b ff06          .dw $ff06
00005c 7872
00005d 692d
00005e 7273          .db "rx-isr"
00005f 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
000060 1c00          .dw DO_COLON
                 PFA_RX_ISR:
000061 007a        .dw XT_RXQ_ISR
000062 1c30        .dw XT_DOCONDBRANCH
000063 0061        .dw PFA_RX_ISR
000064 1c37        .dw XT_DOLITERAL
000065 0114        .dw usart_rx_out
000066 1c92        .dw XT_CFETCH
000067 1cab        .dw XT_DUP
000068 1e29        .dw XT_1PLUS
000069 1c37        .dw XT_DOLITERAL
00006a 000f        .dw usart_rx_mask
00006b 1e0d        .dw XT_AND
00006c 1c37        .dw XT_DOLITERAL
00006d 0114        .dw usart_rx_out
00006e 1c87        .dw XT_CSTORE
00006f 1c37        .dw XT_DOLITERAL
000070 0100        .dw usart_rx_data
000071 1d97        .dw XT_PLUS
000072 1c92        .dw XT_CFETCH
000073 1c1a        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
000074 ff07          .dw $ff07
000075 7872
000076 2d3f
000077 7369
000078 0072          .db "rx?-isr",0
000079 005b          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
00007a 1c00          .dw DO_COLON
                 PFA_RXQ_ISR:
00007b 0a5a        .dw XT_PAUSE
00007c 1c37        .dw XT_DOLITERAL
00007d 0114        .dw usart_rx_out
00007e 1c92        .dw XT_CFETCH
00007f 1c37        .dw XT_DOLITERAL
000080 0112        .dw usart_rx_in
000081 1c92        .dw XT_CFETCH
000082 1d0d        .dw XT_NOTEQUAL
000083 1c1a        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
000084 ff07          .dw $ff07
000085 7874
000086 702d
000087 6c6f
000088 006c          .db "tx-poll",0
000089 0074          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
00008a 1c00          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
00008b 0098        .dw XT_TXQ_POLL
00008c 1c30        .dw XT_DOCONDBRANCH
00008d 008b        .dw PFA_TX_POLL
                   ; send to usart
00008e 1c37        .dw XT_DOLITERAL
00008f 00e6        .dw USART_DATA
000090 1c87        .dw XT_CSTORE
000091 1c1a        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
000092 ff08          .dw $ff08
000093 7874
000094 2d3f
000095 6f70
000096 6c6c          .db "tx?-poll"
000097 0084          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
000098 1c00          .dw DO_COLON
                 PFA_TXQ_POLL:
000099 0a5a        .dw XT_PAUSE
00009a 1c37        .dw XT_DOLITERAL
00009b 00e0        .dw USART_A
00009c 1c92        .dw XT_CFETCH
00009d 1c37        .dw XT_DOLITERAL
00009e 0020        .dw bm_USART_TXRD
00009f 1e0d        .dw XT_AND
0000a0 1c1a        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000a1 ff04        .dw $ff04
0000a2 6275
0000a3 7272        .db "ubrr"
0000a4 0092        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000a5 1c69        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000a6 007e        .dw EE_UBRRVAL
0000a7 0bae        .dw XT_EDEFERFETCH
0000a8 0bb8        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000a9 ff06        .dw $ff06
0000aa 752b
0000ab 6173
0000ac 7472        .db "+usart"
0000ad 00a1        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000ae 1c00        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000af 1c37        .dw XT_DOLITERAL
0000b0 0098        .dw USART_B_VALUE
0000b1 1c37        .dw XT_DOLITERAL
0000b2 00e1        .dw USART_B
0000b3 1c87        .dw XT_CSTORE
                 
0000b4 1c37        .dw XT_DOLITERAL
0000b5 0006        .dw USART_C_VALUE
0000b6 1c37        .dw XT_DOLITERAL
0000b7 00e2        .dw USART_C | bm_USARTC_en
0000b8 1c87        .dw XT_CSTORE
                 
0000b9 00a5        .dw XT_UBRR
0000ba 1cab        .dw XT_DUP
0000bb 1ee7        .dw XT_BYTESWAP
0000bc 1c37        .dw XT_DOLITERAL
0000bd 00e5        .dw BAUDRATE_HIGH
0000be 1c87        .dw XT_CSTORE
0000bf 1c37        .dw XT_DOLITERAL
0000c0 00e4        .dw BAUDRATE_LOW
0000c1 1c87        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000c2 0051        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000c3 1c1a        .dw XT_EXIT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c 0a63   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000116           intcur: .byte 1
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
0000c4 920a          st -Y, r0
0000c5 b60f          in r0, SREG
0000c6 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
0000c7 900f          pop r0
0000c8 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
0000c9 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
0000ca 9200 0116     sts intcur, r0
0000cc 9009          ld r0, Y+
0000cd be0f          out SREG, r0
0000ce 9009          ld r0, Y+
0000cf 9468          set ; set the interrupt flag for the inner interpreter
0000d0 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
0000d1 ff02          .dw $ff02
0000d2 2b6d          .db "m+"
0000d3 00a9          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
0000d4 1c00          .dw DO_COLON
                 PFA_MPLUS:
0000d5 0d62          .dw XT_S2D
0000d6 0139          .dw XT_DPLUS
0000d7 1c1a          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
0000d8 ff03          .dw $ff03
0000d9 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
0000da 002a          .db "ud*"
0000db 00d1          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
0000dc 1c00          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
0000dd 1cab
0000de 1cf9
0000df 1dda
0000e0 1cd3              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
0000e1 1cbe
0000e2 1cf0
0000e3 1dda
0000e4 1cdb
0000e5 1d97
0000e6 1c1a              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
0000e7 ff04          .dw $ff04
0000e8 6d75
0000e9 7861          .db "umax"
0000ea 00d8          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
0000eb 1c00          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
0000ec 0588
0000ed 1d56              .DW XT_2DUP,XT_ULESS
0000ee 1c30      	.dw XT_DOCONDBRANCH
0000ef 00f1      	 DEST(UMAX1)
0000f0 1cbe              .DW XT_SWAP
0000f1 1cd3      UMAX1:  .DW XT_DROP
0000f2 1c1a      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
0000f3 ff04          .dw $ff04
0000f4 6d75
0000f5 6e69          .db "umin"
0000f6 00e7          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
0000f7 1c00          .dw DO_COLON
                 PFA_UMIN:
                 .endif
0000f8 0588
0000f9 1d61              .DW XT_2DUP,XT_UGREATER
0000fa 1c30      	.dw XT_DOCONDBRANCH
0000fb 00fd      	DEST(UMIN1)
0000fc 1cbe              .DW XT_SWAP
0000fd 1cd3      UMIN1:  .DW XT_DROP
0000fe 1c1a      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
0000ff 1c00          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000100 1c37          .dw XT_DOLITERAL
000101 8000          .dw $8000
000102 1e0d          .dw XT_AND
000103 1d14          .dw XT_ZEROEQUAL
000104 1c30          .dw XT_DOCONDBRANCH
000105 0109          DEST(IMMEDIATEQ1)
000106 1c37           .dw XT_DOLITERAL
000107 0001           .dw 1
000108 1c1a           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
000109 1d45          .dw XT_TRUE
00010a 1c1a          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
00010b ff0a          .dw $ff0a
00010c 616e
00010d 656d
00010e 663e
00010f 616c
000110 7367          .db "name>flags"
000111 00f3          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000112 1c00          .dw DO_COLON
                 PFA_NAME2FLAGS:
000113 1fba          .dw XT_FETCHI ; skip to link field
000114 1c37          .dw XT_DOLITERAL
000115 ff00          .dw $ff00
000116 1e0d          .dw XT_AND
000117 1c1a          .dw XT_EXIT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .include "dict/appl_2k.inc"
                 
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
000118 ff03          .dw $ff03
000119 3264
00011a 002a          .db "d2*",0
00011b 010b          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
00011c 011d          .dw PFA_D2STAR
                 PFA_D2STAR:
00011d 9109          ld temp0, Y+
00011e 9119          ld temp1, Y+
00011f 0f00          lsl temp0
000120 1f11          rol temp1
000121 1f88          rol tosl
000122 1f99          rol tosh
000123 931a          st -Y, temp1
000124 930a          st -Y, temp0
000125 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
000127 ff03          .dw $ff03
000128 3264
000129 002f          .db "d2/",0
00012a 0118          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
00012b 012c          .dw PFA_D2SLASH
                 PFA_D2SLASH:
00012c 9109          ld temp0, Y+
00012d 9119          ld temp1, Y+
00012e 9595          asr tosh
00012f 9587          ror tosl
000130 9517          ror temp1
000131 9507          ror temp0
000132 931a          st -Y, temp1
000133 930a          st -Y, temp0
000134 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
000136 ff02          .dw $ff02
000137 2b64          .db "d+"
000138 0127          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
000139 013a          .dw PFA_DPLUS
                 PFA_DPLUS:
00013a 9129          ld temp2, Y+
00013b 9139          ld temp3, Y+
                 
00013c 90e9          ld temp4, Y+
00013d 90f9          ld temp5, Y+
00013e 9149          ld temp6, Y+
00013f 9159          ld temp7, Y+
                 
000140 0f24          add temp2, temp6
000141 1f35          adc temp3, temp7
000142 1d8e          adc tosl, temp4
000143 1d9f          adc tosh, temp5
                     
000144 933a          st -Y, temp3
000145 932a          st -Y, temp2
000146 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
000148 ff02          .dw $ff02
000149 2d64          .db "d-"
00014a 0136          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
00014b 014c          .dw PFA_DMINUS
                 PFA_DMINUS:
00014c 9129          ld temp2, Y+
00014d 9139          ld temp3, Y+
                 
00014e 90e9          ld temp4, Y+
00014f 90f9          ld temp5, Y+
000150 9149          ld temp6, Y+
000151 9159          ld temp7, Y+
                 
000152 1b42          sub temp6, temp2
000153 0b53          sbc temp7, temp3
000154 0ae8          sbc temp4, tosl
000155 0af9          sbc temp5, tosh
                 
000156 935a          st -Y, temp7
000157 934a          st -Y, temp6
000158 01c7          movw tosl, temp4
000159 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
00015b ff07          .dw $ff07
00015c 6964
00015d 766e
00015e 7265
00015f 0074          .db "dinvert",0
000160 0148          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
000161 0162          .dw PFA_DINVERT
                 PFA_DINVERT:
000162 9109          ld temp0, Y+
000163 9119          ld temp1, Y+
000164 9580          com tosl
000165 9590          com tosh
000166 9500          com temp0
000167 9510          com temp1
000168 931a          st -Y, temp1
000169 930a          st -Y, temp0
00016a 940c 1c04     jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
00016c ff02          .dw $ff02
00016d 3d64          .db "d="
00016e 015b          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
00016f 1c00          .dw DO_COLON
                 PFA_DEQUAL:
000170 014b          .dw XT_DMINUS
000171 1e16          .dw XT_OR
000172 1d14          .dw XT_ZEROEQUAL
000173 1c1a          .dw XT_EXIT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
000174 ff02          .dw $ff02
000175 2e75          .db "u."
000176 016c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
000177 1c00          .dw DO_COLON
                 PFA_UDOT:
                 .endif
000178 1d4e          .dw XT_ZERO
000179 0752          .dw XT_UDDOT
00017a 1c1a          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
00017b ff03          .dw $ff03
00017c 2e75
00017d 0072          .db "u.r",0
00017e 0174          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
00017f 1c00          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
000180 1d4e          .dw XT_ZERO
000181 1cbe          .dw XT_SWAP
000182 075b          .dw XT_UDDOTR
000183 1c1a          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
000184 ff0d          .dw $ff0d
000185 6873
000186 776f
000187 772d
000188 726f
000189 6c64
00018a 7369
00018b 0074          .db "show-wordlist",0
00018c 017b          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
00018d 1c00          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
00018e 1c37          .dw XT_DOLITERAL
00018f 0193          .dw XT_SHOWWORD
000190 1cbe          .dw XT_SWAP
000191 0c51          .dw XT_TRAVERSEWORDLIST
000192 1c1a          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
000193 1c00          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
000194 0c6c          .dw XT_NAME2STRING
000195 07c8          .dw XT_ITYPE
000196 080a          .dw XT_SPACE         ; ( -- addr n)
000197 1d45          .dw XT_TRUE
000198 1c1a          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_WORDS:
000199 ff05          .dw $ff05
00019a 6f77
00019b 6472
00019c 0073          .db "words",0
00019d 0184          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
00019e 1c00          .dw DO_COLON
                 PFA_WORDS:
                 .endif
00019f 1c37          .dw XT_DOLITERAL
0001a0 0044          .dw CFG_ORDERLISTLEN+2
0001a1 1f4d          .dw XT_FETCHE
0001a2 018d          .dw XT_SHOWWORDLIST
0001a3 1c1a          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
0001a4 ff04          .dw $ff04
0001a5 692b
0001a6 746e          .db "+int"
0001a7 0199          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
0001a8 01a9          .dw PFA_INTON
                 PFA_INTON:
0001a9 9478          sei
0001aa 940c 1c04     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
0001ac ff04          .dw $ff04
0001ad 692d
0001ae 746e          .db "-int"
0001af 01a4          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
0001b0 01b1          .dw PFA_INTOFF
                 PFA_INTOFF:
0001b1 94f8          cli
0001b2 940c 1c04     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
0001b4 ff04          .dw $ff04
0001b5 6e69
0001b6 2174          .db "int!"
0001b7 01ac          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
0001b8 1c00          .dw DO_COLON
                 PFA_INTSTORE:
0001b9 1c37          .dw XT_DOLITERAL
0001ba 0000          .dw intvec
0001bb 1d97          .dw XT_PLUS
0001bc 1f29          .dw XT_STOREE
0001bd 1c1a          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
0001be ff04          .dw $ff04
0001bf 6e69
0001c0 4074          .db "int@"
0001c1 01b4          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
0001c2 1c00          .dw DO_COLON
                 PFA_INTFETCH:
0001c3 1c37          .dw XT_DOLITERAL
0001c4 0000          .dw intvec
0001c5 1d97          .dw XT_PLUS
0001c6 1f4d          .dw XT_FETCHE
0001c7 1c1a          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
0001c8 ff08          .dw $ff08
0001c9 6e69
0001ca 2d74
0001cb 7274
0001cc 7061          .db "int-trap"
0001cd 01be          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
0001ce 01cf          .dw PFA_INTTRAP
                 PFA_INTTRAP:
0001cf 9380 0116     sts intcur, tosl
0001d1 9189
0001d2 9199          loadtos
0001d3 9468          set ; set the interrupt flag for the inner interpreter
0001d4 940c 1c04     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
0001d6 1c00          .dw DO_COLON
                 PFA_ISREXEC:
0001d7 1c37          .dw XT_DOLITERAL
0001d8 0116          .dw intcur
0001d9 1c92          .dw XT_CFETCH
0001da 1c37          .dw XT_DOLITERAL
0001db 0000          .dw intvec
0001dc 1d97          .dw XT_PLUS
0001dd 1f4d          .dw XT_FETCHE
0001de 1c24          .dw XT_EXECUTE
0001df 01e1          .dw XT_ISREND
0001e0 1c1a          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
0001e1 01e2          .dw PFA_ISREND
                 PFA_ISREND:
0001e2 d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
0001e3 940c 1c04     jmp_ DO_NEXT
                 PFA_ISREND1:
0001e5 9518          reti
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
0001e6 ff04          .dw $ff04
0001e7 6970
0001e8 6b63          .db "pick"
0001e9 01c8          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
0001ea 1c00          .dw DO_COLON
                 PFA_PICK:
                 .endif
0001eb 1e29          .dw XT_1PLUS
0001ec 057a          .dw XT_CELLS
0001ed 1e7b          .dw XT_SP_FETCH
0001ee 1d97          .dw XT_PLUS
0001ef 1c73          .dw XT_FETCH
0001f0 1c1a          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
0001f1 0002          .dw $0002
0001f2 222e          .db ".",$22
0001f3 01e6          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
0001f4 1c00          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
0001f5 01fc          .dw XT_SQUOTE
0001f6 0250          .dw XT_COMPILE
0001f7 07c8          .dw XT_ITYPE
0001f8 1c1a          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
0001f9 0002        .dw $0002
0001fa 2273        .db "s",$22
0001fb 01f1        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
0001fc 1c00          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
0001fd 1c37          .dw XT_DOLITERAL
0001fe 0022          .dw 34   ; 0x22 
0001ff 09a8          .dw XT_PARSE       ; ( -- addr n)
000200 056d          .dw XT_STATE
000201 1c73          .dw XT_FETCH
000202 1c30          .dw XT_DOCONDBRANCH
000203 0205          DEST(PFA_SQUOTE1)
000204 027c            .dw XT_SLITERAL
                 PFA_SQUOTE1:
000205 1c1a          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
000206 ff04          .dw $ff04
000207 6966
000208 6c6c          .db "fill"
000209 01f9          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
00020a 1c00          .dw DO_COLON
                 PFA_FILL:
00020b 1cdb          .dw XT_ROT
00020c 1cdb          .dw XT_ROT
00020d 1cb3
00020e 1c30          .dw XT_QDUP,XT_DOCONDBRANCH
00020f 0217          DEST(PFA_FILL2)
000210 0d59          .dw XT_BOUNDS
000211 1e89          .dw XT_DODO
                 PFA_FILL1:
000212 1cab          .dw XT_DUP
000213 1e9a          .dw XT_I
000214 1c87          .dw XT_CSTORE  ; ( -- c c-addr)
000215 1eb7          .dw XT_DOLOOP
000216 0212          .dw PFA_FILL1
                 PFA_FILL2:
000217 1cd3          .dw XT_DROP
000218 1c1a          .dw XT_EXIT
                 .include "dict/compiler1.inc"
                 
                 .include "words/newest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_NEWEST:
000219 ff06          .dw $ff06
00021a 656e
00021b 6577
00021c 7473          .db "newest"
00021d 0206          .dw VE_HEAD
                     .set VE_HEAD = VE_NEWEST
                 XT_NEWEST:
00021e 1c42          .dw PFA_DOVARIABLE
                 PFA_NEWEST:
00021f 0117          .dw ram_newest
                 
                 .dseg
000117           ram_newest: .byte 4
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_LATEST:
000220 ff06          .dw $ff06
000221 616c
000222 6574
000223 7473          .db "latest"
000224 0219          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000225 1c42          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000226 011b          .dw ram_latest
                 
                 .dseg
00011b           ram_latest: .byte 2
                 .include "words/do-create.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE:
000227 ff08          .dw $ff08
000228 6328
000229 6572
00022a 7461
00022b 2965          .db "(create)"
00022c 0220          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
00022d 1c00          .dw DO_COLON
                 PFA_DOCREATE:
                 .endif
00022e 09d5
00022f 0384          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
000230 1cab
000231 021e
000232 0580
000233 1c7b          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
000234 0369
000235 021e
000236 1c7b          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
000237 1c1a          .DW XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
000238 0001          .dw $0001
000239 005c          .db $5c,0
00023a 0227          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
00023b 1c00          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
00023c 09bc          .dw XT_SOURCE
00023d 1cea          .dw XT_NIP
00023e 05a1          .dw XT_TO_IN
00023f 1c7b          .dw XT_STORE
000240 1c1a          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
000241 0001          .dw $0001
000242 0028          .db "(" ,0
000243 0238          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
000244 1c00          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
000245 1c37          .dw XT_DOLITERAL
000246 0029          .dw ')'
000247 09a8          .dw XT_PARSE
000248 0591          .dw XT_2DROP
000249 1c1a          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
00024a ff07          .dw $ff07
00024b 6f63
00024c 706d
00024d 6c69
00024e 0065          .db "compile",0
00024f 0241          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
000250 1c00          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
000251 1cf0          .dw XT_R_FROM
000252 1cab          .dw XT_DUP
000253 0ba5          .dw XT_ICELLPLUS
000254 1cf9          .dw XT_TO_R
000255 1fba          .dw XT_FETCHI
000256 025b          .dw XT_COMMA
000257 1c1a          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
000258 ff01          .dw $ff01
000259 002c          .db ',',0 ; ,
00025a 024a          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
00025b 1c00          .dw DO_COLON
                 PFA_COMMA:
00025c 05d1          .dw XT_DP
00025d 1f61          .dw XT_STOREI
00025e 05d1          .dw XT_DP
00025f 1e29          .dw XT_1PLUS
000260 0b93          .dw XT_DOTO
000261 05d2          .dw PFA_DP
000262 1c1a          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
000263 0003          .dw $0003
000264 275b
000265 005d          .db "[']",0
000266 0258          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
000267 1c00          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
000268 0832          .dw XT_TICK
000269 0271          .dw XT_LITERAL
00026a 1c1a          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
00026b 0007          .dw $0007
00026c 696c
00026d 6574
00026e 6172
00026f 006c          .db "literal",0
000270 0263          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000271 1c00          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
000272 0250              .DW XT_COMPILE
000273 1c37              .DW XT_DOLITERAL
000274 025b              .DW XT_COMMA
000275 1c1a              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
000276 0008        .dw $0008
000277 6c73
000278 7469
000279 7265
00027a 6c61        .db "sliteral"
00027b 026b        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
00027c 1c00          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
00027d 0250          .dw XT_COMPILE
00027e 0795          .dw XT_DOSLITERAL    ; ( -- addr n)
00027f 07a3          .dw XT_SCOMMA
000280 1c1a          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000281 1c00          .dw DO_COLON
                 PFA_GMARK:
000282 05d1          .dw XT_DP
000283 0250          .dw XT_COMPILE
000284 ffff          .dw -1           ; ffff does not erase flash
000285 1c1a          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
000286 1c00          .dw DO_COLON
                 PFA_GRESOLVE:
000287 0b51          .dw XT_QSTACK
000288 05d1          .dw XT_DP
000289 1cbe          .dw XT_SWAP
00028a 1f61          .dw XT_STOREI
00028b 1c1a          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
00028c 1c00          .dw DO_COLON
                 PFA_LMARK:
00028d 05d1          .dw XT_DP
00028e 1c1a          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
00028f 1c00          .dw DO_COLON
                 PFA_LRESOLVE:
000290 0b51          .dw XT_QSTACK
000291 025b          .dw XT_COMMA
000292 1c1a          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
000293 0005          .dw $0005
000294 6861
000295 6165
000296 0064          .db "ahead",0
000297 0276          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000298 1c00          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
000299 0250          .dw XT_COMPILE
00029a 1c29          .dw XT_DOBRANCH
00029b 0281          .dw XT_GMARK
00029c 1c1a          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
00029d 0002          .dw $0002
00029e 6669          .db "if"
00029f 0293          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
0002a0 1c00          .dw DO_COLON
                 PFA_IF:
                 .endif
0002a1 0250          .dw XT_COMPILE
0002a2 1c30          .dw XT_DOCONDBRANCH
0002a3 0281          .dw XT_GMARK
0002a4 1c1a          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
0002a5 0004          .dw $0004
0002a6 6c65
0002a7 6573          .db "else"
0002a8 029d          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
0002a9 1c00          .dw DO_COLON
                 PFA_ELSE:
                 .endif
0002aa 0250          .dw XT_COMPILE
0002ab 1c29          .dw XT_DOBRANCH
0002ac 0281          .dw XT_GMARK
0002ad 1cbe          .dw XT_SWAP
0002ae 0286          .dw XT_GRESOLVE
0002af 1c1a          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
0002b0 0004          .dw $0004
0002b1 6874
0002b2 6e65          .db "then"
0002b3 02a5          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
0002b4 1c00          .dw DO_COLON
                 PFA_THEN:
                 .endif
0002b5 0286          .dw XT_GRESOLVE
0002b6 1c1a          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
0002b7 0005          .dw $0005
0002b8 6562
0002b9 6967
0002ba 006e          .db "begin",0
0002bb 02b0          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
0002bc 1c00          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
0002bd 028c          .dw XT_LMARK
0002be 1c1a          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
0002bf 0005          .dw $0005
0002c0 6877
0002c1 6c69
0002c2 0065          .db "while",0
0002c3 02b7          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
0002c4 1c00          .dw DO_COLON
                 PFA_WHILE:
                 .endif
0002c5 02a0          .dw XT_IF
0002c6 1cbe          .dw XT_SWAP
0002c7 1c1a          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
0002c8 0006          .dw $0006
0002c9 6572
0002ca 6570
0002cb 7461          .db "repeat"
0002cc 02bf          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
0002cd 1c00          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
0002ce 02e1          .dw XT_AGAIN
0002cf 02b4          .dw XT_THEN
0002d0 1c1a          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
0002d1 0005          .dw $0005
0002d2 6e75
0002d3 6974
0002d4 006c          .db "until",0
0002d5 02c8          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
0002d6 1c00          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
0002d7 1c37          .dw XT_DOLITERAL
0002d8 1c30          .dw XT_DOCONDBRANCH
0002d9 025b          .dw XT_COMMA
                 
0002da 028f          .dw XT_LRESOLVE
0002db 1c1a          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
0002dc 0005          .dw $0005
0002dd 6761
0002de 6961
0002df 006e          .db "again",0
0002e0 02d1          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
0002e1 1c00          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
0002e2 0250          .dw XT_COMPILE
0002e3 1c29          .dw XT_DOBRANCH
0002e4 028f          .dw XT_LRESOLVE
0002e5 1c1a          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
0002e6 0002          .dw $0002
0002e7 6f64          .db "do"
0002e8 02dc          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
0002e9 1c00          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
0002ea 0250          .dw XT_COMPILE
0002eb 1e89          .dw XT_DODO
0002ec 028c          .dw XT_LMARK
0002ed 1d4e          .dw XT_ZERO
0002ee 0344          .dw XT_TO_L
0002ef 1c1a          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
0002f0 0004          .dw $0004
0002f1 6f6c
0002f2 706f          .db "loop"
0002f3 02e6          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
0002f4 1c00          .dw DO_COLON
                 PFA_LOOP:
                 .endif
0002f5 0250          .dw XT_COMPILE
0002f6 1eb7          .dw XT_DOLOOP
0002f7 032b          .dw XT_ENDLOOP
0002f8 1c1a          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
0002f9 0005          .dw $0005
0002fa 6c2b
0002fb 6f6f
0002fc 0070          .db "+loop",0
0002fd 02f0          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
0002fe 1c00          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
0002ff 0250          .dw XT_COMPILE
000300 1ea8          .dw XT_DOPLUSLOOP
000301 032b          .dw XT_ENDLOOP
000302 1c1a          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
000303 0005         .dw $0005
000304 656c
000305 7661
000306 0065         .db "leave",0
000307 02f9         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000308 1c00          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
000309 0250
00030a 1ec2          .DW XT_COMPILE,XT_UNLOOP
00030b 0298
00030c 0344
00030d 1c1a          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
00030e 0003          .dw $0003
00030f 643f
000310 006f          .db "?do",0
000311 0303          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
000312 1c00          .dw DO_COLON
                 PFA_QDO:
                 .endif
000313 0250          .dw XT_COMPILE
000314 031a          .dw XT_QDOCHECK
000315 02a0          .dw XT_IF
000316 02e9          .dw XT_DO
000317 1cbe          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
000318 0344          .dw XT_TO_L    ; then follows at the end.
000319 1c1a          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
00031a 1c00          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
00031b 0588          .dw XT_2DUP
00031c 1fcf          .dw XT_EQUAL
00031d 1cab          .dw XT_DUP
00031e 1cf9          .dw XT_TO_R
00031f 1c30          .dw XT_DOCONDBRANCH
000320 0322          DEST(PFA_QDOCHECK1)
000321 0591          .dw XT_2DROP
                 PFA_QDOCHECK1:
000322 1cf0          .dw XT_R_FROM
000323 1df7          .dw XT_INVERT
000324 1c1a          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
000325 ff07          .dw $ff07
000326 6e65
000327 6c64
000328 6f6f
000329 0070          .db "endloop",0
00032a 030e          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
00032b 1c00          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
00032c 028f              .DW XT_LRESOLVE
00032d 0338
00032e 1cb3
00032f 1c30      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
000330 0334               DEST(LOOP2)
000331 02b4              .DW XT_THEN
000332 1c29      	.dw XT_DOBRANCH
000333 032d               DEST(LOOP1)
000334 1c1a      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
000335 ff02          .dw $ff02
000336 3e6c          .db "l>"
000337 0325          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
000338 1c00          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
000339 0357          .dw XT_LP
00033a 1c73          .dw XT_FETCH
00033b 1c73          .dw XT_FETCH
00033c 1c37          .dw XT_DOLITERAL
00033d fffe          .dw -2
00033e 0357          .dw XT_LP
00033f 1e53          .dw XT_PLUSSTORE
000340 1c1a          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
000341 ff02          .dw $ff02
000342 6c3e          .db ">l"
000343 0335          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
000344 1c00          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
000345 1fdb              .dw XT_TWO
000346 0357      	.dw XT_LP
000347 1e53      	.dw XT_PLUSSTORE
000348 0357      	.dw XT_LP
000349 1c73      	.dw XT_FETCH
00034a 1c7b      	.dw XT_STORE
00034b 1c1a      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
00034c ff03          .dw $ff03
00034d 706c
00034e 0030          .db "lp0",0
00034f 0341          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
000350 1c69          .dw PFA_DOVALUE1
                 PFA_LP0:
000351 0038          .dw CFG_LP0
000352 0bae          .dw XT_EDEFERFETCH
000353 0bb8          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
000354 ff02          .dw $ff02
000355 706c          .db "lp"
000356 034c          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
000357 1c42          .dw PFA_DOVARIABLE
                 PFA_LP:
000358 011d          .dw ram_lp
                 
                 .dseg
00011d           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CREATE:
000359 ff06          .dw $ff06
00035a 7263
00035b 6165
00035c 6574          .db "create"
00035d 0354          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
00035e 1c00          .dw DO_COLON
                 PFA_CREATE:
                 .endif
00035f 022d          .dw XT_DOCREATE
000360 038d          .dw XT_REVEAL
000361 0250          .dw XT_COMPILE
000362 1c4c          .dw PFA_DOCONSTANT
000363 1c1a          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
000364 ff06          .dw $ff06
000365 6568
000366 6461
000367 7265          .db "header"
000368 0359          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
000369 1c00          .dw DO_COLON
                 PFA_HEADER:
00036a 05d1          .dw XT_DP           ; the new Name Field
00036b 1cf9          .dw XT_TO_R
00036c 1cf9          .dw XT_TO_R		; ( R: NFA WID )
00036d 1cab          .dw XT_DUP    
00036e 1d22          .dw XT_GREATERZERO 
00036f 1c30          .dw XT_DOCONDBRANCH
000370 037b          .dw PFA_HEADER1
000371 1cab          .dw XT_DUP
000372 1c37          .dw XT_DOLITERAL
000373 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
000374 1e16          .dw XT_OR
000375 07a7          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
000376 1cf0          .dw XT_R_FROM
000377 1f4d          .dw XT_FETCHE
000378 025b          .dw XT_COMMA
000379 1cf0          .dw XT_R_FROM
00037a 1c1a          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
00037b 1c37          .dw XT_DOLITERAL
00037c fff0          .dw -16
00037d 0861          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
00037e ff07          .dw $ff07
00037f 6c77
000380 6373
000381 706f
000382 0065          .db "wlscope",0
000383 0364          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
000384 0c0d          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
000385 0036          .dw CFG_WLSCOPE
000386 0bae          .dw XT_EDEFERFETCH
000387 0bb8          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REVEAL:
000388 ff06          .dw $ff06
000389 6572
00038a 6576
00038b 6c61          .db "reveal"
00038c 037e          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
00038d 1c00          .dw DO_COLON
                 PFA_REVEAL:
                 .endif
00038e 021e
00038f 0580
000390 1c73          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
000391 1cb3
000392 1c30          .DW XT_QDUP,XT_DOCONDBRANCH
000393 0398          DEST(REVEAL1)
000394 021e
000395 1c73
000396 1cbe
000397 1f29          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                 REVEAL1:
000398 1c1a          .DW XT_EXIT
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000399 0005          .dw $0005
00039a 6f64
00039b 7365
00039c 003e          .db "does>",0
00039d 0388          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
00039e 1c00          .dw DO_COLON
                 PFA_DOES:
00039f 0250          .dw XT_COMPILE
0003a0 03b1          .dw XT_DODOES
0003a1 0250          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
0003a2 940e          .dw $940e       ; the address of this compiled
0003a3 0250          .dw XT_COMPILE  ; code will replace the XT of the 
0003a4 03a6          .dw DO_DODOES   ; word that CREATE created
0003a5 1c1a          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
0003a6 939a
0003a7 938a          savetos
0003a8 01cb          movw tosl, wl
0003a9 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
0003aa 917f          pop wh
0003ab 916f          pop wl
                 
0003ac 93bf          push XH
0003ad 93af          push XL
0003ae 01db          movw XL, wl
0003af 940c 1c04     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
0003b1 1c00          .dw DO_COLON
                 PFA_DODOES:
0003b2 1cf0          .dw XT_R_FROM
0003b3 021e          .dw XT_NEWEST
0003b4 0580          .dw XT_CELLPLUS
0003b5 1c73          .dw XT_FETCH
0003b6 1f4d          .dw XT_FETCHE
0003b7 0c78          .dw XT_NFA2CFA
0003b8 1f61          .dw XT_STOREI
0003b9 1c1a          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
0003ba ff01          .dw $ff01
0003bb 003a          .db ":",0
0003bc 0399          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
0003bd 1c00          .dw DO_COLON
                 PFA_COLON:
                 .endif
0003be 022d          .dw XT_DOCREATE
0003bf 03c8          .dw XT_COLONNONAME
0003c0 1cd3          .dw XT_DROP
0003c1 1c1a          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
0003c2 ff07          .dw $ff07
0003c3 6e3a
0003c4 6e6f
0003c5 6d61
0003c6 0065          .db ":noname",0
0003c7 03ba          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
0003c8 1c00          .dw DO_COLON
                 PFA_COLONNONAME:
0003c9 05d1          .dw XT_DP
0003ca 1cab          .dw XT_DUP
0003cb 0225          .dw XT_LATEST
0003cc 1c7b          .dw XT_STORE
                 
0003cd 0250          .dw XT_COMPILE
0003ce 1c00          .dw DO_COLON
                 
0003cf 03dd          .dw XT_RBRACKET
0003d0 1c1a          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
0003d1 0001          .dw $0001
0003d2 003b          .db $3b,0
0003d3 03c2          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
0003d4 1c00          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
0003d5 0250          .dw XT_COMPILE
0003d6 1c1a          .dw XT_EXIT
0003d7 03e5          .dw XT_LBRACKET
0003d8 038d          .dw XT_REVEAL
0003d9 1c1a          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
0003da ff01          .dw $ff01
0003db 005d          .db "]",0
0003dc 03d1          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
0003dd 1c00          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
0003de 1fd6          .dw XT_ONE
0003df 056d          .dw XT_STATE
0003e0 1c7b          .dw XT_STORE
0003e1 1c1a          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
0003e2 0001          .dw $0001
0003e3 005b          .db "[",0
0003e4 03da          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
0003e5 1c00          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
0003e6 1d4e          .dw XT_ZERO
0003e7 056d          .dw XT_STATE
0003e8 1c7b          .dw XT_STORE
0003e9 1c1a          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
0003ea ff08          .dw $ff08
0003eb 6176
0003ec 6972
0003ed 6261
0003ee 656c          .db "variable"
0003ef 03e2          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
0003f0 1c00          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
0003f1 05e2          .dw XT_HERE
0003f2 03fc          .dw XT_CONSTANT
0003f3 1fdb          .dw XT_TWO
0003f4 05eb          .dw XT_ALLOT
0003f5 1c1a          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
0003f6 ff08          .dw $ff08
0003f7 6f63
0003f8 736e
0003f9 6174
0003fa 746e          .db "constant"
0003fb 03ea          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
0003fc 1c00          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
0003fd 022d          .dw XT_DOCREATE
0003fe 038d          .dw XT_REVEAL
0003ff 0250          .dw XT_COMPILE
000400 1c42          .dw PFA_DOVARIABLE
000401 025b          .dw XT_COMMA
000402 1c1a          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000403 ff04          .dw $ff04
000404 7375
000405 7265          .db "user"
000406 03f6          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000407 1c00          .dw DO_COLON
                 PFA_USER:
000408 022d          .dw XT_DOCREATE
000409 038d          .dw XT_REVEAL
                 
00040a 0250          .dw XT_COMPILE
00040b 1c52          .dw PFA_DOUSER
00040c 025b          .dw XT_COMMA
00040d 1c1a          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECURSE:
00040e 0007          .dw $0007
00040f 6572
000410 7563
000411 7372
000412 0065          .db "recurse",0
000413 0403          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000414 1c00          .dw DO_COLON
                 PFA_RECURSE:
                 .endif
000415 0225          .dw XT_LATEST
000416 1c73          .dw XT_FETCH
000417 025b          .dw XT_COMMA
000418 1c1a          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000419 ff09          .dw $ff09
00041a 6d69
00041b 656d
00041c 6964
00041d 7461
00041e 0065          .db "immediate",0
00041f 040e          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000420 1c00          .dw DO_COLON
                 PFA_IMMEDIATE:
000421 04bb          .dw XT_GET_CURRENT
000422 1f4d          .dw XT_FETCHE
000423 1cab          .dw XT_DUP
000424 1fba          .dw XT_FETCHI
000425 1c37          .dw XT_DOLITERAL
000426 7fff          .dw $7fff
000427 1e0d          .dw XT_AND
000428 1cbe          .dw XT_SWAP
000429 1f61          .dw XT_STOREI
00042a 1c1a          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
00042b 0006          .dw $0006
00042c 635b
00042d 6168
00042e 5d72          .db "[char]"
00042f 0419          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000430 1c00          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
000431 0250          .dw XT_COMPILE
000432 1c37          .dw XT_DOLITERAL
000433 090a          .dw XT_CHAR
000434 025b          .dw XT_COMMA
000435 1c1a          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
000436 0006          .dw $0006
000437 6261
000438 726f
000439 2274          .db "abort",'"'
00043a 042b          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
00043b 1c00          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
00043c 01fc          .dw XT_SQUOTE
00043d 0250          .dw XT_COMPILE
00043e 044d          .dw XT_QABORT
00043f 1c1a          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
000440 ff05          .dw $ff05
000441 6261
000442 726f
000443 0074          .db "abort",0
000444 0436          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000445 1c00          .dw DO_COLON
                 PFA_ABORT:
                 .endif
000446 1d45          .dw XT_TRUE
000447 0861          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
000448 ff06          .dw $ff06
000449 613f
00044a 6f62
00044b 7472          .db "?abort"
00044c 0440          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
00044d 1c00          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
00044e 1cdb
00044f 1c30              .DW XT_ROT,XT_DOCONDBRANCH
000450 0453              DEST(QABO1)
000451 07c8
000452 0445              .DW XT_ITYPE,XT_ABORT
000453 0591
000454 1c1a      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
000455 ff09          .dw $ff09
000456 6567
000457 2d74
000458 7473
000459 6361
00045a 006b          .db "get-stack",0
00045b 0448          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
00045c 1c00          .dw DO_COLON
                 .endif
00045d 1cab          .dw XT_DUP
00045e 0580          .dw XT_CELLPLUS
00045f 1cbe          .dw XT_SWAP
000460 1f4d          .dw XT_FETCHE
000461 1cab          .dw XT_DUP
000462 1cf9          .dw XT_TO_R
000463 1d4e          .dw XT_ZERO
000464 1cbe          .dw XT_SWAP    ; go from bigger to smaller addresses
000465 031a          .dw XT_QDOCHECK
000466 1c30          .dw XT_DOCONDBRANCH
000467 0473          DEST(PFA_N_FETCH_E2)
000468 1e89          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
000469 1e9a          .dw XT_I
00046a 1e2f          .dw XT_1MINUS
00046b 057a          .dw XT_CELLS ; ( -- ee-addr i*2 )
00046c 1cc9          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
00046d 1d97          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
00046e 1f4d          .dw XT_FETCHE ;( -- ee-addr item_i )
00046f 1cbe          .dw XT_SWAP   ;( -- item_i ee-addr )
000470 1d45          .dw XT_TRUE  ; shortcut for -1
000471 1ea8          .dw XT_DOPLUSLOOP
000472 0469          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
000473 0591          .dw XT_2DROP
000474 1cf0          .dw XT_R_FROM
000475 1c1a          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
000476 ff09          .dw $ff09
000477 6573
000478 2d74
000479 7473
00047a 6361
00047b 006b          .db "set-stack",0
00047c 0455          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
00047d 1c00          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
00047e 0588          .dw XT_2DUP
00047f 1f29          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000480 1cbe          .dw XT_SWAP    
000481 1d4e          .dw XT_ZERO
000482 031a          .dw XT_QDOCHECK
000483 1c30          .dw XT_DOCONDBRANCH
000484 048b          DEST(PFA_SET_STACK2)
000485 1e89          .dw XT_DODO
                 PFA_SET_STACK1:
000486 0580          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000487 0599          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
000488 1f29          .dw XT_STOREE
000489 1eb7          .dw XT_DOLOOP
00048a 0486          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
00048b 1cd3          .dw XT_DROP
00048c 1c1a          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
00048d ff09          .dw $ff09
00048e 616d
00048f 2d70
000490 7473
000491 6361
000492 006b          .db "map-stack",0
000493 0476          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
000494 1c00          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
000495 1cab          .dw XT_DUP
000496 0580          .dw XT_CELLPLUS
000497 1cbe          .dw XT_SWAP
000498 1f4d          .dw XT_FETCHE
000499 057a          .dw XT_CELLS
00049a 0d59          .dw XT_BOUNDS
00049b 031a          .dw XT_QDOCHECK
00049c 1c30          .dw XT_DOCONDBRANCH
00049d 04b0          DEST(PFA_MAPSTACK3)
00049e 1e89          .dw XT_DODO
                 PFA_MAPSTACK1:
00049f 1e9a            .dw XT_I
0004a0 1f4d            .dw XT_FETCHE   ; -- i*x XT id
0004a1 1cbe            .dw XT_SWAP
0004a2 1cf9            .dw XT_TO_R
0004a3 1d02            .dw XT_R_FETCH
0004a4 1c24            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
0004a5 1cb3            .dw XT_QDUP
0004a6 1c30            .dw XT_DOCONDBRANCH
0004a7 04ac            DEST(PFA_MAPSTACK2)
0004a8 1cf0               .dw XT_R_FROM
0004a9 1cd3               .dw XT_DROP
0004aa 1ec2               .dw XT_UNLOOP
0004ab 1c1a               .dw XT_EXIT
                 PFA_MAPSTACK2:
0004ac 1cf0            .dw XT_R_FROM
0004ad 1fdb            .dw XT_TWO
0004ae 1ea8            .dw XT_DOPLUSLOOP
0004af 049f            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
0004b0 1cd3          .dw XT_DROP
0004b1 1d4e          .dw XT_ZERO
0004b2 1c1a          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
0004b3 ff0b          .dw $ff0b
0004b4 6567
0004b5 2d74
0004b6 7563
0004b7 7272
0004b8 6e65
0004b9 0074          .db "get-current",0
0004ba 048d          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
0004bb 1c00          .dw DO_COLON
                 PFA_GET_CURRENT:
0004bc 1c37          .dw XT_DOLITERAL
0004bd 003e          .dw CFG_CURRENT
0004be 1f4d          .dw XT_FETCHE
0004bf 1c1a          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_ORDER:
0004c0 ff09          .dw $ff09
0004c1 6567
0004c2 2d74
0004c3 726f
0004c4 6564
0004c5 0072          .db "get-order",0
0004c6 04b3          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
0004c7 1c00          .dw DO_COLON
                 PFA_GET_ORDER:
                 .endif
0004c8 1c37          .dw XT_DOLITERAL
0004c9 0042          .dw CFG_ORDERLISTLEN
0004ca 045c          .dw XT_GET_STACK
0004cb 1c1a          .dw XT_EXIT
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
0004cc ff07          .dw $ff07
0004cd 6f63
0004ce 706d
0004cf 7261
0004d0 0065          .db "compare",0
0004d1 04c0          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
0004d2 04d3          .dw PFA_COMPARE
                 PFA_COMPARE:
0004d3 93bf          push xh
0004d4 93af          push xl
0004d5 018c          movw temp0, tosl
0004d6 9189
0004d7 9199          loadtos
0004d8 01dc          movw xl, tosl
0004d9 9189
0004da 9199          loadtos
0004db 019c          movw temp2, tosl
0004dc 9189
0004dd 9199          loadtos
0004de 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
0004df 90ed          ld temp4, X+
0004e0 90f1          ld temp5, Z+
0004e1 14ef          cp temp4, temp5
0004e2 f451          brne PFA_COMPARE_NOTEQUAL
0004e3 950a          dec temp0
0004e4 f019          breq PFA_COMPARE_ENDREACHED2
0004e5 952a          dec temp2
0004e6 f7c1          brne PFA_COMPARE_LOOP
0004e7 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
0004e8 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
0004e9 2b02          or temp0, temp2
0004ea f411          brne PFA_COMPARE_CHECKLASTCHAR
0004eb 2788          clr tosl
0004ec c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
0004ed ef8f          ser tosl
0004ee c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
0004ef 2f98          mov tosh, tosl
0004f0 91af          pop xl
0004f1 91bf          pop xh
0004f2 940c 1c04     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
0004f4 ff07         .dw $ff07
0004f5 666e
0004f6 3e61
0004f7 666c
0004f8 0061         .db "nfa>lfa",0
0004f9 04cc         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
0004fa 1c00          .dw DO_COLON
                 PFA_NFA2LFA:
0004fb 0c6c          .dw XT_NAME2STRING
0004fc 1e29          .dw XT_1PLUS
0004fd 1dfe          .dw XT_2SLASH
0004fe 1d97          .dw XT_PLUS
0004ff 1c1a          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000500 ff0b          .dw $ff0b
000501 6e65
000502 6976
000503 6f72
000504 6d6e
000505 6e65
000506 0074          .db "environment",0
000507 04f4          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000508 1c42          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000509 003c          .dw CFG_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
00050a ff09          .dw $ff09
00050b 6f77
00050c 6472
00050d 696c
00050e 7473
00050f 0073          .db "wordlists",0
000510 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000511 1c00          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000512 1c37          .dw XT_DOLITERAL
000513 0008          .dw NUMWORDLISTS
000514 1c1a          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
000515 ff04          .dw $ff04
000516 702f
000517 6461          .db "/pad"
000518 050a          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000519 1c00          .dw DO_COLON
                 PFA_ENVSLASHPAD:
00051a 1e7b          .dw XT_SP_FETCH
00051b 05a7          .dw XT_PAD
00051c 1d8d          .dw XT_MINUS
00051d 1c1a          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENVSLASHHOLD:
00051e ff05          .dw $ff05
00051f 682f
000520 6c6f
000521 0064          .db "/hold",0
000522 0515          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000523 1c00          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
                 .endif
000524 05a7          .dw XT_PAD
000525 05e2          .dw XT_HERE
000526 1d8d          .dw XT_MINUS
000527 1c1a          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
000528 ff0a          .dw $ff0a
000529 6f66
00052a 7472
00052b 2d68
00052c 616e
00052d 656d          .db "forth-name"
00052e 051e          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
00052f 1c00          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000530 0795          .dw XT_DOSLITERAL
000531 0007          .dw 7
                 .endif
000532 6d61
000533 6f66
000534 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
000535 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
000536 1c1a          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
000537 ff07          .dw $ff07
000538 6576
000539 7372
00053a 6f69
00053b 006e          .db "version",0
00053c 0528          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
00053d 1c00          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
00053e 1c37          .dw XT_DOLITERAL
00053f 003d          .dw 61
000540 1c1a          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
000541 ff03          .dw $ff03
000542 7063
000543 0075          .db "cpu",0
000544 0537          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
000545 1c00          .dw DO_COLON
                 PFA_EN_CPU:
                 .endif
000546 1c37          .dw XT_DOLITERAL
000547 0031          .dw mcu_name
000548 07f4          .dw XT_ICOUNT
000549 1c1a          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
00054a ff08          .dw $ff08
00054b 636d
00054c 2d75
00054d 6e69
00054e 6f66          .db "mcu-info"
00054f 0541          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000550 1c00          .dw DO_COLON
                 PFA_EN_MCUINFO:
000551 1c37          .dw XT_DOLITERAL
000552 002d          .dw mcu_info
000553 1c1a          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_ENVUSERSIZE:
000554 ff05          .dw $ff05
000555 752f
000556 6573
000557 0072          .db "/user",0
000558 054a          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
000559 1c00          .dw DO_COLON
                 PFA_ENVUSERSIZE:
                 .endif
00055a 1c37          .dw XT_DOLITERAL
00055b 0026          .dw SYSUSERSIZE + APPUSERSIZE
00055c 1c1a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
00055d ff05          .dw $ff05
00055e 5f66
00055f 7063
000560 0075          .db "f_cpu",0
000561 0500          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
000562 1c00          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
000563 1c37          .dw XT_DOLITERAL
000564 1200          .dw (F_CPU % 65536)
000565 1c37          .dw XT_DOLITERAL
000566 007a          .dw (F_CPU / 65536)
000567 1c1a          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
000568 ff05          .dw $ff05
000569 7473
00056a 7461
00056b 0065          .db "state",0
00056c 055d          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00056d 1c42          .dw PFA_DOVARIABLE
                 PFA_STATE:
00056e 011f          .dw ram_state
                 
                 .dseg
00011f           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
00056f ff04          .dw $ff04
000570 6162
000571 6573          .db "base"
000572 0568          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
000573 1c52          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
000574 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
000575 ff05          .dw $ff05
000576 6563
000577 6c6c
000578 0073          .db "cells",0
000579 056f          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
00057a 1e06          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
00057b ff05          .dw $ff05
00057c 6563
00057d 6c6c
00057e 002b          .db "cell+",0
00057f 0575          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
000580 0581          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
000581 9602          adiw tosl, CELLSIZE
000582 940c 1c04     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
000584 ff04          .dw $ff04
000585 6432
000586 7075          .db "2dup"
000587 057b          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
000588 1c00          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
000589 1cc9          .dw XT_OVER
00058a 1cc9          .dw XT_OVER
00058b 1c1a          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
00058c ff05          .dw $ff05
00058d 6432
00058e 6f72
00058f 0070          .db "2drop",0
000590 0584          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
000591 1c00          .dw DO_COLON
                 PFA_2DROP:
                 .endif
000592 1cd3          .dw XT_DROP
000593 1cd3          .dw XT_DROP
000594 1c1a          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
000595 ff04          .dw $ff04
000596 7574
000597 6b63          .db "tuck"
000598 058c          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
000599 1c00          .dw DO_COLON
                 PFA_TUCK:
                 .endif
00059a 1cbe          .dw XT_SWAP
00059b 1cc9          .dw XT_OVER
00059c 1c1a          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
00059d ff03          .dw $ff03
00059e 693e
00059f 006e          .db ">in",0
0005a0 0595          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
0005a1 1c52          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
0005a2 0018          .dw USER_TO_IN
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PAD:
0005a3 ff03          .dw $ff03
0005a4 6170
0005a5 0064          .db "pad",0
0005a6 059d          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
0005a7 1c00          .dw DO_COLON
                 PFA_PAD:
                 .endif
0005a8 05e2          .dw XT_HERE
0005a9 1c37          .dw XT_DOLITERAL
0005aa 0028          .dw 40
0005ab 1d97          .dw XT_PLUS
0005ac 1c1a          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMIT:
0005ad ff04          .dw $ff04
0005ae 6d65
0005af 7469          .db "emit"
0005b0 05a3          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
0005b1 0c0d          .dw PFA_DODEFER1
                 PFA_EMIT:
                 .endif
0005b2 000e          .dw USER_EMIT
0005b3 0bd6          .dw XT_UDEFERFETCH
0005b4 0be2          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMITQ:
0005b5 ff05          .dw $ff05
0005b6 6d65
0005b7 7469
0005b8 003f          .db "emit?",0
0005b9 05ad          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
0005ba 0c0d          .dw PFA_DODEFER1
                 PFA_EMITQ:
                 .endif
0005bb 0010          .dw USER_EMITQ
0005bc 0bd6          .dw XT_UDEFERFETCH
0005bd 0be2          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEY:
0005be ff03          .dw $ff03
0005bf 656b
0005c0 0079          .db "key",0
0005c1 05b5          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
0005c2 0c0d          .dw PFA_DODEFER1
                 PFA_KEY:
                 .endif
0005c3 0012          .dw USER_KEY
0005c4 0bd6          .dw XT_UDEFERFETCH
0005c5 0be2          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEYQ:
0005c6 ff04          .dw $ff04
0005c7 656b
0005c8 3f79          .db "key?"
0005c9 05be          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
0005ca 0c0d          .dw PFA_DODEFER1
                 PFA_KEYQ:
                 .endif
0005cb 0014          .dw USER_KEYQ
0005cc 0bd6          .dw XT_UDEFERFETCH
0005cd 0be2          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
0005ce ff02          .dw $ff02
0005cf 7064          .db "dp"
0005d0 05c6          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
0005d1 1c69          .dw PFA_DOVALUE1
                 PFA_DP:
0005d2 0030          .dw CFG_DP
0005d3 0bae          .dw XT_EDEFERFETCH
0005d4 0bb8          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
0005d5 ff05          .dw $ff05
0005d6 6865
0005d7 7265
0005d8 0065          .db "ehere",0
0005d9 05ce          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
0005da 1c69          .dw PFA_DOVALUE1
                 PFA_EHERE:
0005db 0034          .dw EE_EHERE
0005dc 0bae          .dw XT_EDEFERFETCH
0005dd 0bb8          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
0005de ff04          .dw $ff04
0005df 6568
0005e0 6572          .db "here"
0005e1 05d5          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
0005e2 1c69          .dw PFA_DOVALUE1
                 PFA_HERE:
0005e3 0032          .dw EE_HERE
0005e4 0bae          .dw XT_EDEFERFETCH
0005e5 0bb8          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
0005e6 ff05          .dw $ff05
0005e7 6c61
0005e8 6f6c
0005e9 0074          .db "allot",0
0005ea 05de          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
0005eb 1c00          .dw DO_COLON
                 PFA_ALLOT:
0005ec 05e2          .dw XT_HERE
0005ed 1d97          .dw XT_PLUS
0005ee 0b93          .dw XT_DOTO
0005ef 05e3          .dw PFA_HERE
0005f0 1c1a          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
0005f1 ff03          .dw $ff03
0005f2 6962
0005f3 006e          .db "bin",0
0005f4 05e6          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
0005f5 1c00          .dw DO_COLON
                 PFA_BIN:
                 .endif
0005f6 1fdb          .dw XT_TWO
0005f7 0573          .dw XT_BASE
0005f8 1c7b          .dw XT_STORE
0005f9 1c1a          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
0005fa ff07          .dw $ff07
0005fb 6564
0005fc 6963
0005fd 616d
0005fe 006c          .db "decimal",0
0005ff 05f1          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
000600 1c00          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
000601 1c37          .dw XT_DOLITERAL
000602 000a          .dw 10
000603 0573          .dw XT_BASE
000604 1c7b          .dw XT_STORE
000605 1c1a          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
000606 ff03          .dw $ff03
000607 6568
000608 0078          .db "hex",0
000609 05fa          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
00060a 1c00          .dw DO_COLON
                 PFA_HEX:
                 .endif
00060b 1c37          .dw XT_DOLITERAL
00060c 0010          .dw 16
00060d 0573          .dw XT_BASE
00060e 1c7b          .dw XT_STORE
00060f 1c1a          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
000610 ff02          .dw $ff02
000611 6c62          .db "bl"
000612 0606          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
000613 1c42          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
000614 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
000615 ff07          .dw $ff07
000616 7574
000617 6e72
000618 656b
000619 0079          .db "turnkey",0
00061a 0610          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
00061b 0c0d          .dw PFA_DODEFER1
                 PFA_TURNKEY:
00061c 003a          .dw CFG_TURNKEY
00061d 0bae          .dw XT_EDEFERFETCH
00061e 0bb8          .dw XT_EDEFERSTORE
                 
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
00061f ff04          .dw $ff04
000620 6d2f
000621 646f          .db "/mod"
000622 0615          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
000623 0624          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
000624 019c          movw temp2, tosl
                     
000625 9109          ld temp0, Y+
000626 9119          ld temp1, Y+
                 
000627 2f41          mov	temp6,temp1	;move dividend High to sign register
000628 2743          eor	temp6,temp3	;xor divisor High with sign register
000629 ff17          sbrs	temp1,7	;if MSB in dividend set
00062a c004          rjmp	PFA_SLASHMOD_1
00062b 9510          com	temp1		;    change sign of dividend
00062c 9500          com	temp0		
00062d 5f0f          subi	temp0,low(-1)
00062e 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
00062f ff37          sbrs	temp3,7	;if MSB in divisor set
000630 c004          rjmp	PFA_SLASHMOD_2
000631 9530          com	temp3		;    change sign of divisor
000632 9520          com	temp2		
000633 5f2f          subi	temp2,low(-1)
000634 4f3f          sbci	temp3,high(-1)
000635 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
000636 18ff          sub	temp5,temp5;clear remainder High byte and carry
000637 e151          ldi	temp7,17	;init loop counter
                 
000638 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
000639 1f11          rol	temp1
00063a 955a          dec	temp7		;decrement counter
00063b f439          brne	PFA_SLASHMOD_5		;if done
00063c ff47          sbrs	temp6,7		;    if MSB in sign register set
00063d c004          rjmp	PFA_SLASHMOD_4
00063e 9510          com	temp1	;        change sign of result
00063f 9500          com	temp0
000640 5f0f          subi	temp0,low(-1)
000641 4f1f          sbci	temp1,high(-1)
000642 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
000643 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
000644 1cff          rol	temp5
000645 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
000646 0af3          sbc	temp5,temp3	;
000647 f420          brcc	PFA_SLASHMOD_6		;if result negative
000648 0ee2          add	temp4,temp2	;    restore remainder
000649 1ef3          adc	temp5,temp3
00064a 9488          clc			;    clear carry to be shifted into result
00064b cfec          rjmp	PFA_SLASHMOD_3		;else
00064c 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
00064d cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
00064e 92fa          st -Y,temp5
00064f 92ea          st -Y,temp4
                 
                     ; put quotient on stack
000650 01c8          movw tosl, temp0
000651 940c 1c04     jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
000653 ff05          .dw $ff05
000654 2f75
000655 6f6d
000656 0064          .db "u/mod",0
000657 061f          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
000658 1c00          .dw DO_COLON
                 PFA_USLASHMOD:
000659 1cf9          .dw XT_TO_R
00065a 1d4e          .dw XT_ZERO
00065b 1cf0          .dw XT_R_FROM
00065c 1dbc          .dw XT_UMSLASHMOD
00065d 1c1a          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
00065e ff06          .dw $ff06
00065f 656e
000660 6167
000661 6574          .db "negate"
000662 0653          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
000663 1c00          .dw DO_COLON
                 PFA_NEGATE:
000664 1df7          .dw XT_INVERT
000665 1e29          .dw XT_1PLUS
000666 1c1a          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
000667 ff01          .dw $ff01
000668 002f          .db "/",0
000669 065e          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
00066a 1c00          .dw DO_COLON
                 PFA_SLASH:
                 .endif
00066b 0623          .dw XT_SLASHMOD
00066c 1cea          .dw XT_NIP
00066d 1c1a          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
00066e ff03          .dw $ff03
00066f 6f6d
000670 0064          .db "mod",0
000671 0667          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
000672 1c00          .dw DO_COLON
                 PFA_MOD:
                 .endif
000673 0623          .dw XT_SLASHMOD
000674 1cd3          .dw XT_DROP
000675 1c1a          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
000676 ff03          .dw $ff03
000677 6261
000678 0073          .db "abs",0
000679 066e          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
00067a 067b          .dw PFA_ABS
                 PFA_ABS:
00067b 2399          tst tosh
00067c f41a          brpl PFA_ABS1
00067d 9580          com tosl
00067e 9590          com tosh
00067f 9601          adiw tosl, 1
                 PFA_ABS1:
000680 940c 1c04     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
000682 ff03          .dw $ff03
000683 696d
000684 006e          .db "min",0
000685 0676          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
000686 1c00          .dw DO_COLON
                 PFA_MIN:
                 .endif
000687 0588          .dw XT_2DUP
000688 1d72          .dw XT_GREATER
000689 1c30          .dw XT_DOCONDBRANCH
00068a 068c          DEST(PFA_MIN1)
00068b 1cbe          .dw XT_SWAP
                 PFA_MIN1:
00068c 1cd3          .dw XT_DROP
00068d 1c1a          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
00068e ff03          .dw $ff03
00068f 616d
000690 0078          .db "max",0
000691 0682          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
000692 1c00          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
000693 0588          .dw XT_2DUP
000694 1d68          .dw XT_LESS
000695 1c30          .dw XT_DOCONDBRANCH
000696 0698          DEST(PFA_MAX1)
000697 1cbe          .dw XT_SWAP
                 PFA_MAX1:
000698 1cd3          .dw XT_DROP
000699 1c1a          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
00069a ff06          .dw $ff06
00069b 6977
00069c 6874
00069d 6e69          .db "within"
00069e 068e          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
00069f 1c00          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
0006a0 1cc9          .dw XT_OVER
0006a1 1d8d          .dw XT_MINUS
0006a2 1cf9          .dw XT_TO_R
0006a3 1d8d          .dw XT_MINUS
0006a4 1cf0          .dw XT_R_FROM
0006a5 1d56          .dw XT_ULESS
0006a6 1c1a          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
0006a7 ff07          .dw $ff07 
0006a8 6f74
0006a9 7075
0006aa 6570
0006ab 0072          .db "toupper",0
0006ac 069a          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
0006ad 1c00          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
0006ae 1cab          .dw XT_DUP 
0006af 1c37          .dw XT_DOLITERAL 
0006b0 0061          .dw 'a' 
0006b1 1c37          .dw XT_DOLITERAL 
0006b2 007b          .dw 'z'+1
0006b3 069f          .dw XT_WITHIN 
0006b4 1c30          .dw XT_DOCONDBRANCH
0006b5 06b9          DEST(PFA_TOUPPER0)
0006b6 1c37          .dw XT_DOLITERAL
0006b7 00df          .dw 223 ; inverse of 0x20: 0xdf
0006b8 1e0d          .dw XT_AND 
                 PFA_TOUPPER0:
0006b9 1c1a          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
0006ba ff07          .dw $ff07
0006bb 6f74
0006bc 6f6c
0006bd 6577
0006be 0072          .db "tolower",0
0006bf 06a7          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
0006c0 1c00          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
0006c1 1cab          .dw XT_DUP
0006c2 1c37          .dw XT_DOLITERAL
0006c3 0041          .dw 'A'
0006c4 1c37          .dw XT_DOLITERAL
0006c5 005b          .dw 'Z'+1
0006c6 069f          .dw XT_WITHIN
0006c7 1c30          .dw XT_DOCONDBRANCH
0006c8 06cc          DEST(PFA_TOLOWER0)
0006c9 1c37          .dw XT_DOLITERAL
0006ca 0020          .dw 32
0006cb 1e16          .dw XT_OR 
                 PFA_TOLOWER0:
0006cc 1c1a          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0006cd ff03          .dw $ff03
0006ce 6c68
0006cf 0064          .db "hld",0
0006d0 06ba          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
0006d1 1c42          .dw PFA_DOVARIABLE
                 PFA_HLD:
0006d2 0121          .dw ram_hld
                 
                 .dseg
000121           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
0006d3 ff04          .dw $ff04
0006d4 6f68
0006d5 646c          .db "hold"
0006d6 06cd          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
0006d7 1c00          .dw DO_COLON
                 PFA_HOLD:
                 .endif
0006d8 06d1          .dw XT_HLD
0006d9 1cab          .dw XT_DUP
0006da 1c73          .dw XT_FETCH
0006db 1e2f          .dw XT_1MINUS
0006dc 1cab          .dw XT_DUP
0006dd 1cf9          .dw XT_TO_R
0006de 1cbe          .dw XT_SWAP
0006df 1c7b          .dw XT_STORE
0006e0 1cf0          .dw XT_R_FROM
0006e1 1c87          .dw XT_CSTORE
0006e2 1c1a          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
0006e3 ff02          .dw $ff02
0006e4 233c          .db "<#"
0006e5 06d3          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
0006e6 1c00          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
0006e7 05a7          .dw XT_PAD
0006e8 06d1          .dw XT_HLD
0006e9 1c7b          .dw XT_STORE
0006ea 1c1a          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
0006eb ff01          .dw $ff01
0006ec 0023          .db "#",0
0006ed 06e3          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
0006ee 1c00          .dw DO_COLON
                 PFA_SHARP:
                 .endif
0006ef 0573          .dw XT_BASE
0006f0 1c73          .dw XT_FETCH
0006f1 076b          .dw XT_UDSLASHMOD
0006f2 1cdb          .dw XT_ROT
0006f3 1c37          .dw XT_DOLITERAL
0006f4 0009          .dw 9
0006f5 1cc9          .dw XT_OVER
0006f6 1d68          .dw XT_LESS
0006f7 1c30          .dw XT_DOCONDBRANCH
0006f8 06fc          DEST(PFA_SHARP1)
0006f9 1c37          .dw XT_DOLITERAL
0006fa 0007          .dw 7
0006fb 1d97          .dw XT_PLUS
                 PFA_SHARP1:
0006fc 1c37          .dw XT_DOLITERAL
0006fd 0030          .dw 48 ; ASCII 0
0006fe 1d97          .dw XT_PLUS
0006ff 06d7          .dw XT_HOLD
000700 1c1a          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
000701 ff02          .dw $ff02
000702 7323          .db "#s"
000703 06eb          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
000704 1c00          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
000705 06ee          .dw XT_SHARP
000706 0588          .dw XT_2DUP
000707 1e16          .dw XT_OR
000708 1d14          .dw XT_ZEROEQUAL
000709 1c30          .dw XT_DOCONDBRANCH
00070a 0705          DEST(NUMS1) ; PFA_SHARP_S
00070b 1c1a          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
00070c ff02          .dw $ff02
00070d 3e23          .db "#>"
00070e 0701          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
00070f 1c00          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
000710 0591          .dw XT_2DROP
000711 06d1          .dw XT_HLD
000712 1c73          .dw XT_FETCH
000713 05a7          .dw XT_PAD
000714 1cc9          .dw XT_OVER
000715 1d8d          .dw XT_MINUS
000716 1c1a          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
000717 ff04          .dw $ff04
000718 6973
000719 6e67          .db "sign"
00071a 070c          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00071b 1c00          .dw DO_COLON
                 PFA_SIGN:
                 .endif
00071c 1d1b          .dw XT_ZEROLESS
00071d 1c30          .dw XT_DOCONDBRANCH
00071e 0722          DEST(PFA_SIGN1)
00071f 1c37          .dw XT_DOLITERAL
000720 002d          .dw 45 ; ascii -
000721 06d7          .dw XT_HOLD
                 PFA_SIGN1:
000722 1c1a          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
000723 ff03          .dw $ff03
000724 2e64
000725 0072          .db "d.r",0
000726 0717          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000727 1c00          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
000728 1cf9          .dw XT_TO_R
000729 0599          .dw XT_TUCK
00072a 0cce          .dw XT_DABS
00072b 06e6          .dw XT_L_SHARP
00072c 0704          .dw XT_SHARP_S
00072d 1cdb          .dw XT_ROT
00072e 071b          .dw XT_SIGN
00072f 070f          .dw XT_SHARP_G
000730 1cf0          .dw XT_R_FROM
000731 1cc9          .dw XT_OVER
000732 1d8d          .dw XT_MINUS
000733 0813          .dw XT_SPACES
000734 0823          .dw XT_TYPE
000735 1c1a          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
000736 ff02          .dw $ff02
000737 722e          .db ".r"
000738 0723          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
000739 1c00          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
00073a 1cf9          .dw XT_TO_R
00073b 0d62          .dw XT_S2D
00073c 1cf0          .dw XT_R_FROM
00073d 0727          .dw XT_DDOTR
00073e 1c1a          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
00073f ff02          .dw $ff02
000740 2e64          .db "d."
000741 0736          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000742 1c00          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
000743 1d4e          .dw XT_ZERO
000744 0727          .dw XT_DDOTR
000745 080a          .dw XT_SPACE
000746 1c1a          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
000747 ff01          .dw $ff01
000748 002e          .db ".",0
000749 073f          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
00074a 1c00          .dw DO_COLON
                 PFA_DOT:
                 .endif
00074b 0d62          .dw XT_S2D
00074c 0742          .dw XT_DDOT
00074d 1c1a          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
00074e ff03          .dw $ff03
00074f 6475
000750 002e          .db "ud.",0
000751 0747          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000752 1c00          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
000753 1d4e          .dw XT_ZERO
000754 075b          .dw XT_UDDOTR
000755 080a          .dw XT_SPACE
000756 1c1a          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
000757 ff04          .dw $ff04
000758 6475
000759 722e          .db "ud.r"
00075a 074e          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00075b 1c00          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
00075c 1cf9          .dw XT_TO_R
00075d 06e6          .dw XT_L_SHARP
00075e 0704          .dw XT_SHARP_S
00075f 070f          .dw XT_SHARP_G
000760 1cf0          .dw XT_R_FROM
000761 1cc9          .dw XT_OVER
000762 1d8d          .dw XT_MINUS
000763 0813          .dw XT_SPACES
000764 0823          .dw XT_TYPE
000765 1c1a          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
000766 ff06          .dw $ff06
000767 6475
000768 6d2f
000769 646f          .db "ud/mod"
00076a 0757          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
00076b 1c00          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
00076c 1cf9          .dw XT_TO_R
00076d 1d4e          .dw XT_ZERO
00076e 1d02          .dw XT_R_FETCH
00076f 1dbc          .dw XT_UMSLASHMOD
000770 1cf0          .dw XT_R_FROM
000771 1cbe          .dw XT_SWAP
000772 1cf9          .dw XT_TO_R
000773 1dbc          .dw XT_UMSLASHMOD
000774 1cf0          .dw XT_R_FROM
000775 1c1a          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
000776 ff06          .dw $ff06 
000777 6964
000778 6967
000779 3f74          .db "digit?"
00077a 0766          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
00077b 1c00          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
00077c 06ad          .dw XT_TOUPPER
00077d 1cab
00077e 1c37
00077f 0039
000780 1d72
000781 1c37
000782 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
000783 1e0d
000784 1d97
000785 1cab
000786 1c37
000787 0140
000788 1d72          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
000789 1c37
00078a 0107
00078b 1e0d
00078c 1d8d
00078d 1c37
00078e 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
00078f 1d8d
000790 1cab
000791 0573
000792 1c73
000793 1d56          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
000794 1c1a          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
000795 1c00        .dw DO_COLON
                 PFA_DOSLITERAL:
000796 1d02        .dw XT_R_FETCH   ; ( -- addr )
000797 07f4        .dw XT_ICOUNT
000798 1cf0        .dw XT_R_FROM
000799 1cc9        .dw XT_OVER     ; ( -- addr' n addr n)
00079a 1e29        .dw XT_1PLUS
00079b 1dfe        .dw XT_2SLASH   ; ( -- addr' n addr k )
00079c 1d97        .dw XT_PLUS     ; ( -- addr' n addr'' )
00079d 1e29        .dw XT_1PLUS
00079e 1cf9        .dw XT_TO_R     ; ( -- )
00079f 1c1a        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
0007a0 ff02        .dw $ff02
0007a1 2c73        .db "s",$2c
0007a2 0776        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
0007a3 1c00          .dw DO_COLON
                 PFA_SCOMMA:
0007a4 1cab          .dw XT_DUP
0007a5 07a7          .dw XT_DOSCOMMA
0007a6 1c1a          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0007a7 1c00          .dw DO_COLON
                 PFA_DOSCOMMA:
0007a8 025b          .dw XT_COMMA
0007a9 1cab          .dw XT_DUP   ; ( --addr len len)
0007aa 1dfe          .dw XT_2SLASH ; ( -- addr len len/2
0007ab 0599          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0007ac 1e05          .dw XT_2STAR  ; ( -- addr len/2 len len'
0007ad 1d8d          .dw XT_MINUS  ; ( -- addr len/2 rem
0007ae 1cf9          .dw XT_TO_R
0007af 1d4e          .dw XT_ZERO
0007b0 031a          .dw XT_QDOCHECK
0007b1 1c30          .dw XT_DOCONDBRANCH
0007b2 07ba          .dw PFA_SCOMMA2
0007b3 1e89          .dw XT_DODO
                 PFA_SCOMMA1:
0007b4 1cab          .dw XT_DUP         ; ( -- addr addr )
0007b5 1c73          .dw XT_FETCH       ; ( -- addr c1c2 )
0007b6 025b          .dw XT_COMMA       ; ( -- addr )
0007b7 0580          .dw XT_CELLPLUS    ; ( -- addr+cell )
0007b8 1eb7          .dw XT_DOLOOP
0007b9 07b4          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
0007ba 1cf0          .dw XT_R_FROM
0007bb 1d22          .dw XT_GREATERZERO
0007bc 1c30          .dw XT_DOCONDBRANCH
0007bd 07c1          .dw PFA_SCOMMA3
0007be 1cab            .dw XT_DUP     ; well, tricky
0007bf 1c92            .dw XT_CFETCH
0007c0 025b            .dw XT_COMMA
                 PFA_SCOMMA3:
0007c1 1cd3          .dw XT_DROP        ; ( -- )
0007c2 1c1a          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
0007c3 ff05          .dw $ff05
0007c4 7469
0007c5 7079
0007c6 0065          .db "itype",0
0007c7 07a0          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
0007c8 1c00          .dw DO_COLON
                 PFA_ITYPE:
0007c9 1cab          .dw XT_DUP    ; ( --addr len len)
0007ca 1dfe          .dw XT_2SLASH ; ( -- addr len len/2
0007cb 0599          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0007cc 1e05          .dw XT_2STAR  ; ( -- addr len/2 len len'
0007cd 1d8d          .dw XT_MINUS  ; ( -- addr len/2 rem
0007ce 1cf9          .dw XT_TO_R
0007cf 1d4e          .dw XT_ZERO
0007d0 031a          .dw XT_QDOCHECK
0007d1 1c30          .dw XT_DOCONDBRANCH
0007d2 07dc          .dw PFA_ITYPE2
0007d3 1e89          .dw XT_DODO
                 PFA_ITYPE1:
0007d4 1cab          .dw XT_DUP         ; ( -- addr addr )
0007d5 1fba          .dw XT_FETCHI      ; ( -- addr c1c2 )
0007d6 1cab          .dw XT_DUP
0007d7 07e9          .dw XT_LOWEMIT
0007d8 07e5          .dw XT_HIEMIT
0007d9 1e29          .dw XT_1PLUS    ; ( -- addr+cell )
0007da 1eb7          .dw XT_DOLOOP
0007db 07d4          .dw PFA_ITYPE1
                 PFA_ITYPE2:
0007dc 1cf0          .dw XT_R_FROM
0007dd 1d22          .dw XT_GREATERZERO
0007de 1c30          .dw XT_DOCONDBRANCH
0007df 07e3          .dw PFA_ITYPE3
0007e0 1cab            .dw XT_DUP     ; make sure the drop below has always something to do
0007e1 1fba            .dw XT_FETCHI
0007e2 07e9            .dw XT_LOWEMIT
                 PFA_ITYPE3:
0007e3 1cd3          .dw XT_DROP
0007e4 1c1a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
0007e5 1c00          .dw DO_COLON
                 PFA_HIEMIT:
0007e6 1ee7          .dw XT_BYTESWAP
0007e7 07e9          .dw XT_LOWEMIT
0007e8 1c1a          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
0007e9 1c00          .dw DO_COLON
                 PFA_LOWEMIT:
0007ea 1c37          .dw XT_DOLITERAL
0007eb 00ff          .dw $00ff
0007ec 1e0d          .dw XT_AND
0007ed 05b1          .dw XT_EMIT
0007ee 1c1a          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
0007ef ff06          .dw $ff06
0007f0 6369
0007f1 756f
0007f2 746e          .db "icount"
0007f3 07c3          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
0007f4 1c00          .dw DO_COLON
                 PFA_ICOUNT:
0007f5 1cab          .dw XT_DUP
0007f6 1e29          .dw XT_1PLUS
0007f7 1cbe          .dw XT_SWAP
0007f8 1fba          .dw XT_FETCHI
0007f9 1c1a          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
0007fa ff02          .dw 0xff02
0007fb 7263          .db "cr"
0007fc 07ef          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
0007fd 1c00          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
0007fe 1c37          .dw XT_DOLITERAL
0007ff 000d          .dw 13
000800 05b1          .dw XT_EMIT
000801 1c37          .dw XT_DOLITERAL
000802 000a          .dw 10
000803 05b1          .dw XT_EMIT
000804 1c1a          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
000805 ff05          .dw $ff05
000806 7073
000807 6361
000808 0065          .db "space",0
000809 07fa          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
00080a 1c00          .dw DO_COLON
                 PFA_SPACE:
                 .endif
00080b 0613          .dw XT_BL
00080c 05b1          .dw XT_EMIT
00080d 1c1a          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
00080e ff06          .dw $ff06
00080f 7073
000810 6361
000811 7365          .db "spaces"
000812 0805          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
000813 1c00          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
000814 1d4e
000815 0692      	.DW XT_ZERO, XT_MAX
000816 1cab
000817 1c30      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
000818 081d              DEST(SPCS2)
000819 080a
00081a 1e2f
00081b 1c29              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
00081c 0816              DEST(SPCS1)
00081d 1cd3
00081e 1c1a      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
00081f ff04          .dw $ff04
000820 7974
000821 6570          .db "type"
000822 080e          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000823 1c00          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
000824 0d59          .dw XT_BOUNDS
000825 031a          .dw XT_QDOCHECK
000826 1c30          .dw XT_DOCONDBRANCH
000827 082e          DEST(PFA_TYPE2)
000828 1e89          .dw XT_DODO
                 PFA_TYPE1:
000829 1e9a          .dw XT_I
00082a 1c92          .dw XT_CFETCH
00082b 05b1          .dw XT_EMIT
00082c 1eb7          .dw XT_DOLOOP
00082d 0829          DEST(PFA_TYPE1)
                 PFA_TYPE2:
00082e 1c1a          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
00082f ff01          .dw $ff01
000830 0027          .db "'",0
000831 081f          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000832 1c00          .dw DO_COLON
                 PFA_TICK:
                 .endif
000833 09d5          .dw XT_PARSENAME
000834 0ab9          .dw XT_DORECOGNIZER
000835 0b2f          .dw XT_R_WORD
000836 1fcf          .dw XT_EQUAL
000837 1c30          .dw XT_DOCONDBRANCH
000838 083b          DEST(PFA_TICK1)
000839 1cd3          .dw XT_DROP
00083a 1c1a          .dw XT_EXIT
                 PFA_TICK1:
00083b 1c37          .dw XT_DOLITERAL
00083c fff3          .dw -13
00083d 0861          .dw XT_THROW
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
00083e ff07          .dw $ff07
00083f 6168
000840 646e
000841 656c
000842 0072          .db "handler",0
000843 082f          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
000844 1c52          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
000845 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
000846 ff05          .dw $ff05
000847 6163
000848 6374
000849 0068          .db "catch",0
00084a 083e          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
00084b 1c00          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
00084c 1e7b          .dw XT_SP_FETCH
00084d 1cf9          .dw XT_TO_R
                     ; handler @ >r
00084e 0844          .dw XT_HANDLER
00084f 1c73          .dw XT_FETCH
000850 1cf9          .dw XT_TO_R
                     ; rp@ handler !
000851 1e64          .dw XT_RP_FETCH
000852 0844          .dw XT_HANDLER
000853 1c7b          .dw XT_STORE
000854 1c24          .dw XT_EXECUTE
                     ; r> handler !
000855 1cf0          .dw XT_R_FROM
000856 0844          .dw XT_HANDLER
000857 1c7b          .dw XT_STORE
000858 1cf0          .dw XT_R_FROM
000859 1cd3          .dw XT_DROP
00085a 1d4e          .dw XT_ZERO
00085b 1c1a          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
00085c ff05          .dw $ff05
00085d 6874
00085e 6f72
00085f 0077          .db "throw",0
000860 0846          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
000861 1c00          .dw DO_COLON
                 PFA_THROW:
                 .endif
000862 1cab          .dw XT_DUP
000863 1d14          .dw XT_ZEROEQUAL
000864 1c30          .dw XT_DOCONDBRANCH
000865 0868          DEST(PFA_THROW1)
000866 1cd3      	.dw XT_DROP
000867 1c1a      	.dw XT_EXIT
                 PFA_THROW1:
000868 0844          .dw XT_HANDLER
000869 1c73          .dw XT_FETCH
00086a 1e6e          .dw XT_RP_STORE
00086b 1cf0          .dw XT_R_FROM
00086c 0844          .dw XT_HANDLER
00086d 1c7b          .dw XT_STORE
00086e 1cf0          .dw XT_R_FROM
00086f 1cbe          .dw XT_SWAP
000870 1cf9          .dw XT_TO_R
000871 1e84          .dw XT_SP_STORE
000872 1cd3          .dw XT_DROP
000873 1cf0          .dw XT_R_FROM    
000874 1c1a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
000875 ff05          .dw $ff05
000876 7363
000877 696b
000878 0070          .db "cskip",0
000879 085c          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
00087a 1c00          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
00087b 1cf9          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00087c 1cab          .dw XT_DUP            ; ( -- addr' n' n' )
00087d 1c30          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00087e 0889          DEST(PFA_CSKIP2)
00087f 1cc9          .dw XT_OVER           ; ( -- addr' n' addr' )
000880 1c92          .dw XT_CFETCH         ; ( -- addr' n' c' )
000881 1d02          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000882 1fcf          .dw XT_EQUAL          ; ( -- addr' n' f )
000883 1c30          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000884 0889          DEST(PFA_CSKIP2)
000885 1fd6          .dw XT_ONE
000886 09c6          .dw XT_SLASHSTRING
000887 1c29          .dw XT_DOBRANCH
000888 087c          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
000889 1cf0          .dw XT_R_FROM
00088a 1cd3          .dw XT_DROP           ; ( -- addr2 n2)
00088b 1c1a          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
00088c ff05          .dw $ff05
00088d 7363
00088e 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
00088f 006e          .db "cscan"
000890 0875          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
000891 1c00          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
000892 1cf9          .dw XT_TO_R
000893 1cc9          .dw XT_OVER
                 PFA_CSCAN1:
000894 1cab          .dw XT_DUP
000895 1c92          .dw XT_CFETCH
000896 1d02          .dw XT_R_FETCH
000897 1fcf          .dw XT_EQUAL
000898 1d14          .dw XT_ZEROEQUAL
000899 1c30          .dw XT_DOCONDBRANCH
00089a 08a6          DEST(PFA_CSCAN2)
00089b 1cbe            .dw XT_SWAP
00089c 1e2f            .dw XT_1MINUS
00089d 1cbe            .dw XT_SWAP
00089e 1cc9            .dw XT_OVER
00089f 1d1b            .dw XT_ZEROLESS ; not negative
0008a0 1d14            .dw XT_ZEROEQUAL
0008a1 1c30            .dw XT_DOCONDBRANCH
0008a2 08a6            DEST(PFA_CSCAN2)
0008a3 1e29              .dw XT_1PLUS
0008a4 1c29              .dw XT_DOBRANCH
0008a5 0894              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
0008a6 1cea          .dw XT_NIP
0008a7 1cc9          .dw XT_OVER
0008a8 1d8d          .dw XT_MINUS
0008a9 1cf0          .dw XT_R_FROM
0008aa 1cd3          .dw XT_DROP
0008ab 1c1a          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
0008ac ff06          .dw $ff06
0008ad 6361
0008ae 6563
0008af 7470          .db "accept"
0008b0 088c          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
0008b1 1c00          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
0008b2 1cc9
0008b3 1d97
0008b4 1e2f
0008b5 1cc9              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
0008b6 05c2
0008b7 1cab
0008b8 08f2
0008b9 1d14
0008ba 1c30      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
0008bb 08e4              DEST(ACC5)
0008bc 1cab
0008bd 1c37
0008be 0008
0008bf 1fcf
0008c0 1c30              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
0008c1 08d4              DEST(ACC3)
0008c2 1cd3
0008c3 1cdb
0008c4 0588
0008c5 1d72
0008c6 1cf9
0008c7 1cdb
0008c8 1cdb
0008c9 1cf0
0008ca 1c30              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
0008cb 08d2      	DEST(ACC6)
0008cc 08ea
0008cd 1e2f
0008ce 1cf9
0008cf 1cc9
0008d0 1cf0
0008d1 00eb      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
0008d2 1c29      ACC6:   .DW XT_DOBRANCH
0008d3 08e2              DEST(ACC4)
                     
                 
                 ACC3:    ; check for remaining control characters, replace them with blank
0008d4 1cab      	.dw XT_DUP            ; ( -- addr k k )
0008d5 0613              .dw XT_BL
0008d6 1d68              .dw XT_LESS
0008d7 1c30              .dw XT_DOCONDBRANCH
0008d8 08db              DEST(PFA_ACCEPT6)
0008d9 1cd3              .dw XT_DROP
0008da 0613              .dw XT_BL
                 PFA_ACCEPT6:
0008db 1cab
0008dc 05b1
0008dd 1cc9
0008de 1c87
0008df 1e29
0008e0 1cc9
0008e1 00f7      	.DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
0008e2 1c29      ACC4:   .DW XT_DOBRANCH
0008e3 08b6              DEST(ACC1)
0008e4 1cd3
0008e5 1cea
0008e6 1cbe
0008e7 1d8d
0008e8 07fd
0008e9 1c1a      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
0008ea 1c00          .dw DO_COLON
                 .endif
0008eb 1c37          .dw XT_DOLITERAL
0008ec 0008          .dw 8
0008ed 1cab          .dw XT_DUP
0008ee 05b1          .dw XT_EMIT
0008ef 080a          .dw XT_SPACE
0008f0 05b1          .dw XT_EMIT
0008f1 1c1a          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
0008f2 1c00          .dw DO_COLON
                 .endif
0008f3 1cab          .dw XT_DUP
0008f4 1c37          .dw XT_DOLITERAL
0008f5 000d          .dw 13
0008f6 1fcf          .dw XT_EQUAL
0008f7 1cbe          .dw XT_SWAP
0008f8 1c37          .dw XT_DOLITERAL
0008f9 000a          .dw 10
0008fa 1fcf          .dw XT_EQUAL
0008fb 1e16          .dw XT_OR
0008fc 1c1a          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILL:
0008fd ff06          .dw $ff06
0008fe 6572
0008ff 6966
000900 6c6c          .db "refill"
000901 08ac          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
000902 0c0d          .dw PFA_DODEFER1
                 PFA_REFILL:
                 .endif
000903 001a          .dw USER_REFILL
000904 0bd6          .dw XT_UDEFERFETCH
000905 0be2          .dw XT_UDEFERSTORE
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
000906 ff04          .dw $ff04
000907 6863
000908 7261          .db "char"
000909 08fd          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
00090a 1c00          .dw DO_COLON
                 PFA_CHAR:
                 .endif
00090b 09d5          .dw XT_PARSENAME
00090c 1cd3          .dw XT_DROP
00090d 1c92          .dw XT_CFETCH
00090e 1c1a          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
00090f ff06          .dw $ff06
000910 756e
000911 626d
000912 7265          .db "number"
000913 0906          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
000914 1c00          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
000915 0573          .dw XT_BASE
000916 1c73          .dw XT_FETCH
000917 1cf9          .dw XT_TO_R
000918 0958          .dw XT_QSIGN
000919 1cf9          .dw XT_TO_R
00091a 096b          .dw XT_SET_BASE
00091b 0958          .dw XT_QSIGN
00091c 1cf0          .dw XT_R_FROM
00091d 1e16          .dw XT_OR
00091e 1cf9          .dw XT_TO_R
                     ; check whether something is left
00091f 1cab          .dw XT_DUP
000920 1d14          .dw XT_ZEROEQUAL
000921 1c30          .dw XT_DOCONDBRANCH
000922 092b          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
000923 0591            .dw XT_2DROP
000924 1cf0            .dw XT_R_FROM
000925 1cd3            .dw XT_DROP
000926 1cf0            .dw XT_R_FROM
000927 0573            .dw XT_BASE
000928 1c7b            .dw XT_STORE
000929 1d4e            .dw XT_ZERO
00092a 1c1a            .dw XT_EXIT
                 PFA_NUMBER0:
00092b 1f0c          .dw XT_2TO_R
00092c 1d4e          .dw XT_ZERO       ; starting value
00092d 1d4e          .dw XT_ZERO
00092e 1f1b          .dw XT_2R_FROM
00092f 0989          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
000930 1cb3          .dw XT_QDUP
000931 1c30          .dw XT_DOCONDBRANCH
000932 094d          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
000933 1fd6          .dw XT_ONE
000934 1fcf          .dw XT_EQUAL
000935 1c30          .dw XT_DOCONDBRANCH
000936 0944          DEST(PFA_NUMBER2)
                 	; excatly one character is left
000937 1c92      	.dw XT_CFETCH
000938 1c37      	.dw XT_DOLITERAL
000939 002e      	.dw 46 ; .
00093a 1fcf      	.dw XT_EQUAL
00093b 1c30      	.dw XT_DOCONDBRANCH
00093c 0945      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
00093d 1cf0      	.dw XT_R_FROM
00093e 1c30              .dw XT_DOCONDBRANCH
00093f 0941      	DEST(PFA_NUMBER3)
000940 0cdb              .dw XT_DNEGATE
                 PFA_NUMBER3:
000941 1fdb      	.dw XT_TWO
000942 1c29      	.dw XT_DOBRANCH
000943 0953      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
000944 1cd3      	.dw XT_DROP
                 PFA_NUMBER6:
000945 0591      	.dw XT_2DROP
000946 1cf0      	.dw XT_R_FROM
000947 1cd3      	.dw XT_DROP
000948 1cf0              .dw XT_R_FROM
000949 0573              .dw XT_BASE
00094a 1c7b              .dw XT_STORE
00094b 1d4e      	.dw XT_ZERO
00094c 1c1a      	.dw XT_EXIT
                 PFA_NUMBER1:
00094d 0591          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00094e 1cf0          .dw XT_R_FROM
00094f 1c30          .dw XT_DOCONDBRANCH
000950 0952          DEST(PFA_NUMBER4)
000951 0663          .dw XT_NEGATE
                 PFA_NUMBER4:
000952 1fd6          .dw XT_ONE
                 PFA_NUMBER5:
000953 1cf0          .dw XT_R_FROM
000954 0573          .dw XT_BASE
000955 1c7b          .dw XT_STORE
000956 1d45          .dw XT_TRUE
000957 1c1a          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
000958 1c00          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
000959 1cc9          .dw XT_OVER    ; ( -- addr len addr )
00095a 1c92          .dw XT_CFETCH
00095b 1c37          .dw XT_DOLITERAL
00095c 002d          .dw '-'
00095d 1fcf          .dw XT_EQUAL  ; ( -- addr len flag )
00095e 1cab          .dw XT_DUP
00095f 1cf9          .dw XT_TO_R
000960 1c30          .dw XT_DOCONDBRANCH
000961 0964          DEST(PFA_NUMBERSIGN_DONE)
000962 1fd6          .dw XT_ONE    ; skip sign character
000963 09c6          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
000964 1cf0          .dw XT_R_FROM
000965 1c1a          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
000966 1c4c          .dw PFA_DOCONSTANT
                 .endif
000967 000a
000968 0010
000969 0002
00096a 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
00096b 1c00          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
00096c 1cc9          .dw XT_OVER
00096d 1c92          .dw XT_CFETCH
00096e 1c37          .dw XT_DOLITERAL
00096f 0023          .dw 35
000970 1d8d          .dw XT_MINUS
000971 1cab          .dw XT_DUP
000972 1d4e          .dw XT_ZERO
000973 1c37          .dw XT_DOLITERAL
000974 0004          .dw 4
000975 069f          .dw XT_WITHIN
000976 1c30          .dw XT_DOCONDBRANCH
000977 0981          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
000978 0966      	.dw XT_BASES
000979 1d97      	.dw XT_PLUS
00097a 1fba      	.dw XT_FETCHI
00097b 0573      	.dw XT_BASE
00097c 1c7b      	.dw XT_STORE
00097d 1fd6      	.dw XT_ONE
00097e 09c6      	.dw XT_SLASHSTRING
00097f 1c29      	.dw XT_DOBRANCH
000980 0982      	DEST(SET_BASE2)
                 SET_BASE1:
000981 1cd3      	.dw XT_DROP
                 SET_BASE2:
000982 1c1a          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
000983 ff07          .dw $ff07
000984 6e3e
000985 6d75
000986 6562
000987 0072          .db ">number",0
000988 090f          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
000989 1c00          .dw DO_COLON
                 
                 .endif
                 
00098a 1cab
00098b 1c30      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
00098c 09a2              DEST(TONUM3)
00098d 1cc9
00098e 1c92
00098f 077b              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
000990 1d14
000991 1c30              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
000992 0995              DEST(TONUM2)
000993 1cd3
000994 1c1a              .DW XT_DROP,XT_EXIT
000995 1cf9
000996 0d00
000997 0573
000998 1c73
000999 00dc      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
00099a 1cf0
00099b 00d4
00099c 0d00              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
00099d 1c37
00099e 0001
00099f 09c6
0009a0 1c29              .DW XT_DOLITERAL,1,XT_SLASHSTRING,XT_DOBRANCH
0009a1 098a              DEST(TONUM1)
0009a2 1c1a      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
0009a3 ff05          .dw $ff05
0009a4 6170
0009a5 7372
0009a6 0065          .db "parse",0
0009a7 0983          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
0009a8 1c00          .dw DO_COLON
                 PFA_PARSE:
                 .endif
0009a9 1cf9          .dw XT_TO_R     ; ( -- )
0009aa 09bc          .dw XT_SOURCE   ; ( -- addr len)
0009ab 05a1          .dw XT_TO_IN     ; ( -- addr len >in)
0009ac 1c73          .dw XT_FETCH
0009ad 09c6          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
0009ae 1cf0          .dw XT_R_FROM      ; ( -- addr' len' c)
0009af 0891          .dw XT_CSCAN       ; ( -- addr' len'')
0009b0 1cab          .dw XT_DUP         ; ( -- addr' len'' len'')
0009b1 1e29          .dw XT_1PLUS
0009b2 05a1          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
0009b3 1e53          .dw XT_PLUSSTORE   ; ( -- addr' len')
0009b4 1fd6          .dw XT_ONE
0009b5 09c6          .dw XT_SLASHSTRING
0009b6 1c1a          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCE:
0009b7 ff06          .dw $FF06
0009b8 6f73
0009b9 7275
0009ba 6563          .db "source"
0009bb 09a3          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
0009bc 0c0d          .dw PFA_DODEFER1
                 PFA_SOURCE:
                 .endif
0009bd 0016          .dw USER_SOURCE
0009be 0bd6          .dw XT_UDEFERFETCH
0009bf 0be2          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
0009c0 ff07          .dw $ff07
0009c1 732f
0009c2 7274
0009c3 6e69
0009c4 0067          .db "/string",0
0009c5 09b7          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0009c6 1c00          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
0009c7 1cdb          .dw XT_ROT
0009c8 1cc9          .dw XT_OVER
0009c9 1d97          .dw XT_PLUS
0009ca 1cdb          .dw XT_ROT
0009cb 1cdb          .dw XT_ROT
0009cc 1d8d          .dw XT_MINUS
0009cd 1c1a          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
0009ce ff0a          .dw $FF0A 
0009cf 6170
0009d0 7372
0009d1 2d65
0009d2 616e
0009d3 656d          .db "parse-name"
0009d4 09c0          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0009d5 1c00          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
0009d6 0613          .dw XT_BL
0009d7 09d9          .dw XT_SKIPSCANCHAR
0009d8 1c1a          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0009d9 1c00          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
0009da 1cf9          .dw XT_TO_R
0009db 09bc          .dw XT_SOURCE 
0009dc 05a1          .dw XT_TO_IN 
0009dd 1c73          .dw XT_FETCH 
0009de 09c6          .dw XT_SLASHSTRING 
                 
0009df 1d02          .dw XT_R_FETCH
0009e0 087a          .dw XT_CSKIP
0009e1 1cf0          .dw XT_R_FROM
0009e2 0891          .dw XT_CSCAN
                 
                     ; adjust >IN
0009e3 0588          .dw XT_2DUP
0009e4 1d97          .dw XT_PLUS
0009e5 09bc          .dw XT_SOURCE 
0009e6 1cd3          .dw XT_DROP
0009e7 1d8d          .dw XT_MINUS
0009e8 05a1          .dw XT_TO_IN
0009e9 1c7b          .dw XT_STORE
0009ea 1c1a          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the name from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDNAME:
0009eb ff09          .dw $ff09
0009ec 6966
0009ed 646e
0009ee 6e2d
0009ef 6d61
0009f0 0065          .db "find-name",0
0009f1 09ce          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
0009f2 1c00          .dw DO_COLON
                 PFA_FINDNAME:
                 .endif
0009f3 1c37          .dw XT_DOLITERAL
0009f4 09fe          .dw XT_FINDNAMEA
0009f5 1c37          .dw XT_DOLITERAL
0009f6 0042          .dw CFG_ORDERLISTLEN
0009f7 0494          .dw XT_MAPSTACK
0009f8 1d14          .dw XT_ZEROEQUAL
0009f9 1c30          .dw XT_DOCONDBRANCH
0009fa 09fd          DEST(PFA_FINDNAME1)
0009fb 0591            .dw XT_2DROP
0009fc 1d4e            .dw XT_ZERO
                 PFA_FINDNAME1:
0009fd 1c1a          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDNAMEA:
0009fe 1c00          .dw DO_COLON
                 PFA_FINDNAMEA:
                 .endif
0009ff 1cf9          .dw XT_TO_R
000a00 0588          .dw XT_2DUP
000a01 1cf0          .dw XT_R_FROM
000a02 0c1f          .dw XT_SEARCH_WORDLIST
000a03 1cab          .dw XT_DUP
000a04 1c30          .dw XT_DOCONDBRANCH
000a05 0a0b          DEST(PFA_FINDNAMEA1)
000a06 1cf9            .dw XT_TO_R
000a07 1cea            .dw XT_NIP
000a08 1cea            .dw XT_NIP
000a09 1cf0            .dw XT_R_FROM
000a0a 1d45            .dw XT_TRUE
                 PFA_FINDNAMEA1:
000a0b 1c1a          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
000a0c ff04          .dw $ff04
000a0d 7571
000a0e 7469          .db "quit"
000a0f 09eb          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
000a10 1c00          .dw DO_COLON
                 PFA_QUIT:
                 .endif
                 PFA_QUIT1:
000a11 0350
000a12 0357
000a13 1c7b          .dw XT_LP0,XT_LP,XT_STORE
000a14 0a91          .dw XT_SP0
000a15 1e84          .dw XT_SP_STORE
000a16 0a9e          .dw XT_RP0
000a17 1e6e          .dw XT_RP_STORE
000a18 03e5          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000a19 056d          .dw XT_STATE
000a1a 1c73          .dw XT_FETCH
000a1b 1d14          .dw XT_ZEROEQUAL
000a1c 1c30          .dw XT_DOCONDBRANCH
000a1d 0a1f          DEST(PFA_QUIT4)
000a1e 0a3c          .dw XT_PROMPTREADY
                 PFA_QUIT4:
000a1f 0902          .dw XT_REFILL
000a20 1c30          .dw XT_DOCONDBRANCH
000a21 0a19          DEST(PFA_QUIT2)
000a22 1c37          .dw XT_DOLITERAL
000a23 0ae1          .dw XT_INTERPRET
000a24 084b          .dw XT_CATCH
000a25 1cb3          .dw XT_QDUP
000a26 1c30          .dw XT_DOCONDBRANCH
000a27 0a31          DEST(PFA_QUIT3)
000a28 1cab      	.dw XT_DUP
000a29 1c37      	.dw XT_DOLITERAL
000a2a fffe      	.dw -2
000a2b 1d68      	.dw XT_LESS
000a2c 1c30      	.dw XT_DOCONDBRANCH
000a2d 0a2f      	DEST(PFA_QUIT5)
000a2e 0a43      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000a2f 1c29      	.dw XT_DOBRANCH
000a30 0a11      	DEST(PFA_QUIT1)
                 PFA_QUIT3:
000a31 0a35          .dw XT_PROMPTOK
000a32 1c29          .dw XT_DOBRANCH
000a33 0a19          DEST(PFA_QUIT2)
000a34 1c1a          .dw XT_EXIT ; never reached
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000a35 1c00          .dw DO_COLON
                 PFA_PROMPTOK:
000a36 0795          .dw XT_DOSLITERAL
000a37 0003          .dw 3
000a38 6f20
000a39 006b          .db " ok",0
                 .endif
000a3a 07c8          .dw XT_ITYPE
000a3b 1c1a          .dw XT_EXIT
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTREADY:
000a3c 1c00          .dw DO_COLON
                 PFA_PROMPTREADY:
000a3d 0795          .dw XT_DOSLITERAL
000a3e 0002          .dw 2
000a3f 203e          .db "> "
                 .endif
000a40 07fd          .dw XT_CR
000a41 07c8          .dw XT_ITYPE
000a42 1c1a          .dw XT_EXIT
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
000a43 1c00          .dw DO_COLON
                 PFA_PROMPTERROR:
000a44 0795      	.dw XT_DOSLITERAL
000a45 0004          .dw 4
000a46 3f20
000a47 203f          .db " ?? "
                 .endif
000a48 07c8          .dw XT_ITYPE
000a49 0573          .dw XT_BASE
000a4a 1c73          .dw XT_FETCH
000a4b 1cf9          .dw XT_TO_R
000a4c 0600          .dw XT_DECIMAL
000a4d 074a          .dw XT_DOT
000a4e 05a1          .dw XT_TO_IN
000a4f 1c73          .dw XT_FETCH
000a50 074a          .dw XT_DOT
000a51 1cf0          .dw XT_R_FROM
000a52 0573          .dw XT_BASE
000a53 1c7b          .dw XT_STORE
000a54 1c1a          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000a55 ff05          .dw $ff05
000a56 6170
000a57 7375
000a58 0065          .db "pause",0
000a59 0a0c          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000a5a 0c0d          .dw PFA_DODEFER1
                 PFA_PAUSE:
000a5b 0123          .dw ram_pause
000a5c 0bc2          .dw XT_RDEFERFETCH
000a5d 0bcc          .dw XT_RDEFERSTORE
                 
                 .dseg
000123           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000a5e ff04          .dw $ff04
000a5f 6f63
000a60 646c          .db "cold"
000a61 0a55          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000a62 0a63          .dw PFA_COLD
                 PFA_COLD:
000a63 b6a4          in_ mcu_boot, MCUSR
000a64 2422          clr zerol
000a65 2433          clr zeroh
000a66 be24          out_ MCUSR, zerol
                     ; clear RAM
000a67 e0e0          ldi zl, low(ramstart)
000a68 e0f1          ldi zh, high(ramstart)
                 clearloop:
000a69 9221          st Z+, zerol
000a6a 30e0          cpi zl, low(sram_size+ramstart)
000a6b f7e9          brne clearloop
000a6c 30f5          cpi zh, high(sram_size+ramstart)
000a6d f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000125           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000a6e e2e5          ldi zl, low(ram_user1)
000a6f e0f1          ldi zh, high(ram_user1)
000a70 012f          movw upl, zl
                     ; init return stack pointer
000a71 ef0f          ldi temp0,low(rstackstart)
000a72 bf0d          out_ SPL,temp0
000a73 8304          std Z+4, temp0
000a74 e014          ldi temp1,high(rstackstart)
000a75 bf1e          out_ SPH,temp1
000a76 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000a77 eacf          ldi yl,low(stackstart)
000a78 83c6          std Z+6, yl
000a79 e0d4          ldi yh,high(stackstart)
000a7a 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000a7b e8a4          ldi XL, low(PFA_WARM)
000a7c e0ba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000a7d 940c 1c04     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WARM:
000a7f ff04          .dw $ff04
000a80 6177
000a81 6d72          .db "warm"
000a82 0a5e          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000a83 1c00          .dw DO_COLON
                 PFA_WARM:
                 .endif
000a84 0d4b          .dw XT_INIT_RAM
000a85 1c37          .dw XT_DOLITERAL
000a86 0b79          .dw XT_NOOP
000a87 1c37          .dw XT_DOLITERAL
000a88 0a5a          .dw XT_PAUSE
000a89 0bed          .dw XT_DEFERSTORE
000a8a 03e5          .dw XT_LBRACKET
000a8b 061b          .dw XT_TURNKEY
000a8c 0a10          .dw XT_QUIT     ; never returns
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000a8d ff03          .dw $ff03
000a8e 7073
000a8f 0030          .db "sp0",0
000a90 0a7f          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
000a91 1c69          .dw PFA_DOVALUE1
                 PFA_SP0:
000a92 0006          .dw USER_SP0
000a93 0bd6          .dw XT_UDEFERFETCH
000a94 0be2          .dw XT_UDEFERSTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
000a95 ff02          .dw $ff02
000a96 7073          .db "sp"
000a97 0a8d          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
000a98 1c52          .dw PFA_DOUSER
                 PFA_SP:
000a99 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000a9a ff03          .dw $ff03
000a9b 7072
000a9c 0030          .db "rp0",0
000a9d 0a95          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
000a9e 1c00          .dw DO_COLON
                 PFA_RP0:
000a9f 0aa2          .dw XT_DORP0
000aa0 1c73          .dw XT_FETCH
000aa1 1c1a          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
000aa2 1c52          .dw PFA_DOUSER
                 PFA_DORP0:
000aa3 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
000aa4 ff05          .dw $ff05
000aa5 6564
000aa6 7470
000aa7 0068          .db "depth",0
000aa8 0a9a          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
000aa9 1c00          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
000aaa 0a91          .dw XT_SP0
000aab 1e7b          .dw XT_SP_FETCH
000aac 1d8d          .dw XT_MINUS
000aad 1dfe          .dw XT_2SLASH
000aae 1e2f          .dw XT_1MINUS
000aaf 1c1a          .dw XT_EXIT
                 .include "words/do-recognizer.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DORECOGNIZER:
000ab0 ff0d          .dw $ff0d
000ab1 6f64
000ab2 722d
000ab3 6365
000ab4 676f
000ab5 696e
000ab6 657a
000ab7 0072          .db "do-recognizer",0
000ab8 0aa4          .dw VE_HEAD
                     .set VE_HEAD = VE_DORECOGNIZER
                 XT_DORECOGNIZER:
000ab9 1c00          .dw DO_COLON
                 PFA_DORECOGNIZER:
                 .endif
000aba 1c37          .dw XT_DOLITERAL
000abb 0ac5          .dw XT_DORECOGNIZER_A
000abc 1c37          .dw XT_DOLITERAL
000abd 0054          .dw CFG_RECOGNIZERLISTLEN
000abe 0494          .dw XT_MAPSTACK
000abf 1d14          .dw XT_ZEROEQUAL
000ac0 1c30          .dw XT_DOCONDBRANCH
000ac1 0ac4          DEST(PFA_DORECOGNIZER1)
000ac2 0591            .dw XT_2DROP
000ac3 0b44            .dw XT_R_FAIL
                 PFA_DORECOGNIZER1:
000ac4 1c1a          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ; ( addr len XT -- addr len [ r:table -1 | 0 ] )
                 XT_DORECOGNIZER_A:
000ac5 1c00         .dw DO_COLON
                 PFA_DORECOGNIZER_A:
                 .endif
000ac6 1cdb         .dw XT_ROT  ; -- len xt addr
000ac7 1cdb         .dw XT_ROT  ; -- xt addr len
000ac8 0588         .dw XT_2DUP 
000ac9 1f0c         .dw XT_2TO_R
000aca 1cdb         .dw XT_ROT  ; -- addr len xt
000acb 1c24         .dw XT_EXECUTE ; -- i*x r:foo | r:fail
000acc 1f1b         .dw XT_2R_FROM
000acd 1cdb         .dw XT_ROT
000ace 1cab         .dw XT_DUP
000acf 0b44         .dw XT_R_FAIL
000ad0 1fcf         .dw XT_EQUAL
000ad1 1c30         .dw XT_DOCONDBRANCH
000ad2 0ad6         DEST(PFA_DORECOGNIZER_A1)
000ad3 1cd3           .dw XT_DROP
000ad4 1d4e           .dw XT_ZERO
000ad5 1c1a           .dw XT_EXIT
                 PFA_DORECOGNIZER_A1:
000ad6 1cea         .dw XT_NIP 
000ad7 1cea         .dw XT_NIP
000ad8 1d45         .dw XT_TRUE
000ad9 1c1a         .dw XT_EXIT
                 
                 ; : do-recognizer ( addr len -- i*x r:table|r:fail )
                 ;    \ ( addr len -- addr len 0 | i*x r:table -1 )
                 ;    [: rot rot 2dup 2>r rot execute 2r> rot 
                 ;          dup r:fail = ( -- addr len r:table f )
                 ;          if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    EE_RECOGNIZERLISTLEN map-stack ( -- i*x addr len r:table f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop r:fail 
                 ;    then
                 ;
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
000ada ff09          .dw $ff09
000adb 6e69
000adc 6574
000add 7072
000ade 6572
000adf 0074          .db "interpret",0
000ae0 0ab0          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000ae1 1c00          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
000ae2 09d5          .dw XT_PARSENAME ; ( -- addr len )
000ae3 1cab          .dw XT_DUP   ; ( -- addr len flag)
000ae4 1c30          .dw XT_DOCONDBRANCH
000ae5 0af1          DEST(PFA_INTERPRET2)
000ae6 0ab9            .dw XT_DORECOGNIZER
000ae7 056d            .dw XT_STATE
000ae8 1c73            .dw XT_FETCH
000ae9 1c30            .dw XT_DOCONDBRANCH
000aea 0aec          DEST(PFA_INTERPRET1)
000aeb 0ba5            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
000aec 1fba            .dw XT_FETCHI
000aed 1c24            .dw XT_EXECUTE
000aee 0b51            .dw XT_QSTACK
000aef 1c29          .dw XT_DOBRANCH
000af0 0ae2          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
000af1 0591          .dw XT_2DROP
000af2 1c1a          .dw XT_EXIT
                 .include "words/r-intnumber.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_NUM:
000af3 ff05          .dw $ff05
000af4 3a72
000af5 756e
000af6 006d          .db "r:num",0
000af7 0ada          .dw VE_HEAD
                     .set VE_HEAD = VE_R_NUM
                 XT_R_NUM:
000af8 1c4c          .dw PFA_DOCONSTANT
                 PFA_R_NUM:
                 .endif
000af9 0b79          .dw XT_NOOP    ; interpret
000afa 0271          .dw XT_LITERAL ; compile
000afb 0271          .dw XT_LITERAL ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_DNUM:
000afc ff06          .dw $ff06
000afd 3a72
000afe 6e64
000aff 6d75          .db "r:dnum"
000b00 0af3          .dw VE_HEAD
                     .set VE_HEAD = VE_R_DNUM
                 XT_R_DNUM:
000b01 1c4c          .dw PFA_DOCONSTANT
                 PFA_R_DNUM:
                 .endif
000b02 0b79          .dw XT_NOOP     ; interpret
000b03 1fc7          .dw XT_2LITERAL ; compile
000b04 1fc7          .dw XT_2LITERAL ; postpone
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
000b05 ff07          .dw $ff07
000b06 6572
000b07 3a63
000b08 756e
000b09 006d          .db "rec:num",0
000b0a 0afc          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
000b0b 1c00          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
000b0c 0914          .dw XT_NUMBER
000b0d 1c30          .dw XT_DOCONDBRANCH
000b0e 0b17          DEST(PFA_REC_NONUMBER)
000b0f 1fd6          .dw XT_ONE
000b10 1fcf          .dw XT_EQUAL
000b11 1c30          .dw XT_DOCONDBRANCH
000b12 0b15          DEST(PFA_REC_INTNUM2)
000b13 0af8            .dw XT_R_NUM
000b14 1c1a            .dw XT_EXIT
                 PFA_REC_INTNUM2:
000b15 0b01            .dw XT_R_DNUM
000b16 1c1a            .dw XT_EXIT
                 PFA_REC_NONUMBER:
000b17 0b44          .dw XT_R_FAIL
000b18 1c1a          .dw XT_EXIT
                 .include "words/r-word.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_WORD:
000b19 ff08          .dw $ff08
000b1a 6572
000b1b 3a63
000b1c 6f77
000b1d 6472          .db "rec:word"
000b1e 0b05          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_WORD
                 XT_REC_WORD:
000b1f 1c00          .dw DO_COLON
                 PFA_REC_WORD:
                 .endif
000b20 09f2          .DW XT_FINDNAME
000b21 1cab          .dw XT_DUP
000b22 1d14          .dw XT_ZEROEQUAL
000b23 1c30          .dw XT_DOCONDBRANCH
000b24 0b28          DEST(PFA_REC_WORD_FOUND)
000b25 1cd3              .dw XT_DROP
000b26 0b44      	.dw XT_R_FAIL
000b27 1c1a      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
000b28 0b2f          .dw XT_R_WORD
                 
000b29 1c1a          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_WORD:
000b2a ff06          .dw $ff06
000b2b 3a72
000b2c 6f77
000b2d 6472          .db "r:word"
000b2e 0b19          .dw VE_HEAD
                     .set VE_HEAD = VE_R_WORD
                 XT_R_WORD:
000b2f 1c4c          .dw PFA_DOCONSTANT
                 PFA_R_WORD:
                 .endif
000b30 0b33          .dw XT_R_WORD_INTERPRET
000b31 0b37          .dw XT_R_WORD_COMPILE
000b32 1fc7          .dw XT_2LITERAL
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
000b33 1c00          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
000b34 1cd3          .dw XT_DROP ; the flags are in the way
000b35 1c24          .dw XT_EXECUTE
000b36 1c1a          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
000b37 1c00          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
000b38 1d1b          .dw XT_ZEROLESS
000b39 1c30          .dw XT_DOCONDBRANCH
000b3a 0b3d          DEST(PFA_R_WORD_COMPILE1)
000b3b 025b      	.dw XT_COMMA
000b3c 1c1a              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
000b3d 1c24              .dw XT_EXECUTE
000b3e 1c1a          .dw XT_EXIT
                 .include "words/r-fail.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_FAIL:
000b3f ff06          .dw $ff06
000b40 3a72
000b41 6166
000b42 6c69          .db "r:fail"
000b43 0b2a          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FAIL
                 XT_R_FAIL:
000b44 1c4c          .dw PFA_DOCONSTANT
                 PFA_R_FAIL:
                 .endif
000b45 0b48          .dw XT_FAIL  ; interpret
000b46 0b48          .dw XT_FAIL  ; compile
000b47 0b48          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
000b48 1c00          .dw DO_COLON
                 PFA_FAIL:
                 .endif
000b49 1c37          .dw XT_DOLITERAL
000b4a fff3          .dw -13
000b4b 0861          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
000b4c ff06          .dw $ff06
000b4d 733f
000b4e 6174
000b4f 6b63          .db "?stack"
000b50 0b3f          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000b51 1c00          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
000b52 0aa9          .dw XT_DEPTH
000b53 1d1b          .dw XT_ZEROLESS
000b54 1c30          .dw XT_DOCONDBRANCH
000b55 0b59          DEST(PFA_QSTACK1)
000b56 1c37            .dw XT_DOLITERAL
000b57 fffc            .dw -4
000b58 0861            .dw XT_THROW
                 PFA_QSTACK1:
000b59 1c1a          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
000b5a ff03          .dw $ff03
000b5b 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
000b5c 0072          .db "ver"
000b5d 0b4c          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
000b5e 1c00          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
000b5f 052f          .dw XT_ENV_FORTHNAME
000b60 07c8          .dw XT_ITYPE
000b61 080a          .dw XT_SPACE
000b62 0573          .dw XT_BASE
000b63 1c73          .dw XT_FETCH
                 
000b64 053d          .dw XT_ENV_FORTHVERSION
000b65 0600          .dw XT_DECIMAL
000b66 0d62          .dw XT_S2D
000b67 06e6          .dw XT_L_SHARP
000b68 06ee          .dw XT_SHARP
000b69 1c37          .dw XT_DOLITERAL
000b6a 002e          .dw '.'
000b6b 06d7          .dw XT_HOLD
000b6c 0704          .dw XT_SHARP_S
000b6d 070f          .dw XT_SHARP_G
000b6e 0823          .dw XT_TYPE
000b6f 0573          .dw XT_BASE
000b70 1c7b          .dw XT_STORE
000b71 080a          .dw XT_SPACE
000b72 0545          .dw XT_ENV_CPU
000b73 07c8          .dw XT_ITYPE
                 
000b74 1c1a          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOOP:
000b75 ff04          .dw $ff04
000b76 6f6e
000b77 706f          .db "noop"
000b78 0b5a          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000b79 1c00          .dw DO_COLON
                 PFA_NOOP:
                 .endif
000b7a 1c1a         .DW XT_EXIT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000b7b ff06          .dw $ff06
000b7c 6e75
000b7d 7375
000b7e 6465          .db "unused"
000b7f 0b75          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000b80 1c00          .dw DO_COLON
                 PFA_UNUSED:
000b81 1e7b          .dw XT_SP_FETCH
000b82 05e2          .dw XT_HERE
000b83 1d8d          .dw XT_MINUS
000b84 1c1a          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
000b85 0002          .dw $0002
000b86 6f74          .db "to"
000b87 0b7b          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000b88 1c00          .dw DO_COLON
                 PFA_TO:
                 .endif
000b89 0832          .dw XT_TICK
000b8a 0d6b          .dw XT_TO_BODY
000b8b 056d          .dw XT_STATE
000b8c 1c73          .dw XT_FETCH
000b8d 1c30          .dw XT_DOCONDBRANCH
000b8e 0b99          DEST(PFA_TO1)
000b8f 0250          .dw XT_COMPILE
000b90 0b93          .dw XT_DOTO
000b91 025b          .dw XT_COMMA
000b92 1c1a          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
000b93 1c00          .dw DO_COLON
                 PFA_DOTO:
                 .endif
000b94 1cf0          .dw XT_R_FROM
000b95 1cab          .dw XT_DUP
000b96 0ba5          .dw XT_ICELLPLUS
000b97 1cf9          .dw XT_TO_R
000b98 1fba          .dw XT_FETCHI
                 PFA_TO1:
000b99 1cab          .dw XT_DUP
000b9a 0ba5          .dw XT_ICELLPLUS
000b9b 0ba5          .dw XT_ICELLPLUS
000b9c 1fba          .dw XT_FETCHI
000b9d 1c24          .dw XT_EXECUTE
000b9e 1c1a          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
000b9f ff07          .dw $FF07
000ba0 2d69
000ba1 6563
000ba2 6c6c
000ba3 002b          .db "i-cell+",0
000ba4 0b85          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
000ba5 1c00          .dw DO_COLON
                 PFA_ICELLPLUS:
000ba6 1e29          .dw XT_1PLUS
000ba7 1c1a          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
000ba8 ff07          .dw $ff07
000ba9 6445
000baa 6665
000bab 7265
000bac 0040          .db "Edefer@",0
000bad 0b9f          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
000bae 1c00          .dw DO_COLON
                 PFA_EDEFERFETCH:
000baf 1fba          .dw XT_FETCHI
000bb0 1f4d          .dw XT_FETCHE
000bb1 1c1a          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
000bb2 ff07          .dw $ff07
000bb3 6445
000bb4 6665
000bb5 7265
000bb6 0021          .db "Edefer!",0
000bb7 0ba8          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
000bb8 1c00          .dw DO_COLON
                 PFA_EDEFERSTORE:
000bb9 1fba          .dw XT_FETCHI
000bba 1f29          .dw XT_STOREE
000bbb 1c1a          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
000bbc ff07          .dw $ff07
000bbd 6452
000bbe 6665
000bbf 7265
000bc0 0040          .db "Rdefer@",0
000bc1 0bb2          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
000bc2 1c00          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
000bc3 1fba          .dw XT_FETCHI
000bc4 1c73          .dw XT_FETCH
000bc5 1c1a          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
000bc6 ff07          .dw $ff07
000bc7 6452
000bc8 6665
000bc9 7265
000bca 0021          .db "Rdefer!",0
000bcb 0bbc          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
000bcc 1c00          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
000bcd 1fba          .dw XT_FETCHI
000bce 1c7b          .dw XT_STORE
000bcf 1c1a          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
000bd0 ff07          .dw $ff07
000bd1 6455
000bd2 6665
000bd3 7265
000bd4 0040          .db "Udefer@",0
000bd5 0bc6          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
000bd6 1c00          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
000bd7 1fba          .dw XT_FETCHI
000bd8 1ef0          .dw XT_UP_FETCH
000bd9 1d97          .dw XT_PLUS
000bda 1c73          .dw XT_FETCH
000bdb 1c1a          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
000bdc ff07          .dw $ff07
000bdd 6455
000bde 6665
000bdf 7265
000be0 0021          .db "Udefer!",0
000be1 0bd0          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
000be2 1c00          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
000be3 1fba          .dw XT_FETCHI
000be4 1ef0          .dw XT_UP_FETCH
000be5 1d97          .dw XT_PLUS
000be6 1c7b          .dw XT_STORE
000be7 1c1a          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
000be8 ff06          .dw $ff06
000be9 6564
000bea 6566
000beb 2172          .db "defer!"
000bec 0bdc          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
000bed 1c00          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
000bee 0d6b          .dw XT_TO_BODY
000bef 1cab          .dw XT_DUP
000bf0 0ba5          .dw XT_ICELLPLUS
000bf1 0ba5          .dw XT_ICELLPLUS
000bf2 1fba          .dw XT_FETCHI
000bf3 1c24          .dw XT_EXECUTE
000bf4 1c1a          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
000bf5 ff06          .dw $ff06
000bf6 6564
000bf7 6566
000bf8 4072          .db "defer@"
000bf9 0be8          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
000bfa 1c00          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
000bfb 0d6b          .dw XT_TO_BODY 
000bfc 1cab          .dw XT_DUP
000bfd 0ba5          .dw XT_ICELLPLUS
000bfe 1fba          .dw XT_FETCHI
000bff 1c24          .dw XT_EXECUTE
000c00 1c1a          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
000c01 ff07          .dw $ff07
000c02 6428
000c03 6665
000c04 7265
000c05 0029          .db "(defer)", 0
000c06 0bf5          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
000c07 1c00          .dw DO_COLON
                 PFA_DODEFER:
000c08 022d          .dw XT_DOCREATE
000c09 038d          .dw XT_REVEAL
000c0a 0250          .dw XT_COMPILE
000c0b 0c0d          .dw PFA_DODEFER1
000c0c 1c1a          .dw XT_EXIT
                 PFA_DODEFER1:
000c0d 940e 03a6     call_ DO_DODOES
000c0f 1cab          .dw XT_DUP
000c10 0ba5          .dw XT_ICELLPLUS
000c11 1fba          .dw XT_FETCHI
000c12 1c24          .dw XT_EXECUTE 
000c13 1c24          .dw XT_EXECUTE
000c14 1c1a          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
000c15 ff0f          .dw $ff0f
000c16 6573
000c17 7261
000c18 6863
000c19 772d
000c1a 726f
000c1b 6c64
000c1c 7369
000c1d 0074          .db "search-wordlist",0
000c1e 0c01          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
000c1f 1c00          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
000c20 1cf9          .dw XT_TO_R
000c21 1d4e          .dw XT_ZERO
000c22 1c37          .dw XT_DOLITERAL
000c23 0c34          .dw XT_ISWORD
000c24 1cf0          .dw XT_R_FROM
000c25 0c51          .dw XT_TRAVERSEWORDLIST
000c26 1cab          .dw XT_DUP
000c27 1d14          .dw XT_ZEROEQUAL
000c28 1c30          .dw XT_DOCONDBRANCH
000c29 0c2e          DEST(PFA_SEARCH_WORDLIST1)
000c2a 0591             .dw XT_2DROP
000c2b 1cd3             .dw XT_DROP
000c2c 1d4e             .dw XT_ZERO
000c2d 1c1a             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
000c2e 1cab            .dw XT_DUP
000c2f 0c78            .dw XT_NFA2CFA
                       ; .. and get the header flag
000c30 1cbe            .dw XT_SWAP
000c31 0112            .dw XT_NAME2FLAGS
000c32 00ff            .dw XT_IMMEDIATEQ
000c33 1c1a          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
000c34 1c00          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
000c35 1cf9          .dw XT_TO_R
000c36 1cd3          .dw XT_DROP
000c37 0588          .dw XT_2DUP
000c38 1d02          .dw XT_R_FETCH  ; -- addr len addr len nt
000c39 0c6c          .dw XT_NAME2STRING
000c3a 0c82          .dw XT_ICOMPARE      ; (-- addr len f )
000c3b 1c30          .dw XT_DOCONDBRANCH
000c3c 0c42          DEST(PFA_ISWORD3)
                       ; not now
000c3d 1cf0            .dw XT_R_FROM
000c3e 1cd3            .dw XT_DROP
000c3f 1d4e            .dw XT_ZERO
000c40 1d45            .dw XT_TRUE         ; maybe next word
000c41 1c1a            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
000c42 0591            .dw XT_2DROP
000c43 1cf0            .dw XT_R_FROM
000c44 1d4e            .dw XT_ZERO       ; finish traverse-wordlist
000c45 1c1a            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
000c46 ff11          .dw $ff11
000c47 7274
000c48 7661
000c49 7265
000c4a 6573
000c4b 772d
000c4c 726f
000c4d 6c64
000c4e 7369
000c4f 0074          .db "traverse-wordlist",0
000c50 0c15          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
000c51 1c00          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
000c52 1f4d          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
000c53 1cab          .dw XT_DUP           ; ( -- xt nt nt )
000c54 1c30          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
000c55 0c62          DEST(PFA_TRAVERSEWORDLIST2)
000c56 0588          .dw XT_2DUP
000c57 1f0c          .dw XT_2TO_R
000c58 1cbe          .dw XT_SWAP
000c59 1c24          .dw XT_EXECUTE
000c5a 1f1b          .dw XT_2R_FROM
000c5b 1cdb          .dw XT_ROT
000c5c 1c30          .dw XT_DOCONDBRANCH
000c5d 0c62          DEST(PFA_TRAVERSEWORDLIST2)
000c5e 04fa          .dw XT_NFA2LFA
000c5f 1fba          .dw XT_FETCHI
000c60 1c29          .dw XT_DOBRANCH      ; ( -- addr )
000c61 0c53          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
000c62 0591          .dw XT_2DROP
000c63 1c1a          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                 ;        begin @ dup
                 ;        while
                 ;          2dup 2>r
                 ;          swap execute ( i*x nt -- i*x' f )
                 ;          2r> rot
                 ;        while
                 ;          nfa>lfa @i
                 ;        repeat then 2drop ;
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
000c64 ff0b          .dw $ff0b
000c65 616e
000c66 656d
000c67 733e
000c68 7274
000c69 6e69
000c6a 0067          .db "name>string",0
000c6b 0c46          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
000c6c 1c00          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
000c6d 07f4          .dw XT_ICOUNT   ; ( -- addr n )
000c6e 1c37          .dw XT_DOLITERAL
000c6f 00ff          .dw 255
000c70 1e0d          .dw XT_AND      ; mask immediate bit
000c71 1c1a          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
000c72 ff07          .dw $ff07
000c73 666e
000c74 3e61
000c75 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
000c76 0061          .db "nfa>cfa"
000c77 0c64          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
000c78 1c00          .dw DO_COLON
                 PFA_NFA2CFA:
000c79 04fa          .dw XT_NFA2LFA ; skip to link field
000c7a 1e29          .dw XT_1PLUS   ; next is the execution token
000c7b 1c1a          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
000c7c ff08          .dw $ff08
000c7d 6369
000c7e 6d6f
000c7f 6170
000c80 6572          .db "icompare"
000c81 0c72          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
000c82 1c00          .dw DO_COLON
                 PFA_ICOMPARE:
000c83 1cf9          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
000c84 1cc9          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
000c85 1cf0          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
000c86 1d0d          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
000c87 1c30          .dw XT_DOCONDBRANCH
000c88 0c8d          .dw PFA_ICOMPARE_SAMELEN
000c89 0591            .dw XT_2DROP
000c8a 1cd3            .dw XT_DROP
000c8b 1d45            .dw XT_TRUE
000c8c 1c1a            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
000c8d 1cbe          .dw XT_SWAP ; ( -- r-addr f-addr len )
000c8e 1d4e          .dw XT_ZERO
000c8f 031a          .dw XT_QDOCHECK
000c90 1c30          .dw XT_DOCONDBRANCH
000c91 0cb0          .dw PFA_ICOMPARE_DONE
000c92 1e89          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
000c93 1cc9          .dw XT_OVER
000c94 1c73          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
000c95 1cc9          .dw XT_OVER
000c96 1fba          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
000c97 1cab          .dw XT_DUP
                     ;.dw XT_BYTESWAP
000c98 1c37          .dw XT_DOLITERAL
000c99 0100          .dw $100
000c9a 1d56          .dw XT_ULESS
000c9b 1c30          .dw XT_DOCONDBRANCH
000c9c 0ca1          .dw PFA_ICOMPARE_LASTCELL
000c9d 1cbe          .dw XT_SWAP
000c9e 1c37          .dw XT_DOLITERAL
000c9f 00ff          .dw $00FF
000ca0 1e0d          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000ca1 1d0d          .dw XT_NOTEQUAL
000ca2 1c30          .dw XT_DOCONDBRANCH
000ca3 0ca8          .dw PFA_ICOMPARE_NEXTLOOP
000ca4 0591          .dw XT_2DROP
000ca5 1d45          .dw XT_TRUE
000ca6 1ec2          .dw XT_UNLOOP
000ca7 1c1a          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
000ca8 1e29          .dw XT_1PLUS
000ca9 1cbe          .dw XT_SWAP
000caa 0580          .dw XT_CELLPLUS
000cab 1cbe          .dw XT_SWAP
000cac 1c37          .dw XT_DOLITERAL
000cad 0002          .dw 2
000cae 1ea8          .dw XT_DOPLUSLOOP
000caf 0c93          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
000cb0 0591          .dw XT_2DROP
000cb1 1d4e          .dw XT_ZERO
000cb2 1c1a          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
000cb3 ff01          .dw $ff01
000cb4 002a          .db "*",0
000cb5 0c7c          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000cb6 1c00          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
000cb7 1da0          .dw XT_MSTAR
000cb8 1cd3          .dw XT_DROP
000cb9 1c1a          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
000cba ff01          .dw $FF01
000cbb 006a          .db "j",0
000cbc 0cb3          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
000cbd 1c00          .dw DO_COLON
                 PFA_J:
000cbe 1e64          .dw XT_RP_FETCH
000cbf 1c37          .dw XT_DOLITERAL
000cc0 0007          .dw 7
000cc1 1d97          .dw XT_PLUS
000cc2 1c73          .dw XT_FETCH
000cc3 1e64          .dw XT_RP_FETCH
000cc4 1c37          .dw XT_DOLITERAL
000cc5 0009          .dw 9
000cc6 1d97          .dw XT_PLUS
000cc7 1c73          .dw XT_FETCH
000cc8 1d97          .dw XT_PLUS
000cc9 1c1a          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
000cca ff04          .dw $ff04
000ccb 6164
000ccc 7362          .db "dabs"
000ccd 0cba          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000cce 1c00          .dw DO_COLON
                 PFA_DABS:
000ccf 1cab          .dw XT_DUP
000cd0 1d1b          .dw XT_ZEROLESS
000cd1 1c30          .dw XT_DOCONDBRANCH
000cd2 0cd4          .dw PFA_DABS1
000cd3 0cdb          .dw XT_DNEGATE
                 PFA_DABS1:
000cd4 1c1a          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000cd5 ff07          .dw $ff07
000cd6 6e64
000cd7 6765
000cd8 7461
000cd9 0065          .db "dnegate",0
000cda 0cca          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
000cdb 1c00          .dw DO_COLON
                 PFA_DNEGATE:
000cdc 0161          .dw XT_DINVERT
000cdd 1c37          .dw XT_DOLITERAL
000cde 0001          .dw 1
000cdf 1d4e          .dw XT_ZERO
000ce0 0139          .dw XT_DPLUS
000ce1 1c1a          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000ce2 ff05          .dw $ff05
000ce3 6d63
000ce4 766f
000ce5 0065          .db "cmove",0
000ce6 0cd5          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
000ce7 0ce8          .dw PFA_CMOVE
                 PFA_CMOVE:
000ce8 93bf          push xh
000ce9 93af          push xl
000cea 91e9          ld zl, Y+
000ceb 91f9          ld zh, Y+ ; addr-to
000cec 91a9          ld xl, Y+
000ced 91b9          ld xh, Y+ ; addr-from
000cee 2f09          mov temp0, tosh
000cef 2b08          or temp0, tosl
000cf0 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
000cf1 911d          ld temp1, X+
000cf2 9311          st Z+, temp1
000cf3 9701          sbiw tosl, 1
000cf4 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
000cf5 91af          pop xl
000cf6 91bf          pop xh
000cf7 9189
000cf8 9199          loadtos
000cf9 940c 1c04     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
000cfb ff05          .dw $ff05
000cfc 7332
000cfd 6177
000cfe 0070          .db "2swap",0
000cff 0ce2          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
000d00 1c00          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
000d01 1cdb          .dw XT_ROT
000d02 1cf9          .dw XT_TO_R
000d03 1cdb          .dw XT_ROT
000d04 1cf0          .dw XT_R_FROM
000d05 1c1a          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System
                 ; refills the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILLTIB:
000d06 ff0a          .dw $ff0a
000d07 6572
000d08 6966
000d09 6c6c
000d0a 742d
000d0b 6269          .db "refill-tib"
000d0c 0cfb          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
000d0d 1c00          .dw DO_COLON
                 PFA_REFILLTIB:
                 .endif
000d0e 0d29          .dw XT_TIB
000d0f 1c37          .dw XT_DOLITERAL
000d10 005a          .dw TIB_SIZE
000d11 08b1          .dw XT_ACCEPT
000d12 0d2f          .dw XT_NUMBERTIB
000d13 1c7b          .dw XT_STORE
000d14 1d4e          .dw XT_ZERO
000d15 05a1          .dw XT_TO_IN
000d16 1c7b          .dw XT_STORE
000d17 1d45          .dw XT_TRUE ; -1
000d18 1c1a          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCETIB:
000d19 ff0a          .dw $FF0A
000d1a 6f73
000d1b 7275
000d1c 6563
000d1d 742d
000d1e 6269          .db "source-tib"
000d1f 0d06          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
000d20 1c00          .dw DO_COLON
                 PFA_SOURCETIB:
                 .endif
000d21 0d29          .dw XT_TIB
000d22 0d2f          .dw XT_NUMBERTIB
000d23 1c73          .dw XT_FETCH
000d24 1c1a          .dw XT_EXIT
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; terminal input buffer address
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TIB:
000d25 ff03          .dw $ff03
000d26 6974
000d27 0062          .db "tib",0
000d28 0d19          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
000d29 1c42          .dw PFA_DOVARIABLE
                 PFA_TIB:
000d2a 014b          .dw ram_tib
                 .dseg
00014b           ram_tib: .byte TIB_SIZE
                 .cseg
                 .endif
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBERTIB:
000d2b ff04          .dw $ff04
000d2c 7423
000d2d 6269          .db "#tib"
000d2e 0d25          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
000d2f 1c42          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000d30 01a5          .dw ram_sharptib
                 .dseg
0001a5           ram_sharptib: .byte 2
                 .cseg
                 .endif
                 
                 .include "words/init-ram.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
000d31 ff06        .dw $ff06
000d32 6565
000d33 723e
000d34 6d61        .db "ee>ram"
000d35 0d2b        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
000d36 1c00        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
000d37 1d4e          .dw XT_ZERO
000d38 1e89          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000d39 1cc9          .dw XT_OVER
000d3a 1f4d          .dw XT_FETCHE
000d3b 1cc9          .dw XT_OVER
000d3c 1c7b          .dw XT_STORE
000d3d 0580          .dw XT_CELLPLUS
000d3e 1cbe          .dw XT_SWAP
000d3f 0580          .dw XT_CELLPLUS
000d40 1cbe          .dw XT_SWAP
000d41 1eb7          .dw XT_DOLOOP
000d42 0d39          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
000d43 0591          .dw XT_2DROP
000d44 1c1a          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INIT_RAM:
000d45 ff08        .dw $ff08
000d46 6e69
000d47 7469
000d48 722d
000d49 6d61        .db "init-ram"
000d4a 0d31        .dw VE_HEAD
                   .set VE_HEAD = VE_INIT_RAM
                 XT_INIT_RAM:
000d4b 1c00        .dw DO_COLON
                 PFA_INI_RAM:          ; ( -- )
000d4c 1c37          .dw XT_DOLITERAL
000d4d 0062          .dw EE_INITUSER
000d4e 1ef0          .dw XT_UP_FETCH
000d4f 1c37          .dw XT_DOLITERAL
000d50 001c          .dw SYSUSERSIZE
000d51 1dfe          .dw XT_2SLASH
000d52 0d36          .dw XT_EE2RAM
000d53 1c1a          .dw XT_EXIT
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
000d54 ff06          .dw $ff06
000d55 6f62
000d56 6e75
000d57 7364          .db "bounds"
000d58 0d45          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
000d59 1c00          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
000d5a 1cc9          .dw XT_OVER
000d5b 1d97          .dw XT_PLUS
000d5c 1cbe          .dw XT_SWAP
000d5d 1c1a          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
000d5e ff03          .dw $ff03
000d5f 3e73
000d60 0064          .db "s>d",0
000d61 0d54          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
000d62 1c00          .dw DO_COLON
                 PFA_S2D:
                 .endif
000d63 1cab          .dw XT_DUP
000d64 1d1b          .dw XT_ZEROLESS
000d65 1c1a          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
000d66 ff05          .dw $ff05
000d67 623e
000d68 646f
000d69 0079          .db ">body",0
000d6a 0d5e          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
000d6b 1e2a          .dw PFA_1PLUS
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000d6c ff0b          .dw $ff0b
000d6d 7061
000d6e 6c70
000d6f 7574
000d70 6e72
000d71 656b
000d72 0079          .db "applturnkey",0
000d73 0d66          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000d74 1c00          .dw DO_COLON
                 PFA_APPLTURNKEY:
000d75 00ae          .dw XT_USART
000d76 01a8          .dw XT_INTON
000d77 0b5e          .dw XT_DOT_VER
000d78 1c1a          .dw XT_EXIT
                 
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
001c00 93bf          push XH
001c01 93af          push XL          ; PUSH IP
001c02 01db          movw XL, wl
001c03 9611          adiw xl, 1
                 DO_NEXT:
001c04 f06e          brts DO_INTERRUPT
001c05 01fd          movw zl, XL        ; READ IP
001c06 0fee
001c07 1fff
001c08 9165
001c09 9175          readflashcell wl, wh
001c0a 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
001c0b 01fb          movw zl, wl
001c0c 0fee
001c0d 1fff
001c0e 9105
001c0f 9115          readflashcell temp0,temp1
001c10 01f8          movw zl, temp0
001c11 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
001c12 94e8          clt
001c13 ed66          ldi wl, LOW(XT_ISREXEC)
001c14 e071          ldi wh, HIGH(XT_ISREXEC)
001c15 cff5          rjmp DO_EXECUTE
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
001c16 ff04          .dw $ff04
001c17 7865
001c18 7469          .db "exit"
001c19 0d6c          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
001c1a 1c1b          .dw PFA_EXIT
                 PFA_EXIT:
001c1b 91af          pop XL
001c1c 91bf          pop XH
001c1d cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
001c1e ff07          .dw $ff07
001c1f 7865
001c20 6365
001c21 7475
001c22 0065          .db "execute",0
001c23 1c16          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
001c24 1c25          .dw PFA_EXECUTE
                 PFA_EXECUTE:
001c25 01bc          movw wl, tosl
001c26 9189
001c27 9199          loadtos
001c28 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
001c29 1c2a          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
001c2a 01fd          movw zl, XL
001c2b 0fee
001c2c 1fff
001c2d 91a5
001c2e 91b5          readflashcell XL,XH
001c2f cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
001c30 1c31          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
001c31 2b98          or tosh, tosl
001c32 9189
001c33 9199          loadtos
001c34 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
001c35 9611          adiw XL, 1
001c36 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
001c37 1c38          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
001c38 939a
001c39 938a          savetos
001c3a 01fd          movw zl, xl
001c3b 0fee
001c3c 1fff
001c3d 9185
001c3e 9195          readflashcell tosl,tosh
001c3f 9611          adiw xl, 1
001c40 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
001c41 1c42          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
001c42 939a
001c43 938a          savetos
001c44 01fb          movw zl, wl
001c45 9631          adiw zl,1
001c46 0fee
001c47 1fff
001c48 9185
001c49 9195          readflashcell tosl,tosh
001c4a cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
001c4b 1c4c          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
001c4c 939a
001c4d 938a          savetos
001c4e 01cb          movw tosl, wl
001c4f 9601          adiw tosl, 1
001c50 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
001c51 1c52          .dw PFA_DOUSER
                 PFA_DOUSER:
001c52 939a
001c53 938a          savetos
001c54 01fb          movw zl, wl
001c55 9631          adiw zl, 1
001c56 0fee
001c57 1fff
001c58 9185
001c59 9195          readflashcell tosl,tosh
001c5a 0d84          add tosl, upl
001c5b 1d95          adc tosh, uph
001c5c cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
001c5d ff07          .dw $ff07
001c5e 7628
001c5f 6c61
001c60 6575
001c61 0029          .db "(value)", 0
001c62 1c1e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
001c63 1c00          .dw DO_COLON
                 PFA_DOVALUE:
001c64 022d          .dw XT_DOCREATE
001c65 038d          .dw XT_REVEAL
001c66 0250          .dw XT_COMPILE
001c67 1c69          .dw PFA_DOVALUE1
001c68 1c1a          .dw XT_EXIT
                 PFA_DOVALUE1:
001c69 940e 03a6     call_ DO_DODOES
001c6b 1cab          .dw XT_DUP
001c6c 0ba5          .dw XT_ICELLPLUS
001c6d 1fba          .dw XT_FETCHI
001c6e 1c24          .dw XT_EXECUTE
001c6f 1c1a          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
001c70 ff01          .dw $ff01
001c71 0040          .db "@",0
001c72 1c5d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
001c73 1c74          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
001c74 01fc          movw zl, tosl
                     ; low byte is read before the high byte
001c75 9181          ld tosl, z+
001c76 9191          ld tosh, z+
001c77 cf8c          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
001c78 ff01          .dw $ff01
001c79 0021          .db "!",0
001c7a 1c70          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
001c7b 1c7c          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
001c7c 01fc          movw zl, tosl
001c7d 9189
001c7e 9199          loadtos
                     ; the high byte is written before the low byte
001c7f 8391          std Z+1, tosh
001c80 8380          std Z+0, tosl
001c81 9189
001c82 9199          loadtos
001c83 cf80          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
001c84 ff02          .dw $ff02
001c85 2163          .db "c!"
001c86 1c78          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
001c87 1c88          .dw PFA_CSTORE
                 PFA_CSTORE:
001c88 01fc          movw zl, tosl
001c89 9189
001c8a 9199          loadtos
001c8b 8380          st Z, tosl
001c8c 9189
001c8d 9199          loadtos
001c8e cf75          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
001c8f ff02          .dw $ff02
001c90 4063          .db "c@"
001c91 1c84          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
001c92 1c93          .dw PFA_CFETCH
                 PFA_CFETCH:
001c93 01fc          movw zl, tosl
001c94 2799          clr tosh
001c95 8180          ld tosl, Z
001c96 cf6d          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
001c97 ff02          .dw $ff02
001c98 7540          .db "@u"
001c99 1c8f          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
001c9a 1c00          .dw DO_COLON
                 PFA_FETCHU:
001c9b 1ef0          .dw XT_UP_FETCH
001c9c 1d97          .dw XT_PLUS
001c9d 1c73          .dw XT_FETCH
001c9e 1c1a          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
001c9f ff02          .dw $ff02
001ca0 7521          .db "!u"
001ca1 1c97          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
001ca2 1c00          .dw DO_COLON
                 PFA_STOREU:
001ca3 1ef0          .dw XT_UP_FETCH
001ca4 1d97          .dw XT_PLUS
001ca5 1c7b          .dw XT_STORE
001ca6 1c1a          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
001ca7 ff03          .dw $ff03
001ca8 7564
001ca9 0070          .db "dup",0
001caa 1c9f          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
001cab 1cac          .dw PFA_DUP
                 PFA_DUP:
001cac 939a
001cad 938a          savetos
001cae cf55          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
001caf ff04          .dw $ff04
001cb0 643f
001cb1 7075          .db "?dup"
001cb2 1ca7          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
001cb3 1cb4          .dw PFA_QDUP
                 PFA_QDUP:
001cb4 2f08          mov temp0, tosl
001cb5 2b09          or temp0, tosh
001cb6 f011          breq PFA_QDUP1
001cb7 939a
001cb8 938a          savetos
                 PFA_QDUP1:
001cb9 cf4a          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
001cba ff04          .dw $ff04
001cbb 7773
001cbc 7061          .db "swap"
001cbd 1caf          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
001cbe 1cbf          .dw PFA_SWAP
                 PFA_SWAP:
001cbf 018c          movw temp0, tosl
001cc0 9189
001cc1 9199          loadtos
001cc2 931a          st -Y, temp1
001cc3 930a          st -Y, temp0
001cc4 cf3f          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
001cc5 ff04          .dw $ff04
001cc6 766f
001cc7 7265          .db "over"
001cc8 1cba          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
001cc9 1cca          .dw PFA_OVER
                 PFA_OVER:
001cca 939a
001ccb 938a          savetos
001ccc 818a          ldd tosl, Y+2
001ccd 819b          ldd tosh, Y+3
                 
001cce cf35          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
001ccf ff04          .dw $ff04
001cd0 7264
001cd1 706f          .db "drop"
001cd2 1cc5          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
001cd3 1cd4          .dw PFA_DROP
                 PFA_DROP:
001cd4 9189
001cd5 9199          loadtos
001cd6 cf2d          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
001cd7 ff03          .dw $ff03
001cd8 6f72
001cd9 0074          .db "rot",0
001cda 1ccf          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
001cdb 1cdc          .dw PFA_ROT
                 PFA_ROT:
001cdc 018c          movw temp0, tosl
001cdd 9129          ld temp2, Y+
001cde 9139          ld temp3, Y+ 
001cdf 9189
001ce0 9199          loadtos
                         
001ce1 933a          st -Y, temp3
001ce2 932a          st -Y, temp2
001ce3 931a          st -Y, temp1
001ce4 930a          st -Y, temp0
                 
001ce5 cf1e          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
001ce6 ff03          .dw $ff03
001ce7 696e
001ce8 0070          .db "nip",0
001ce9 1cd7          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
001cea 1ceb          .dw PFA_NIP
                 PFA_NIP:
001ceb 9622          adiw yl, 2
001cec cf17          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
001ced ff02          .dw $ff02
001cee 3e72          .db "r>"
001cef 1ce6          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
001cf0 1cf1          .dw PFA_R_FROM
                 PFA_R_FROM:
001cf1 939a
001cf2 938a          savetos
001cf3 918f          pop tosl
001cf4 919f          pop tosh
001cf5 cf0e          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
001cf6 ff02          .dw $ff02
001cf7 723e          .db ">r"
001cf8 1ced          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
001cf9 1cfa          .dw PFA_TO_R
                 PFA_TO_R:
001cfa 939f          push tosh
001cfb 938f          push tosl
001cfc 9189
001cfd 9199          loadtos
001cfe cf05          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
001cff ff02          .dw $ff02
001d00 4072          .db "r@"
001d01 1cf6          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
001d02 1d03          .dw PFA_R_FETCH
                 PFA_R_FETCH:
001d03 939a
001d04 938a          savetos
001d05 918f          pop tosl
001d06 919f          pop tosh
001d07 939f          push tosh
001d08 938f          push tosl
001d09 cefa          jmp_ DO_NEXT
                 
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
001d0a ff02          .dw $ff02
001d0b 3e3c          .db "<>"
001d0c 1cff          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
001d0d 1c00          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
001d0e 1fcf
001d0f 1d14
001d10 1c1a          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
001d11 ff02          .dw $ff02
001d12 3d30          .db "0="
001d13 1d0a          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
001d14 1d15          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
001d15 2b98          or tosh, tosl
001d16 f5d1          brne PFA_ZERO1
001d17 c030          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
001d18 ff02          .dw $ff02
001d19 3c30          .db "0<"
001d1a 1d11          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
001d1b 1d1c          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
001d1c fd97          sbrc tosh,7
001d1d c02a          rjmp PFA_TRUE1
001d1e c032          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
001d1f ff02          .dw $ff02
001d20 3e30          .db "0>"
001d21 1d18          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
001d22 1d23          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
001d23 1582          cp tosl, zerol
001d24 0593          cpc tosh, zeroh
001d25 f15c          brlt PFA_ZERO1
001d26 f151          brbs 1, PFA_ZERO1
001d27 c020          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
001d28 ff03          .dw $ff03
001d29 3064
001d2a 003e          .db "d0>",0
001d2b 1d1f          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
001d2c 1d2d          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
001d2d 1582          cp tosl, zerol
001d2e 0593          cpc tosh, zeroh
001d2f 9189
001d30 9199          loadtos
001d31 0582          cpc tosl, zerol
001d32 0593          cpc tosh, zeroh
001d33 f0ec          brlt PFA_ZERO1
001d34 f0e1          brbs 1, PFA_ZERO1
001d35 c012          rjmp PFA_TRUE1
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
001d36 ff03          .dw $ff03
001d37 3064
001d38 003c          .db "d0<",0
001d39 1d28          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
001d3a 1d3b          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
001d3b 9622          adiw Y,2
001d3c fd97          sbrc tosh,7
001d3d 940c 1d48     jmp PFA_TRUE1
001d3f 940c 1d51     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
001d41 ff04          .dw $ff04
001d42 7274
001d43 6575          .db "true"
001d44 1d36          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
001d45 1d46          .dw PFA_TRUE
                 PFA_TRUE:
001d46 939a
001d47 938a          savetos
                 PFA_TRUE1:
001d48 ef8f          ser tosl
001d49 ef9f          ser tosh
001d4a ceb9          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
001d4b ff01          .dw $ff01
001d4c 0030          .db "0",0
001d4d 1d41          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
001d4e 1d4f          .dw PFA_ZERO
                 PFA_ZERO:
001d4f 939a
001d50 938a          savetos
                 PFA_ZERO1:
001d51 01c1          movw tosl, zerol
001d52 ceb1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
001d53 ff02          .dw $ff02
001d54 3c75          .db "u<"
001d55 1d4b          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
001d56 1d57          .dw PFA_ULESS
                 PFA_ULESS:
001d57 9129          ld temp2, Y+
001d58 9139          ld temp3, Y+
001d59 1782          cp tosl, temp2
001d5a 0793          cpc tosh, temp3
001d5b f3a8          brlo PFA_ZERO1
001d5c f3a1          brbs 1, PFA_ZERO1
001d5d cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
001d5e ff02          .dw $ff02
001d5f 3e75          .db "u>"
001d60 1d53          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
001d61 1c00          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
001d62 1cbe          .DW XT_SWAP
001d63 1d56          .dw XT_ULESS
001d64 1c1a          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
001d65 ff01          .dw $ff01
001d66 003c          .db "<",0
001d67 1d5e          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
001d68 1d69          .dw PFA_LESS
                 PFA_LESS:
001d69 9129          ld temp2, Y+
001d6a 9139          ld temp3, Y+
001d6b 1728          cp temp2, tosl
001d6c 0739          cpc temp3, tosh
                 PFA_LESSDONE:
001d6d f71c          brge PFA_ZERO1
001d6e cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
001d6f ff01          .dw $ff01
001d70 003e          .db ">",0
001d71 1d65          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
001d72 1d73          .dw PFA_GREATER
                 PFA_GREATER:
001d73 9129          ld temp2, Y+
001d74 9139          ld temp3, Y+
001d75 1728          cp temp2, tosl
001d76 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
001d77 f2cc          brlt PFA_ZERO1
001d78 f2c1          brbs 1, PFA_ZERO1
001d79 cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
001d7a ff04          .dw $ff04
001d7b 6f6c
001d7c 3267          .db "log2"
001d7d 1d6f          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
001d7e 1d7f          .dw PFA_LOG2
                 PFA_LOG2:
001d7f 01fc          movw zl, tosl
001d80 2799          clr tosh
001d81 e180          ldi tosl, 16
                 PFA_LOG2_1:
001d82 958a          dec tosl
001d83 f022          brmi PFA_LOG2_2 ; wrong data
001d84 0fee          lsl  zl
001d85 1fff          rol  zh
001d86 f7d8          brcc PFA_LOG2_1
001d87 ce7c          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
001d88 959a          dec tosh
001d89 ce7a          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
001d8a ff01          .dw $ff01
001d8b 002d          .db "-",0
001d8c 1d7a          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
001d8d 1d8e          .dw PFA_MINUS
                 PFA_MINUS:
001d8e 9109          ld temp0, Y+
001d8f 9119          ld temp1, Y+
001d90 1b08          sub temp0, tosl
001d91 0b19          sbc temp1, tosh
001d92 01c8          movw tosl, temp0
001d93 ce70          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
001d94 ff01          .dw $ff01
001d95 002b          .db "+",0
001d96 1d8a          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
001d97 1d98          .dw PFA_PLUS
                 PFA_PLUS:
001d98 9109          ld temp0, Y+
001d99 9119          ld temp1, Y+
001d9a 0f80          add tosl, temp0
001d9b 1f91          adc tosh, temp1
001d9c ce67          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
001d9d ff02          .dw $ff02
001d9e 2a6d          .db "m*"
001d9f 1d94          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
001da0 1da1          .dw PFA_MSTAR
                 PFA_MSTAR:
001da1 018c          movw temp0, tosl
001da2 9189
001da3 9199          loadtos
001da4 019c          movw temp2, tosl
                     ; high cell ah*bh
001da5 0231          muls temp3, temp1
001da6 0170          movw temp4, r0
                     ; low cell  al*bl
001da7 9f20          mul  temp2, temp0
001da8 01c0          movw tosl, r0
                     ; signed ah*bl
001da9 0330          mulsu temp3, temp0
001daa 08f3          sbc   temp5, zeroh
001dab 0d90          add   tosh,  r0
001dac 1ce1          adc   temp4, r1
001dad 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
001dae 0312          mulsu temp1, temp2
001daf 08f3          sbc   temp5, zeroh
001db0 0d90          add   tosh,  r0
001db1 1ce1          adc   temp4, r1
001db2 1cf3          adc   temp5, zeroh
                 
001db3 939a
001db4 938a          savetos
001db5 01c7          movw tosl, temp4
001db6 ce4d          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
001db7 ff06          .dw $ff06
001db8 6d75
001db9 6d2f
001dba 646f          .db "um/mod"
001dbb 1d9d          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
001dbc 1dbd          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
001dbd 017c          movw temp4, tosl
                 
001dbe 9129          ld temp2, Y+
001dbf 9139          ld temp3, Y+
                   
001dc0 9109          ld temp0, Y+
001dc1 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
001dc2 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
001dc3 2755          clr temp7
001dc4 0f00          lsl temp0
001dc5 1f11          rol temp1
001dc6 1f22          rol temp2
001dc7 1f33          rol temp3
001dc8 1f55          rol temp7
                 
                   ; try subtracting divisor
001dc9 152e          cp temp2, temp4
001dca 053f          cpc temp3, temp5
001dcb 0552          cpc temp7,zerol
                 
001dcc f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
001dcd 9503          inc temp0
001dce 192e          sub temp2, temp4
001dcf 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
001dd0 954a          dec  temp6
001dd1 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
001dd2 933a          st -Y,temp3
001dd3 932a          st -Y,temp2
                 
                     ; put quotient on stack
001dd4 01c8          movw tosl, temp0
001dd5 ce2e          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
001dd6 ff03          .dw $ff03
001dd7 6d75
001dd8 002a          .db "um*",0
001dd9 1db7          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
001dda 1ddb          .dw PFA_UMSTAR
                 PFA_UMSTAR:
001ddb 018c          movw temp0, tosl
001ddc 9189
001ddd 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
001dde 9f80          mul tosl,temp0
001ddf 01f0          movw zl, r0
001de0 2722          clr temp2
001de1 2733          clr temp3
                     ; middle bytes
001de2 9f90          mul tosh, temp0
001de3 0df0          add zh, r0
001de4 1d21          adc temp2, r1
001de5 1d33          adc temp3, zeroh
                         
001de6 9f81          mul tosl, temp1
001de7 0df0          add zh, r0
001de8 1d21          adc temp2, r1
001de9 1d33          adc temp3, zeroh
                     
001dea 9f91          mul tosh, temp1
001deb 0d20          add temp2, r0
001dec 1d31          adc temp3, r1
001ded 01cf          movw tosl, zl
001dee 939a
001def 938a          savetos
001df0 01c9          movw tosl, temp2
001df1 ce12          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
001df2 ff06          .dw $ff06
001df3 6e69
001df4 6576
001df5 7472          .db "invert"
001df6 1dd6          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
001df7 1df8          .dw PFA_INVERT
                 PFA_INVERT:
001df8 9580          com tosl
001df9 9590          com tosh
001dfa ce09          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
001dfb ff02          .dw $ff02
001dfc 2f32          .db "2/"
001dfd 1df2          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
001dfe 1dff          .dw PFA_2SLASH
                 PFA_2SLASH:
001dff 9595          asr tosh
001e00 9587          ror tosl
001e01 ce02          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
001e02 ff02          .dw $ff02
001e03 2a32          .db "2*"
001e04 1dfb          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
001e05 1e06          .dw PFA_2STAR
                 PFA_2STAR:
001e06 0f88          lsl tosl
001e07 1f99          rol tosh
001e08 cdfb          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
001e09 ff03          .dw $ff03
001e0a 6e61
001e0b 0064          .db "and",0
001e0c 1e02          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
001e0d 1e0e          .dw PFA_AND
                 PFA_AND:
001e0e 9109          ld temp0, Y+
001e0f 9119          ld temp1, Y+
001e10 2380          and tosl, temp0
001e11 2391          and tosh, temp1
001e12 cdf1          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
001e13 ff02          .dw $ff02
001e14 726f          .db "or"
001e15 1e09          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
001e16 1e17          .dw PFA_OR
                 PFA_OR:
001e17 9109          ld temp0, Y+
001e18 9119          ld temp1, Y+
001e19 2b80          or tosl, temp0
001e1a 2b91          or tosh, temp1
001e1b cde8          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
001e1c ff03          .dw $ff03
001e1d 6f78
001e1e 0072          .db "xor",0
001e1f 1e13          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
001e20 1e21          .dw PFA_XOR
                 PFA_XOR:
001e21 9109          ld temp0, Y+
001e22 9119          ld temp1, Y+
001e23 2780          eor tosl, temp0
001e24 2791          eor tosh, temp1
001e25 cdde          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
001e26 ff02          .dw $ff02
001e27 2b31          .db "1+"
001e28 1e1c          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
001e29 1e2a          .dw PFA_1PLUS
                 PFA_1PLUS:
001e2a 9601          adiw tosl,1
001e2b cdd8          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
001e2c ff02          .dw $ff02 
001e2d 2d31          .db "1-"
001e2e 1e26          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
001e2f 1e30          .dw PFA_1MINUS
                 PFA_1MINUS:
001e30 9701          sbiw tosl, 1
001e31 cdd2          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
001e32 ff06          .dw $ff06
001e33 736c
001e34 6968
001e35 7466          .db "lshift"
001e36 1e2c          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
001e37 1e38          .dw PFA_LSHIFT
                 PFA_LSHIFT:
001e38 01fc          movw zl, tosl
001e39 9189
001e3a 9199          loadtos
                 PFA_LSHIFT1:
001e3b 9731          sbiw zl, 1
001e3c f01a          brmi PFA_LSHIFT2
001e3d 0f88          lsl tosl
001e3e 1f99          rol tosh
001e3f cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
001e40 cdc3          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
001e41 ff06          .dw $ff06
001e42 7372
001e43 6968
001e44 7466          .db "rshift"
001e45 1e32          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
001e46 1e47          .dw PFA_RSHIFT
                 PFA_RSHIFT:
001e47 01fc          movw zl, tosl
001e48 9189
001e49 9199          loadtos
                 PFA_RSHIFT1:
001e4a 9731          sbiw zl, 1
001e4b f01a          brmi PFA_RSHIFT2
001e4c 9596          lsr tosh
001e4d 9587          ror tosl
001e4e cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
001e4f cdb4          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
001e50 ff02          .dw $ff02
001e51 212b          .db "+!"
001e52 1e41          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
001e53 1e54          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
001e54 01fc          movw zl, tosl
001e55 9189
001e56 9199          loadtos
001e57 8120          ldd temp2, Z+0
001e58 8131          ldd temp3, Z+1
001e59 0f82          add tosl, temp2
001e5a 1f93          adc tosh, temp3
001e5b 8380          std Z+0, tosl
001e5c 8391          std Z+1, tosh
001e5d 9189
001e5e 9199          loadtos
001e5f cda4          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
001e60 ff03          .dw $ff03
001e61 7072
001e62 0040          .db "rp@",0
001e63 1e50          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
001e64 1e65          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
001e65 939a
001e66 938a          savetos
001e67 b78d          in tosl, SPL
001e68 b79e          in tosh, SPH
001e69 cd9a          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
001e6a ff03          .dw $ff03
001e6b 7072
001e6c 0021          .db "rp!",0
001e6d 1e60          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
001e6e 1e6f          .dw PFA_RP_STORE
                 PFA_RP_STORE:
001e6f b72f          in temp2, SREG
001e70 94f8          cli
001e71 bf8d          out SPL, tosl
001e72 bf9e          out SPH, tosh
001e73 bf2f          out SREG, temp2
001e74 9189
001e75 9199          loadtos
001e76 cd8d          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
001e77 ff03          .dw $ff03
001e78 7073
001e79 0040          .db "sp@",0
001e7a 1e6a          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
001e7b 1e7c          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
001e7c 939a
001e7d 938a          savetos
001e7e 01ce          movw tosl, yl
001e7f cd84          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
001e80 ff03          .dw $ff03
001e81 7073
001e82 0021          .db "sp!",0
001e83 1e77          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
001e84 1e85          .dw PFA_SP_STORE
                 PFA_SP_STORE:
001e85 01ec          movw yl, tosl
001e86 9189
001e87 9199          loadtos
001e88 cd7b          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
001e89 1e8a          .dw PFA_DODO
                 PFA_DODO:
001e8a 9129          ld temp2, Y+
001e8b 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
001e8c e8e0          ldi zl, $80
001e8d 0f3e          add temp3, zl
001e8e 1b82          sub  tosl, temp2
001e8f 0b93          sbc  tosh, temp3
                 
001e90 933f          push temp3
001e91 932f          push temp2    ; limit  ( --> limit + $8000)
001e92 939f          push tosh
001e93 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
001e94 9189
001e95 9199          loadtos
001e96 cd6d          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
001e97 ff01          .dw $FF01
001e98 0069          .db "i",0
001e99 1e80          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
001e9a 1e9b          .dw PFA_I
                 PFA_I:
001e9b 939a
001e9c 938a          savetos
001e9d 918f          pop tosl
001e9e 919f          pop tosh  ; index
001e9f 91ef          pop zl
001ea0 91ff          pop zh    ; limit
001ea1 93ff          push zh
001ea2 93ef          push zl
001ea3 939f          push tosh
001ea4 938f          push tosl
001ea5 0f8e          add tosl, zl
001ea6 1f9f          adc tosh, zh
001ea7 cd5c          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
001ea8 1ea9          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
001ea9 91ef          pop zl
001eaa 91ff          pop zh
001eab 0fe8          add zl, tosl
001eac 1ff9          adc zh, tosh
001ead 9189
001eae 9199          loadtos
001eaf f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
001eb0 93ff          push zh
001eb1 93ef          push zl
001eb2 cd77          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
001eb3 910f          pop  temp0
001eb4 911f          pop  temp1  ; remove limit
001eb5 9611          adiw xl, 1  ; skip branch-back address
001eb6 cd4d          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
001eb7 1eb8          .dw PFA_DOLOOP
                 PFA_DOLOOP:
001eb8 91ef          pop zl
001eb9 91ff          pop zh
001eba 9631          adiw zl,1
001ebb f3bb          brvs PFA_DOPLUSLOOP_LEAVE
001ebc cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
001ebd ff06          .dw $ff06
001ebe 6e75
001ebf 6f6c
001ec0 706f          .db "unloop"
001ec1 1e97          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
001ec2 1ec3          .dw PFA_UNLOOP
                 PFA_UNLOOP:
001ec3 911f          pop temp1
001ec4 910f          pop temp0
001ec5 911f          pop temp1
001ec6 910f          pop temp0
001ec7 cd3c          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
001ec8 ff06          .dw $ff06
001ec9 6d63
001eca 766f
001ecb 3e65          .db "cmove>"
001ecc 1ebd          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
001ecd 1ece          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
001ece 93bf          push xh
001ecf 93af          push xl
001ed0 91e9          ld zl, Y+
001ed1 91f9          ld zh, Y+ ; addr-to
001ed2 91a9          ld xl, Y+
001ed3 91b9          ld xh, Y+ ; addr-from
001ed4 2f09          mov temp0, tosh
001ed5 2b08          or temp0, tosl
001ed6 f041          brbs 1, PFA_CMOVE_G1
001ed7 0fe8          add zl, tosl
001ed8 1ff9          adc zh, tosh
001ed9 0fa8          add xl, tosl
001eda 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
001edb 911e          ld temp1, -X
001edc 9312          st -Z, temp1
001edd 9701          sbiw tosl, 1
001ede f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
001edf 91af          pop xl
001ee0 91bf          pop xh
001ee1 9189
001ee2 9199          loadtos
001ee3 cd20          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
001ee4 ff02          .dw $ff02
001ee5 3c3e          .db "><"
001ee6 1ec8          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
001ee7 1ee8          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
001ee8 2f09          mov temp0, tosh
001ee9 2f98          mov tosh, tosl
001eea 2f80          mov tosl, temp0
001eeb cd18          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
001eec ff03          .dw $ff03
001eed 7075
001eee 0040          .db "up@",0
001eef 1ee4          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
001ef0 1ef1          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
001ef1 939a
001ef2 938a          savetos
001ef3 01c2          movw tosl, upl
001ef4 cd0f          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
001ef5 ff03          .dw $ff03
001ef6 7075
001ef7 0021          .db "up!",0
001ef8 1eec          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
001ef9 1efa          .dw PFA_UP_STORE
                 PFA_UP_STORE:
001efa 012c          movw upl, tosl
001efb 9189
001efc 9199          loadtos
001efd cd06          jmp_ DO_NEXT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
001efe ff03          .dw $ff03
001eff 6d31
001f00 0073          .db "1ms",0
001f01 1ef5          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
001f02 1f03          .dw PFA_1MS
                 PFA_1MS:
001f03 ede0
001f04 e0f7
001f05 9731
001f06 f7f1          delay 1000
001f07 ccfc          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
001f08 ff03          .dw $ff03
001f09 3e32
001f0a 0072          .db "2>r",0
001f0b 1efe          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
001f0c 1f0d          .dw PFA_2TO_R
                 PFA_2TO_R:
001f0d 01fc          movw zl, tosl
001f0e 9189
001f0f 9199          loadtos
001f10 939f          push tosh
001f11 938f          push tosl
001f12 93ff          push zh
001f13 93ef          push zl
001f14 9189
001f15 9199          loadtos
001f16 cced          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
001f17 ff03          .dw $ff03
001f18 7232
001f19 003e          .db "2r>",0
001f1a 1f08          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
001f1b 1f1c          .dw PFA_2R_FROM
                 PFA_2R_FROM:
001f1c 939a
001f1d 938a          savetos
001f1e 91ef          pop zl
001f1f 91ff          pop zh
001f20 918f          pop tosl
001f21 919f          pop tosh
001f22 939a
001f23 938a          savetos
001f24 01cf          movw tosl, zl
001f25 ccde          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
001f26 ff02          .dw $ff02
001f27 6521          .db "!e"
001f28 1f17          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
001f29 1f2a          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
001f2a 01fc          movw zl, tosl
001f2b 9189
001f2c 9199          loadtos
001f2d b72f          in_ temp2, SREG
001f2e 94f8          cli
001f2f d028          rcall PFA_FETCHE2
001f30 b500          in_  temp0, EEDR
001f31 1708          cp temp0,tosl
001f32 f009          breq PFA_STOREE3
001f33 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
001f34 9631          adiw zl,1
001f35 d022          rcall PFA_FETCHE2
001f36 b500          in_  temp0, EEDR
001f37 1709          cp temp0,tosh
001f38 f011          breq PFA_STOREE4
001f39 2f89          mov tosl, tosh
001f3a d004          rcall PFA_STOREE1
                 PFA_STOREE4:
001f3b bf2f          out_ SREG, temp2
001f3c 9189
001f3d 9199          loadtos
001f3e ccc5          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
001f3f 99f9          sbic EECR, EEPE
001f40 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
001f41 b707          in_ temp0, SPMCSR
001f42 fd00          sbrc temp0,SPMEN
001f43 cffd          rjmp PFA_STOREE2
                 
001f44 bdf2          out_ EEARH,zh
001f45 bde1          out_ EEARL,zl
001f46 bd80          out_ EEDR, tosl
001f47 9afa          sbi EECR,EEMPE
001f48 9af9          sbi EECR,EEPE
                 
001f49 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
001f4a ff02          .dw $ff02
001f4b 6540          .db "@e"
001f4c 1f26          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
001f4d 1f4e          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
001f4e b72f          in_ temp2, SREG
001f4f 94f8          cli
001f50 01fc          movw zl, tosl
001f51 d006          rcall PFA_FETCHE2
001f52 b580          in_ tosl, EEDR
                 
001f53 9631          adiw zl,1
                 
001f54 d003          rcall PFA_FETCHE2
001f55 b590          in_  tosh, EEDR
001f56 bf2f          out_ SREG, temp2
001f57 ccac          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
001f58 99f9          sbic EECR, EEPE
001f59 cffe          rjmp PFA_FETCHE2
                 
001f5a bdf2          out_ EEARH,zh
001f5b bde1          out_ EEARL,zl
                 
001f5c 9af8          sbi EECR,EERE
001f5d 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
001f5e ff02          .dw $ff02
001f5f 6921          .db "!i"
001f60 1f4a          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
001f61 0c0d          .dw PFA_DODEFER1
                 PFA_STOREI:
001f62 005e          .dw EE_STOREI
001f63 0bae          .dw XT_EDEFERFETCH
001f64 0bb8          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
001f65 ff09          .dw $ff09
001f66 2128
001f67 2d69
001f68 726e
001f69 7777
001f6a 0029          .db "(!i-nrww)",0
001f6b 1f5e          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
001f6c 1f6d          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
001f6d b71f        in temp1,SREG
001f6e 931f        push temp1
001f6f 94f8        cli
                 
001f70 019c        movw temp2, tosl ; save the (word) address
001f71 9189
001f72 9199        loadtos          ; get the new value for the flash cell
001f73 93af        push xl
001f74 93bf        push xh
001f75 93cf        push yl
001f76 93df        push yh
001f77 d009        rcall DO_STOREI_atmega
001f78 91df        pop yh
001f79 91cf        pop yl
001f7a 91bf        pop xh
001f7b 91af        pop xl
                   ; finally clear the stack
001f7c 9189
001f7d 9199        loadtos
001f7e 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
001f7f bf1f        out SREG,temp1
                 
001f80 cc83        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
001f81 d011        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
001f82 94e0        com temp4
001f83 94f0        com temp5
001f84 218e        and tosl, temp4
001f85 219f        and tosh, temp5
001f86 2b98        or tosh, tosl
001f87 f021        breq DO_STOREI_writepage 
001f88 94b3          inc erase_counter
001f89 01f9          movw zl, temp2
001f8a e002          ldi temp0,(1<<PGERS)
001f8b d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
001f8c 01f9        movw zl, temp2
001f8d e004        ldi temp0,(1<<PGWRT)
001f8e d01d        rcall dospm
                 
                   ; reenable RWW section
001f8f 01f9        movw zl, temp2
001f90 e100        ldi temp0,(1<<RWWSRE)
001f91 d01a        rcall dospm
001f92 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
001f93 01f9        movw zl, temp2
                   ; get the beginning of page
001f94 7ce0        andi zl,low(pagemask)
001f95 7fff        andi zh,high(pagemask)
001f96 01ef        movw y, z
                   ; loop counter (in words)
001f97 e4a0        ldi xl,low(pagesize)
001f98 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
001f99 01fe        movw z, y
001f9a 0fee
001f9b 1fff
001f9c 9145
001f9d 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
001f9e 01fe        movw z, y
001f9f 17e2        cp zl, temp2
001fa0 07f3        cpc zh, temp3
001fa1 f011        breq pageload_newdata
001fa2 010a          movw r0, temp6
001fa3 c002          rjmp pageload_cont
                 pageload_newdata:
001fa4 017a          movw temp4, temp6
001fa5 010c          movw r0, tosl
                 pageload_cont:
001fa6 2700        clr temp0
001fa7 d004        rcall dospm
001fa8 9621        adiw y, 1
001fa9 9711        sbiw x, 1
001faa f771        brne pageload_loop
                 
                 pageload_done:
001fab 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
001fac 99f9        sbic EECR, EEPE
001fad cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
001fae b717        in_  temp1, SPMCSR
001faf fd10        sbrc temp1, SPMEN
001fb0 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
001fb1 0fee
001fb2 1fff        writeflashcell
                   ; execute spm
001fb3 6001        ori temp0, (1<<SPMEN)
001fb4 bf07        out_ SPMCSR,temp0
001fb5 95e8        spm
001fb6 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
001fb7 ff02          .dw $ff02
001fb8 6940          .db "@i"
001fb9 1f65          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
001fba 1fbb          .dw PFA_FETCHI
                 PFA_FETCHI:
001fbb 01fc          movw zl, tosl
001fbc 0fee
001fbd 1fff
001fbe 9185
001fbf 9195          readflashcell tosl,tosh
001fc0 cc43          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .include "dict/core_2k.inc"
                 
                 .else
                 .endif
                 ; now colon words
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2LITERAL:
001fc1 0008          .dw $0008
001fc2 6c32
001fc3 7469
001fc4 7265
001fc5 6c61          .db "2literal"
001fc6 1fb7          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
001fc7 1c00          .dw DO_COLON
                 PFA_2LITERAL:
                 .endif
001fc8 1cbe          .dw XT_SWAP
001fc9 0271          .dw XT_LITERAL
001fca 0271          .dw XT_LITERAL
001fcb 1c1a          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
001fcc ff01          .dw $ff01
001fcd 003d          .db "=",0
001fce 1fc1          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
001fcf 1c00          .dw DO_COLON
                 PFA_EQUAL:
001fd0 1d8d          .dw XT_MINUS
001fd1 1d14          .dw XT_ZEROEQUAL
001fd2 1c1a          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
001fd3 ff01          .dw $ff01
001fd4 0031          .db "1",0
001fd5 1fcc          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
001fd6 1c42          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
001fd7 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
001fd8 ff01          .dw $ff01
001fd9 0032          .db "2",0
001fda 1fd3          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
001fdb 1c42          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
001fdc 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
001fdd ff02          .dw $ff02
001fde 312d          .db "-1"
001fdf 1fd8          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
001fe0 1c42          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
001fe1 ffff              .DW -1
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
00002e ff ff     
                 ; some configs
000030 79 0d     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
000032 a7 01     EE_HERE:     .dw HERESTART       ; Memory Allocation
000034 80 00     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
000036 bb 04     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
                 ; LEAVE stack is between data stack and return stack.
000038 b0 04     CFG_LP0:     .dw stackstart+1
00003a 74 0d     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
00003c 54 05     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
00003e 40 00     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
000040 dd 1f     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
000042 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000044 40 00         .dw CFG_FORTHWORDLIST      ; get/set-order
000046               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
000054 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
000056 1f 0b         .dw XT_REC_WORD
000058 0b 0b         .dw XT_REC_NUM
00005a               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_STOREI:
00005e 6c 1f         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000060 60 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000062 00 00         .dw 0  ; USER_STATE
000064 00 00         .dw 0  ; USER_FOLLOWER
000066 ff 04         .dw rstackstart  ; USER_RP
000068 af 04         .dw stackstart   ; USER_SP0
00006a af 04         .dw stackstart   ; USER_SP
                     
00006c 00 00         .dw 0  ; USER_HANDLER
00006e 0a 00         .dw 10 ; USER_BASE
                     
000070 8a 00         .dw XT_TX  ; USER_EMIT
000072 98 00         .dw XT_TXQ ; USER_EMITQ
000074 60 00         .dw XT_RX  ; USER_KEY
000076 7a 00         .dw XT_RXQ ; USER_KEYQ
000078 20 0d         .dw XT_SOURCETIB ; USER_SKEY
00007a 00 00         .dw 0            ; USER_G_IN
00007c 0d 0d         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
00007e 0c 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega169" register use summary:
r0 :  20 r1 :   5 r2 :   8 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  72 r17:  52 r18:  52 r19:  37 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 176 r25: 126 r26:  39 r27:  21 r28:   7 r29:   4 r30:  71 r31:  36 
x  :   4 y  : 191 z  :  39 
Registers used: 29 out of 35 (82.9%)

"ATmega169" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  21 add   :  16 adiw  :  18 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  10 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  10 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  10 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :   8 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  15 inc   :   3 jmp   :  19 
ld    : 129 ldd   :   4 ldi   :  25 lds   :   2 lpm   :  16 lsl   :  14 
lsr   :   1 mov   :   9 movw  :  63 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   1 out   :  17 pop   :  44 
push  :  38 rcall :  35 ret   :   6 reti  :   2 rjmp  :  90 rol   :  23 
ror   :   5 sbc   :   9 sbci  :   3 sbi   :   3 sbic  :   3 sbis  :   0 
sbiw  :   7 sbr   :   0 sbrc  :   4 sbrs  :   3 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   3 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  67 std   :   8 sts   :   3 
sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 75 out of 113 (66.4%)

"ATmega169" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x003fc4   1810   9024  10834   16384  66.1%
[.dseg] 0x000100 0x0001a7      0    167    167    1024  16.3%
[.eseg] 0x000000 0x000080      0    128    128     512  25.0%

Assembly complete, 0 errors, 5 warnings
