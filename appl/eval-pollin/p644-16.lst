
AVRASM ver. 2.1.52  p644-16.asm Sat Oct 17 14:26:18 2015

p644-16.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega644\device.asm'
../../avr8/devices/atmega644\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m644def.inc'
p644-16.asm(14): Including file '../../avr8\drivers/usart_0.asm'
../../avr8\drivers/usart_0.asm(32): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(5): Including file '../../avr8\drivers/usart-isr-rx.asm'
../../avr8\drivers/usart_common.asm(17): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(22): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(23): Including file '../../avr8\words/usart.asm'
p644-16.asm(19): Including file '../../avr8\drivers/1wire.asm'
p644-16.asm(21): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(9): Including file '../../avr8\dict/appl_8k.inc'
../../avr8\dict/appl_8k.inc(1): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/newest.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/do-create.asm'
../../avr8\dict/compiler1.inc(5): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(9): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(10): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(17): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(33): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(38): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../common\words/create.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../common\words/reveal.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(53): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../common\words/recurse.asm'
../../avr8\dict/compiler1.inc(56): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(61): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(67): Including file '../../common\words/get-order.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(70): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../common\words/dot-s.asm'
dict_appl.inc(4): Including file '../../avr8\words/spirw.asm'
dict_appl.inc(5): Including file '../../avr8\words/n-spi.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
dict_appl.inc(7): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../common\words/set-order.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../common\words/set-recognizer.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../common\words/get-recognizer.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(16): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(17): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(18): Including file '../../common\words/postpone.asm'
dict_appl.inc(8): Including file '../../avr8\words/2r_fetch.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(36): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(41): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(45): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(46): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(48): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(55): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(62): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(88): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(92): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(96): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(98): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(101): Including file '../../avr8\dict/core_8k.inc'
../../avr8\dict/core_8k.inc(2): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_8k.inc(3): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_8k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_8k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_8k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_8k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_8k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_8k.inc(10): Including file '../../avr8\words/d-equal.asm'
../../avr8\dict/core_8k.inc(11): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_8k.inc(12): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_8k.inc(14): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_8k.inc(15): Including file '../../common\words/words.asm'
../../avr8\dict/core_8k.inc(16): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(2): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(3): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(4): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(8): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/core_8k.inc(18): Including file '../../common\words/pick.asm'
../../avr8\dict/core_8k.inc(19): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_8k.inc(20): Including file '../../common\words/squote.asm'
../../avr8\dict/core_8k.inc(22): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_8k.inc(24): Including file '../../avr8\words/environment.asm'
../../avr8\dict/core_8k.inc(25): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/core_8k.inc(26): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/core_8k.inc(27): Including file '../../common\words/env-slashhold.asm'
../../avr8\dict/core_8k.inc(28): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/core_8k.inc(29): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/core_8k.inc(30): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/core_8k.inc(31): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/core_8k.inc(32): Including file '../../common\words/env-usersize.asm'
../../avr8\dict/core_8k.inc(34): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_8k.inc(35): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_8k.inc(36): Including file '../../common\words/base.asm'
../../avr8\dict/core_8k.inc(38): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_8k.inc(39): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_8k.inc(41): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_8k.inc(42): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_8k.inc(44): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_8k.inc(46): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_8k.inc(47): Including file '../../common\words/pad.asm'
../../avr8\dict/core_8k.inc(48): Including file '../../common\words/emit.asm'
../../avr8\dict/core_8k.inc(49): Including file '../../common\words/emitq.asm'
../../avr8\dict/core_8k.inc(50): Including file '../../common\words/key.asm'
../../avr8\dict/core_8k.inc(51): Including file '../../common\words/keyq.asm'
../../avr8\dict/core_8k.inc(53): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_8k.inc(54): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_8k.inc(55): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_8k.inc(56): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_8k.inc(58): Including file '../../common\words/bin.asm'
../../avr8\dict/core_8k.inc(59): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_8k.inc(60): Including file '../../common\words/hex.asm'
../../avr8\dict/core_8k.inc(61): Including file '../../common\words/bl.asm'
../../avr8\dict/core_8k.inc(63): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_8k.inc(65): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_8k.inc(66): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_8k.inc(67): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_8k.inc(68): Including file '../../common\words/slash.asm'
../../avr8\dict/core_8k.inc(69): Including file '../../common\words/mod.asm'
../../avr8\dict/core_8k.inc(70): Including file '../../avr8\words/abs.asm'
../../avr8\dict/core_8k.inc(71): Including file '../../common\words/min.asm'
../../avr8\dict/core_8k.inc(72): Including file '../../common\words/max.asm'
../../avr8\dict/core_8k.inc(73): Including file '../../common\words/within.asm'
../../avr8\dict/core_8k.inc(75): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_8k.inc(76): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_8k.inc(78): Including file '../../avr8\words/hld.asm'
../../avr8\dict/core_8k.inc(79): Including file '../../common\words/hold.asm'
../../avr8\dict/core_8k.inc(80): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/core_8k.inc(81): Including file '../../common\words/sharp.asm'
../../avr8\dict/core_8k.inc(82): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/core_8k.inc(83): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/core_8k.inc(84): Including file '../../common\words/sign.asm'
../../avr8\dict/core_8k.inc(85): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/core_8k.inc(86): Including file '../../common\words/dot-r.asm'
../../avr8\dict/core_8k.inc(87): Including file '../../common\words/d-dot.asm'
../../avr8\dict/core_8k.inc(88): Including file '../../common\words/dot.asm'
../../avr8\dict/core_8k.inc(89): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/core_8k.inc(90): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/core_8k.inc(91): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/core_8k.inc(92): Including file '../../common\words/digit-q.asm'
../../avr8\dict/core_8k.inc(94): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/core_8k.inc(95): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/core_8k.inc(96): Including file '../../avr8\words/itype.asm'
../../avr8\dict/core_8k.inc(97): Including file '../../avr8\words/icount.asm'
../../avr8\dict/core_8k.inc(98): Including file '../../common\words/cr.asm'
../../avr8\dict/core_8k.inc(99): Including file '../../common\words/space.asm'
../../avr8\dict/core_8k.inc(100): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_8k.inc(101): Including file '../../common\words/type.asm'
../../avr8\dict/core_8k.inc(102): Including file '../../common\words/tick.asm'
../../avr8\dict/core_8k.inc(104): Including file '../../common\words/handler.asm'
../../avr8\dict/core_8k.inc(105): Including file '../../common\words/catch.asm'
../../avr8\dict/core_8k.inc(106): Including file '../../common\words/throw.asm'
../../avr8\dict/core_8k.inc(108): Including file '../../common\words/cskip.asm'
../../avr8\dict/core_8k.inc(109): Including file '../../common\words/cscan.asm'
../../avr8\dict/core_8k.inc(110): Including file '../../common\words/accept.asm'
../../avr8\dict/core_8k.inc(111): Including file '../../common\words/refill.asm'
../../avr8\dict/core_8k.inc(112): Including file '../../common\words/char.asm'
../../avr8\dict/core_8k.inc(113): Including file '../../common\words/number.asm'
../../avr8\dict/core_8k.inc(114): Including file '../../common\words/q-sign.asm'
../../avr8\dict/core_8k.inc(115): Including file '../../common\words/set-base.asm'
../../avr8\dict/core_8k.inc(116): Including file '../../common\words/to-number.asm'
../../avr8\dict/core_8k.inc(117): Including file '../../common\words/parse.asm'
../../avr8\dict/core_8k.inc(118): Including file '../../common\words/source.asm'
../../avr8\dict/core_8k.inc(119): Including file '../../common\words/slash-string.asm'
../../avr8\dict/core_8k.inc(120): Including file '../../common\words/parse-name.asm'
../../avr8\dict/core_8k.inc(121): Including file '../../common\words/find-name.asm'
../../avr8\dict/core_8k.inc(123): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_8k.inc(124): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_8k.inc(125): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_8k.inc(127): Including file '../../common\words/quit.asm'
../../avr8\dict/core_8k.inc(128): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_8k.inc(129): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_8k.inc(130): Including file '../../common\words/warm.asm'
../../avr8\dict/core_8k.inc(132): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/core_8k.inc(133): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/core_8k.inc(134): Including file '../../common\words/depth.asm'
../../avr8\dict/core_8k.inc(135): Including file '../../common\words/interpret.asm'
../../avr8\dict/core_8k.inc(136): Including file '../../common\words/do-recognizer.asm'
../../avr8\dict/core_8k.inc(137): Including file '../../common\words/r-intnumber.asm'
../../avr8\dict/core_8k.inc(138): Including file '../../common\words/r-word.asm'
../../avr8\dict/core_8k.inc(139): Including file '../../common\words/r-fail.asm'
../../avr8\dict/core_8k.inc(141): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_8k.inc(142): Including file '../../common\words/ver.asm'
../../avr8\dict/core_8k.inc(144): Including file '../../common\words/noop.asm'
../../avr8\dict/core_8k.inc(145): Including file '../../avr8\words/unused.asm'
../../avr8\dict/core_8k.inc(147): Including file '../../common\words/to.asm'
../../avr8\dict/core_8k.inc(148): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/core_8k.inc(150): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_8k.inc(151): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_8k.inc(152): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_8k.inc(153): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_8k.inc(154): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_8k.inc(155): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_8k.inc(156): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_8k.inc(157): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_8k.inc(158): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_8k.inc(160): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/core_8k.inc(161): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/core_8k.inc(162): Including file '../../common\words/name2string.asm'
../../avr8\dict/core_8k.inc(163): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/core_8k.inc(164): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/core_8k.inc(166): Including file '../../common\words/star.asm'
../../avr8\dict/core_8k.inc(167): Including file '../../avr8\words/j.asm'
../../avr8\dict/core_8k.inc(169): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/core_8k.inc(170): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/core_8k.inc(171): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/core_8k.inc(172): Including file '../../common\words/2swap.asm'
../../avr8\dict/core_8k.inc(174): Including file '../../common\words/tib.asm'
../../avr8\dict/core_8k.inc(176): Including file '../../avr8\words/init-ram.asm'
../../avr8\dict/core_8k.inc(177): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/core_8k.inc(178): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_8k.inc(179): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_8k.inc(180): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/nrww.inc(111): Including file '../../common\words/2literal.asm'
../../avr8\dict/nrww.inc(112): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(113): Including file '../../common\words/num-constants.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot      = r10
                   .def erase_counter = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_JTAG = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TWI = 0
                 .set WANT_SPI = 0
                 .set WANT_CPU = 0
                 .equ intvecsize = 2 ; please verify; flash size: 65536 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d118      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d116      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d114      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d112      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d110      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d10e      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 14
00000e d10c      	 rcall isr ; Pin Change Interrupt Request 3
                 .org 16
000010 d10a      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 18
000012 d108      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 20
000014 d106      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 22
000016 d104      	 rcall isr ; Timer/Counter2 Overflow
                 .org 24
000018 d102      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 26
00001a d100      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 28
00001c d0fe      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 30
00001e d0fc      	 rcall isr ; Timer/Counter1 Overflow
                 .org 32
000020 d0fa      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 34
000022 d0f8      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 36
000024 d0f6      	 rcall isr ; Timer/Counter0 Overflow
                 .org 38
000026 d0f4      	 rcall isr ; SPI Serial Transfer Complete
                 .org 40
000028 d0f2      	 rcall isr ; USART0, Rx Complete
                 .org 42
00002a d0f0      	 rcall isr ; USART0 Data register Empty
                 .org 44
00002c d0ee      	 rcall isr ; USART0, Tx Complete
                 .org 46
00002e d0ec      	 rcall isr ; Analog Comparator
                 .org 48
000030 d0ea      	 rcall isr ; ADC Conversion Complete
                 .org 50
000032 d0e8      	 rcall isr ; EEPROM Ready
                 .org 52
000034 d0e6      	 rcall isr ; 2-wire Serial Interface
                 .org 54
000036 d0e4      	 rcall isr ; Store Program Memory Read
                 .equ INTVECTORS = 28
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000037 1000      	.dw 4096
                 mcu_eepromsize:
000038 0800      	.dw 2048
                 mcu_maxdp:
000039 e000      	.dw 57344 
                 mcu_numints:
00003a 001c      	.dw 28
                 mcu_name:
00003b 0009      	.dw  9
00003c 5441
00003d 656d
00003e 6167
00003f 3436
000040 0034      	.db "ATmega644",0
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; receiving is asynchron, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR+1
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 .set BAUD_MAXERROR = 30
                 .equ TIMER_INT = OVF2addr
                 
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100           usart_rx_data: .byte usart_rx_size+2
000112           usart_rx_in: .byte 2
000114           usart_rx_out: .byte 2
                 
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
000041 93af        push xl
000042 b7af        in xl, SREG
000043 93af        push xl
000044 93bf        push xh
000045 93ef        push zl
000046 93ff        push zh
                 
000047 91b0 00c6   lds xh, USART_DATA
                 usart_rx_store:
000049 91a0 0112   lds xl, usart_rx_in
00004b e0e0        ldi zl, low(usart_rx_data)
00004c e0f1        ldi zh, high(usart_rx_data)
00004d 0fea        add zl, xl
00004e 1df3        adc zh, zeroh
00004f 83b0        st Z, xh
                 
000050 95a3        inc xl
000051 70af        andi xl,usart_rx_mask
                 
000052 93a0 0112   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
000054 91ff        pop zh
000055 91ef        pop zl
000056 91bf        pop xh
000057 91af        pop xl
000058 bfaf        out SREG, xl
000059 91af        pop xl
00005a 9518        reti
                 
                 .set usartpc = pc
                 .org URXCaddr
000028 c018        jmp_ usart_rx_isr
                 .org usartpc
                 
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
00005b 7001        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
00005c 714f        .dw XT_ZERO
00005d 7038        .dw XT_DOLITERAL
00005e 0112        .dw usart_rx_in
00005f 7088        .dw XT_CSTORE
000060 714f        .dw XT_ZERO
000061 7038        .dw XT_DOLITERAL
000062 0114        .dw usart_rx_out
000063 7088        .dw XT_CSTORE
                 
000064 701b        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
000065 ff06          .dw $ff06
000066 7872
000067 692d
000068 7273          .db "rx-isr"
000069 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
00006a 7001          .dw DO_COLON
                 PFA_RX_ISR:
00006b 0084        .dw XT_RXQ_ISR
00006c 7031        .dw XT_DOCONDBRANCH
00006d 006b        .dw PFA_RX_ISR
00006e 7038        .dw XT_DOLITERAL
00006f 0114        .dw usart_rx_out
000070 7093        .dw XT_CFETCH
000071 70ac        .dw XT_DUP
000072 722a        .dw XT_1PLUS
000073 7038        .dw XT_DOLITERAL
000074 000f        .dw usart_rx_mask
000075 720e        .dw XT_AND
000076 7038        .dw XT_DOLITERAL
000077 0114        .dw usart_rx_out
000078 7088        .dw XT_CSTORE
000079 7038        .dw XT_DOLITERAL
00007a 0100        .dw usart_rx_data
00007b 7198        .dw XT_PLUS
00007c 7093        .dw XT_CFETCH
00007d 701b        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
00007e ff07          .dw $ff07
00007f 7872
000080 2d3f
000081 7369
000082 0072          .db "rx?-isr",0
000083 0065          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
000084 7001          .dw DO_COLON
                 PFA_RXQ_ISR:
000085 7a35        .dw XT_PAUSE
000086 7038        .dw XT_DOLITERAL
000087 0114        .dw usart_rx_out
000088 7093        .dw XT_CFETCH
000089 7038        .dw XT_DOLITERAL
00008a 0112        .dw usart_rx_in
00008b 7093        .dw XT_CFETCH
00008c 710e        .dw XT_NOTEQUAL
00008d 701b        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
00008e ff07          .dw $ff07
00008f 7874
000090 702d
000091 6c6f
000092 006c          .db "tx-poll",0
000093 007e          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
000094 7001          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
000095 00a2        .dw XT_TXQ_POLL
000096 7031        .dw XT_DOCONDBRANCH
000097 0095        .dw PFA_TX_POLL
                   ; send to usart
000098 7038        .dw XT_DOLITERAL
000099 00c6        .dw USART_DATA
00009a 7088        .dw XT_CSTORE
00009b 701b        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
00009c ff08          .dw $ff08
00009d 7874
00009e 2d3f
00009f 6f70
0000a0 6c6c          .db "tx?-poll"
0000a1 008e          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000a2 7001          .dw DO_COLON
                 PFA_TXQ_POLL:
0000a3 7a35        .dw XT_PAUSE
0000a4 7038        .dw XT_DOLITERAL
0000a5 00c0        .dw USART_A
0000a6 7093        .dw XT_CFETCH
0000a7 7038        .dw XT_DOLITERAL
0000a8 0020        .dw bm_USART_TXRD
0000a9 720e        .dw XT_AND
0000aa 701b        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000ab ff04        .dw $ff04
0000ac 6275
0000ad 7272        .db "ubrr"
0000ae 009c        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000af 706a        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000b0 0088        .dw EE_UBRRVAL
0000b1 7b89        .dw XT_EDEFERFETCH
0000b2 7b93        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000b3 ff06        .dw $ff06
0000b4 752b
0000b5 6173
0000b6 7472        .db "+usart"
0000b7 00ab        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000b8 7001        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000b9 7038        .dw XT_DOLITERAL
0000ba 0098        .dw USART_B_VALUE
0000bb 7038        .dw XT_DOLITERAL
0000bc 00c1        .dw USART_B
0000bd 7088        .dw XT_CSTORE
                 
0000be 7038        .dw XT_DOLITERAL
0000bf 0006        .dw USART_C_VALUE
0000c0 7038        .dw XT_DOLITERAL
0000c1 00c2        .dw USART_C | bm_USARTC_en
0000c2 7088        .dw XT_CSTORE
                 
0000c3 00af        .dw XT_UBRR
0000c4 70ac        .dw XT_DUP
0000c5 72e8        .dw XT_BYTESWAP
0000c6 7038        .dw XT_DOLITERAL
0000c7 00c5        .dw BAUDRATE_HIGH
0000c8 7088        .dw XT_CSTORE
0000c9 7038        .dw XT_DOLITERAL
0000ca 00c4        .dw BAUDRATE_LOW
0000cb 7088        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000cc 005b        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000cd 701b        .dw XT_EXIT
                 
                 ; settings for 1wire interface
                 .equ OW_PORT=PORTB
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
0000ce ff08          .dw $ff08
0000cf 7731
0000d0 722e
0000d1 7365
0000d2 7465          .db "1w.reset"
0000d3 00b3          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
0000d4 00d5          .dw PFA_OW_RESET
                 PFA_OW_RESET:
0000d5 939a
0000d6 938a          savetos
0000d7 2799          clr tosh
                     ; setup to output
0000d8 9a24          sbi OW_DDR, OW_BIT
                     ; Pull output low
0000d9 982c          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
0000da e8e0
0000db e0f7
0000dc 9731
0000dd f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
0000de b71f          in temp1, SREG
0000df 94f8          cli
                     ; Pull output high
0000e0 9a2c          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
0000e1 9824          cbi OW_DDR, OW_BIT 
0000e2 e0e0
0000e3 e0f1
0000e4 9731
0000e5 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
0000e6 b183          in tosl, OW_PIN
0000e7 ff84          sbrs tosl, OW_BIT
0000e8 ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
0000e9 bf1f          out SREG, temp1
                     ; release bus
0000ea 9824          cbi OW_DDR, OW_BIT
0000eb 982c          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
0000ec e8e0
0000ed e0f6
0000ee 9731
0000ef f7f1          DELAY   416
                     ; we now have the result flag in TOS        
0000f0 2f89          mov tosl, tosh
0000f1 940c 7005     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
0000f3 ff07          .dw $ff07
0000f4 7731
0000f5 732e
0000f6 6f6c
0000f7 0074          .db "1w.slot",0
0000f8 00ce          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
0000f9 00fa          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
0000fa 9a24          sbi OW_DDR, OW_BIT
0000fb 982c          cbi OW_PORT, OW_BIT
                     ; disable interrupts
0000fc b71f          in temp1, SREG
0000fd 94f8          cli
0000fe e1e8
0000ff e0f0
000100 9731
000101 f7f1          DELAY   6 ; DELAY A
                     ; check bit
000102 9488          clc
000103 9587          ror tosl
000104 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
000105 9824            cbi OW_DDR, OW_BIT
000106 9a2c            sbi OW_PORT, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
000107 e2e4
000108 e0f0
000109 9731
00010a f7f1          DELAY 9   ; wait DELAY E to sample
00010b b103          in temp0, OW_PIN
00010c fd04          sbrc temp0, OW_BIT
00010d 6880          ori tosl, $80
                 
00010e ecec
00010f e0f0
000110 9731
000111 f7f1          DELAY   51 ; DELAY B
000112 9824          cbi OW_DDR, OW_BIT
000113 9a2c          sbi OW_PORT, OW_BIT ; release bus
000114 e0e8
000115 e0f0
000116 9731
000117 f7f1          delay 2
                     ; re-enable interrupts
000118 bf1f          out SREG, temp1
000119 940c 7005     jmp_ DO_NEXT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c 7a3e   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000116           intcur: .byte 1
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
00011b 920a          st -Y, r0
00011c b60f          in r0, SREG
00011d 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
00011e 900f          pop r0
00011f 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
000120 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
000121 9200 0116     sts intcur, r0
000123 9009          ld r0, Y+
000124 be0f          out SREG, r0
000125 9009          ld r0, Y+
000126 9468          set ; set the interrupt flag for the inner interpreter
000127 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000128 ff02          .dw $ff02
000129 2b6d          .db "m+"
00012a 00f3          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
00012b 7001          .dw DO_COLON
                 PFA_MPLUS:
00012c 7d3d          .dw XT_S2D
00012d 7405          .dw XT_DPLUS
00012e 701b          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
00012f ff03          .dw $ff03
000130 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
000131 002a          .db "ud*"
000132 0128          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
000133 7001          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000134 70ac
000135 70fa
000136 71db
000137 70d4              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000138 70bf
000139 70f1
00013a 71db
00013b 70dc
00013c 7198
00013d 701b              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00013e ff04          .dw $ff04
00013f 6d75
000140 7861          .db "umax"
000141 012f          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
000142 7001          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
000143 7565
000144 7157              .DW XT_2DUP,XT_ULESS
000145 7031      	.dw XT_DOCONDBRANCH
000146 0148      	 DEST(UMAX1)
000147 70bf              .DW XT_SWAP
000148 70d4      UMAX1:  .DW XT_DROP
000149 701b      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
00014a ff04          .dw $ff04
00014b 6d75
00014c 6e69          .db "umin"
00014d 013e          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00014e 7001          .dw DO_COLON
                 PFA_UMIN:
                 .endif
00014f 7565
000150 7162              .DW XT_2DUP,XT_UGREATER
000151 7031      	.dw XT_DOCONDBRANCH
000152 0154      	DEST(UMIN1)
000153 70bf              .DW XT_SWAP
000154 70d4      UMIN1:  .DW XT_DROP
000155 701b      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000156 7001          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000157 7038          .dw XT_DOLITERAL
000158 8000          .dw $8000
000159 720e          .dw XT_AND
00015a 7115          .dw XT_ZEROEQUAL
00015b 7031          .dw XT_DOCONDBRANCH
00015c 0160          DEST(IMMEDIATEQ1)
00015d 7038           .dw XT_DOLITERAL
00015e 0001           .dw 1
00015f 701b           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
000160 7146          .dw XT_TRUE
000161 701b          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
000162 ff0a          .dw $ff0a
000163 616e
000164 656d
000165 663e
000166 616c
000167 7367          .db "name>flags"
000168 014a          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000169 7001          .dw DO_COLON
                 PFA_NAME2FLAGS:
00016a 73bb          .dw XT_FETCHI ; skip to link field
00016b 7038          .dw XT_DOLITERAL
00016c ff00          .dw $ff00
00016d 720e          .dw XT_AND
00016e 701b          .dw XT_EXIT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .include "dict/appl_8k.inc"
                 
                 
                 .include "words/newest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_NEWEST:
00016f ff06          .dw $ff06
000170 656e
000171 6577
000172 7473          .db "newest"
000173 0162          .dw VE_HEAD
                     .set VE_HEAD = VE_NEWEST
                 XT_NEWEST:
000174 7043          .dw PFA_DOVARIABLE
                 PFA_NEWEST:
000175 0117          .dw ram_newest
                 
                 .dseg
000117           ram_newest: .byte 4
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_LATEST:
000176 ff06          .dw $ff06
000177 616c
000178 6574
000179 7473          .db "latest"
00017a 016f          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
00017b 7043          .dw PFA_DOVARIABLE
                 PFA_LATEST:
00017c 011b          .dw ram_latest
                 
                 .dseg
00011b           ram_latest: .byte 2
                 .include "words/do-create.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE:
00017d ff08          .dw $ff08
00017e 6328
00017f 6572
000180 7461
000181 2965          .db "(create)"
000182 0176          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000183 7001          .dw DO_COLON
                 PFA_DOCREATE:
                 .endif
000184 79b0
000185 02da          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
000186 70ac
000187 0174
000188 755e
000189 707c          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
00018a 02bf
00018b 0174
00018c 707c          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
00018d 701b          .DW XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
00018e 0001          .dw $0001
00018f 005c          .db $5c,0
000190 017d          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
000191 7001          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
000192 7997          .dw XT_SOURCE
000193 70eb          .dw XT_NIP
000194 757e          .dw XT_TO_IN
000195 707c          .dw XT_STORE
000196 701b          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
000197 0001          .dw $0001
000198 0028          .db "(" ,0
000199 018e          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
00019a 7001          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
00019b 7038          .dw XT_DOLITERAL
00019c 0029          .dw ')'
00019d 7983          .dw XT_PARSE
00019e 756e          .dw XT_2DROP
00019f 701b          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
0001a0 ff07          .dw $ff07
0001a1 6f63
0001a2 706d
0001a3 6c69
0001a4 0065          .db "compile",0
0001a5 0197          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001a6 7001          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
0001a7 70f1          .dw XT_R_FROM
0001a8 70ac          .dw XT_DUP
0001a9 7b80          .dw XT_ICELLPLUS
0001aa 70fa          .dw XT_TO_R
0001ab 73bb          .dw XT_FETCHI
0001ac 01b1          .dw XT_COMMA
0001ad 701b          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001ae ff01          .dw $ff01
0001af 002c          .db ',',0 ; ,
0001b0 01a0          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001b1 7001          .dw DO_COLON
                 PFA_COMMA:
0001b2 75ae          .dw XT_DP
0001b3 7362          .dw XT_STOREI
0001b4 75ae          .dw XT_DP
0001b5 722a          .dw XT_1PLUS
0001b6 7b6e          .dw XT_DOTO
0001b7 75af          .dw PFA_DP
0001b8 701b          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
0001b9 0003          .dw $0003
0001ba 275b
0001bb 005d          .db "[']",0
0001bc 01ae          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001bd 7001          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
0001be 780d          .dw XT_TICK
0001bf 01c7          .dw XT_LITERAL
0001c0 701b          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
0001c1 0007          .dw $0007
0001c2 696c
0001c3 6574
0001c4 6172
0001c5 006c          .db "literal",0
0001c6 01b9          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
0001c7 7001          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
0001c8 01a6              .DW XT_COMPILE
0001c9 7038              .DW XT_DOLITERAL
0001ca 01b1              .DW XT_COMMA
0001cb 701b              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
0001cc 0008        .dw $0008
0001cd 6c73
0001ce 7469
0001cf 7265
0001d0 6c61        .db "sliteral"
0001d1 01c1        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
0001d2 7001          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
0001d3 01a6          .dw XT_COMPILE
0001d4 7770          .dw XT_DOSLITERAL    ; ( -- addr n)
0001d5 777e          .dw XT_SCOMMA
0001d6 701b          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
0001d7 7001          .dw DO_COLON
                 PFA_GMARK:
0001d8 75ae          .dw XT_DP
0001d9 01a6          .dw XT_COMPILE
0001da ffff          .dw -1           ; ffff does not erase flash
0001db 701b          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
0001dc 7001          .dw DO_COLON
                 PFA_GRESOLVE:
0001dd 7b2c          .dw XT_QSTACK
0001de 75ae          .dw XT_DP
0001df 70bf          .dw XT_SWAP
0001e0 7362          .dw XT_STOREI
0001e1 701b          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
0001e2 7001          .dw DO_COLON
                 PFA_LMARK:
0001e3 75ae          .dw XT_DP
0001e4 701b          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
0001e5 7001          .dw DO_COLON
                 PFA_LRESOLVE:
0001e6 7b2c          .dw XT_QSTACK
0001e7 01b1          .dw XT_COMMA
0001e8 701b          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
0001e9 0005          .dw $0005
0001ea 6861
0001eb 6165
0001ec 0064          .db "ahead",0
0001ed 01cc          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
0001ee 7001          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
0001ef 01a6          .dw XT_COMPILE
0001f0 702a          .dw XT_DOBRANCH
0001f1 01d7          .dw XT_GMARK
0001f2 701b          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
0001f3 0002          .dw $0002
0001f4 6669          .db "if"
0001f5 01e9          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
0001f6 7001          .dw DO_COLON
                 PFA_IF:
                 .endif
0001f7 01a6          .dw XT_COMPILE
0001f8 7031          .dw XT_DOCONDBRANCH
0001f9 01d7          .dw XT_GMARK
0001fa 701b          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
0001fb 0004          .dw $0004
0001fc 6c65
0001fd 6573          .db "else"
0001fe 01f3          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
0001ff 7001          .dw DO_COLON
                 PFA_ELSE:
                 .endif
000200 01a6          .dw XT_COMPILE
000201 702a          .dw XT_DOBRANCH
000202 01d7          .dw XT_GMARK
000203 70bf          .dw XT_SWAP
000204 01dc          .dw XT_GRESOLVE
000205 701b          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
000206 0004          .dw $0004
000207 6874
000208 6e65          .db "then"
000209 01fb          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
00020a 7001          .dw DO_COLON
                 PFA_THEN:
                 .endif
00020b 01dc          .dw XT_GRESOLVE
00020c 701b          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
00020d 0005          .dw $0005
00020e 6562
00020f 6967
000210 006e          .db "begin",0
000211 0206          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000212 7001          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
000213 01e2          .dw XT_LMARK
000214 701b          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
000215 0005          .dw $0005
000216 6877
000217 6c69
000218 0065          .db "while",0
000219 020d          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
00021a 7001          .dw DO_COLON
                 PFA_WHILE:
                 .endif
00021b 01f6          .dw XT_IF
00021c 70bf          .dw XT_SWAP
00021d 701b          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
00021e 0006          .dw $0006
00021f 6572
000220 6570
000221 7461          .db "repeat"
000222 0215          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000223 7001          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
000224 0237          .dw XT_AGAIN
000225 020a          .dw XT_THEN
000226 701b          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
000227 0005          .dw $0005
000228 6e75
000229 6974
00022a 006c          .db "until",0
00022b 021e          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
00022c 7001          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
00022d 7038          .dw XT_DOLITERAL
00022e 7031          .dw XT_DOCONDBRANCH
00022f 01b1          .dw XT_COMMA
                 
000230 01e5          .dw XT_LRESOLVE
000231 701b          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
000232 0005          .dw $0005
000233 6761
000234 6961
000235 006e          .db "again",0
000236 0227          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000237 7001          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
000238 01a6          .dw XT_COMPILE
000239 702a          .dw XT_DOBRANCH
00023a 01e5          .dw XT_LRESOLVE
00023b 701b          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
00023c 0002          .dw $0002
00023d 6f64          .db "do"
00023e 0232          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
00023f 7001          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000240 01a6          .dw XT_COMPILE
000241 728a          .dw XT_DODO
000242 01e2          .dw XT_LMARK
000243 714f          .dw XT_ZERO
000244 029a          .dw XT_TO_L
000245 701b          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
000246 0004          .dw $0004
000247 6f6c
000248 706f          .db "loop"
000249 023c          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
00024a 7001          .dw DO_COLON
                 PFA_LOOP:
                 .endif
00024b 01a6          .dw XT_COMPILE
00024c 72b8          .dw XT_DOLOOP
00024d 0281          .dw XT_ENDLOOP
00024e 701b          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
00024f 0005          .dw $0005
000250 6c2b
000251 6f6f
000252 0070          .db "+loop",0
000253 0246          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000254 7001          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
000255 01a6          .dw XT_COMPILE
000256 72a9          .dw XT_DOPLUSLOOP
000257 0281          .dw XT_ENDLOOP
000258 701b          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
000259 0005         .dw $0005
00025a 656c
00025b 7661
00025c 0065         .db "leave",0
00025d 024f         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
00025e 7001          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
00025f 01a6
000260 72c3          .DW XT_COMPILE,XT_UNLOOP
000261 01ee
000262 029a
000263 701b          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
000264 0003          .dw $0003
000265 643f
000266 006f          .db "?do",0
000267 0259          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
000268 7001          .dw DO_COLON
                 PFA_QDO:
                 .endif
000269 01a6          .dw XT_COMPILE
00026a 0270          .dw XT_QDOCHECK
00026b 01f6          .dw XT_IF
00026c 023f          .dw XT_DO
00026d 70bf          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
00026e 029a          .dw XT_TO_L    ; then follows at the end.
00026f 701b          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
000270 7001          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
000271 7565          .dw XT_2DUP
000272 7d55          .dw XT_EQUAL
000273 70ac          .dw XT_DUP
000274 70fa          .dw XT_TO_R
000275 7031          .dw XT_DOCONDBRANCH
000276 0278          DEST(PFA_QDOCHECK1)
000277 756e          .dw XT_2DROP
                 PFA_QDOCHECK1:
000278 70f1          .dw XT_R_FROM
000279 71f8          .dw XT_INVERT
00027a 701b          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
00027b ff07          .dw $ff07
00027c 6e65
00027d 6c64
00027e 6f6f
00027f 0070          .db "endloop",0
000280 0264          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
000281 7001          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
000282 01e5              .DW XT_LRESOLVE
000283 028e
000284 70b4
000285 7031      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
000286 028a               DEST(LOOP2)
000287 020a              .DW XT_THEN
000288 702a      	.dw XT_DOBRANCH
000289 0283               DEST(LOOP1)
00028a 701b      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
00028b ff02          .dw $ff02
00028c 3e6c          .db "l>"
00028d 027b          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
00028e 7001          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
00028f 02ad          .dw XT_LP
000290 7074          .dw XT_FETCH
000291 7074          .dw XT_FETCH
000292 7038          .dw XT_DOLITERAL
000293 fffe          .dw -2
000294 02ad          .dw XT_LP
000295 7254          .dw XT_PLUSSTORE
000296 701b          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
000297 ff02          .dw $ff02
000298 6c3e          .db ">l"
000299 028b          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
00029a 7001          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
00029b 7d61              .dw XT_TWO
00029c 02ad      	.dw XT_LP
00029d 7254      	.dw XT_PLUSSTORE
00029e 02ad      	.dw XT_LP
00029f 7074      	.dw XT_FETCH
0002a0 707c      	.dw XT_STORE
0002a1 701b      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
0002a2 ff03          .dw $ff03
0002a3 706c
0002a4 0030          .db "lp0",0
0002a5 0297          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
0002a6 706a          .dw PFA_DOVALUE1
                 PFA_LP0:
0002a7 0042          .dw CFG_LP0
0002a8 7b89          .dw XT_EDEFERFETCH
0002a9 7b93          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
0002aa ff02          .dw $ff02
0002ab 706c          .db "lp"
0002ac 02a2          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
0002ad 7043          .dw PFA_DOVARIABLE
                 PFA_LP:
0002ae 011d          .dw ram_lp
                 
                 .dseg
00011d           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CREATE:
0002af ff06          .dw $ff06
0002b0 7263
0002b1 6165
0002b2 6574          .db "create"
0002b3 02aa          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0002b4 7001          .dw DO_COLON
                 PFA_CREATE:
                 .endif
0002b5 0183          .dw XT_DOCREATE
0002b6 02e3          .dw XT_REVEAL
0002b7 01a6          .dw XT_COMPILE
0002b8 704d          .dw PFA_DOCONSTANT
0002b9 701b          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0002ba ff06          .dw $ff06
0002bb 6568
0002bc 6461
0002bd 7265          .db "header"
0002be 02af          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0002bf 7001          .dw DO_COLON
                 PFA_HEADER:
0002c0 75ae          .dw XT_DP           ; the new Name Field
0002c1 70fa          .dw XT_TO_R
0002c2 70fa          .dw XT_TO_R		; ( R: NFA WID )
0002c3 70ac          .dw XT_DUP    
0002c4 7123          .dw XT_GREATERZERO 
0002c5 7031          .dw XT_DOCONDBRANCH
0002c6 02d1          .dw PFA_HEADER1
0002c7 70ac          .dw XT_DUP
0002c8 7038          .dw XT_DOLITERAL
0002c9 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0002ca 7217          .dw XT_OR
0002cb 7782          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0002cc 70f1          .dw XT_R_FROM
0002cd 734e          .dw XT_FETCHE
0002ce 01b1          .dw XT_COMMA
0002cf 70f1          .dw XT_R_FROM
0002d0 701b          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0002d1 7038          .dw XT_DOLITERAL
0002d2 fff0          .dw -16
0002d3 783c          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0002d4 ff07          .dw $ff07
0002d5 6c77
0002d6 6373
0002d7 706f
0002d8 0065          .db "wlscope",0
0002d9 02ba          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0002da 7be8          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
0002db 0040          .dw CFG_WLSCOPE
0002dc 7b89          .dw XT_EDEFERFETCH
0002dd 7b93          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REVEAL:
0002de ff06          .dw $ff06
0002df 6572
0002e0 6576
0002e1 6c61          .db "reveal"
0002e2 02d4          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
0002e3 7001          .dw DO_COLON
                 PFA_REVEAL:
                 .endif
0002e4 0174
0002e5 755e
0002e6 7074          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
0002e7 70b4
0002e8 7031          .DW XT_QDUP,XT_DOCONDBRANCH
0002e9 02ee          DEST(REVEAL1)
0002ea 0174
0002eb 7074
0002ec 70bf
0002ed 732a          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                 REVEAL1:
0002ee 701b          .DW XT_EXIT
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
0002ef 0005          .dw $0005
0002f0 6f64
0002f1 7365
0002f2 003e          .db "does>",0
0002f3 02de          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
0002f4 7001          .dw DO_COLON
                 PFA_DOES:
0002f5 01a6          .dw XT_COMPILE
0002f6 0307          .dw XT_DODOES
0002f7 01a6          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
0002f8 940e          .dw $940e       ; the address of this compiled
0002f9 01a6          .dw XT_COMPILE  ; code will replace the XT of the 
0002fa 02fc          .dw DO_DODOES   ; word that CREATE created
0002fb 701b          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
0002fc 939a
0002fd 938a          savetos
0002fe 01cb          movw tosl, wl
0002ff 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000300 917f          pop wh
000301 916f          pop wl
                 
000302 93bf          push XH
000303 93af          push XL
000304 01db          movw XL, wl
000305 940c 7005     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000307 7001          .dw DO_COLON
                 PFA_DODOES:
000308 70f1          .dw XT_R_FROM
000309 0174          .dw XT_NEWEST
00030a 755e          .dw XT_CELLPLUS
00030b 7074          .dw XT_FETCH
00030c 734e          .dw XT_FETCHE
00030d 7c53          .dw XT_NFA2CFA
00030e 7362          .dw XT_STOREI
00030f 701b          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
000310 ff01          .dw $ff01
000311 003a          .db ":",0
000312 02ef          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000313 7001          .dw DO_COLON
                 PFA_COLON:
                 .endif
000314 0183          .dw XT_DOCREATE
000315 031e          .dw XT_COLONNONAME
000316 70d4          .dw XT_DROP
000317 701b          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000318 ff07          .dw $ff07
000319 6e3a
00031a 6e6f
00031b 6d61
00031c 0065          .db ":noname",0
00031d 0310          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
00031e 7001          .dw DO_COLON
                 PFA_COLONNONAME:
00031f 75ae          .dw XT_DP
000320 70ac          .dw XT_DUP
000321 017b          .dw XT_LATEST
000322 707c          .dw XT_STORE
                 
000323 01a6          .dw XT_COMPILE
000324 7001          .dw DO_COLON
                 
000325 0333          .dw XT_RBRACKET
000326 701b          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
000327 0001          .dw $0001
000328 003b          .db $3b,0
000329 0318          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
00032a 7001          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
00032b 01a6          .dw XT_COMPILE
00032c 701b          .dw XT_EXIT
00032d 033b          .dw XT_LBRACKET
00032e 02e3          .dw XT_REVEAL
00032f 701b          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
000330 ff01          .dw $ff01
000331 005d          .db "]",0
000332 0327          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000333 7001          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
000334 7d5c          .dw XT_ONE
000335 754b          .dw XT_STATE
000336 707c          .dw XT_STORE
000337 701b          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
000338 0001          .dw $0001
000339 005b          .db "[",0
00033a 0330          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
00033b 7001          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
00033c 714f          .dw XT_ZERO
00033d 754b          .dw XT_STATE
00033e 707c          .dw XT_STORE
00033f 701b          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
000340 ff08          .dw $ff08
000341 6176
000342 6972
000343 6261
000344 656c          .db "variable"
000345 0338          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000346 7001          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
000347 75bf          .dw XT_HERE
000348 0352          .dw XT_CONSTANT
000349 7d61          .dw XT_TWO
00034a 75c8          .dw XT_ALLOT
00034b 701b          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
00034c ff08          .dw $ff08
00034d 6f63
00034e 736e
00034f 6174
000350 746e          .db "constant"
000351 0340          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000352 7001          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000353 0183          .dw XT_DOCREATE
000354 02e3          .dw XT_REVEAL
000355 01a6          .dw XT_COMPILE
000356 7043          .dw PFA_DOVARIABLE
000357 01b1          .dw XT_COMMA
000358 701b          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000359 ff04          .dw $ff04
00035a 7375
00035b 7265          .db "user"
00035c 034c          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
00035d 7001          .dw DO_COLON
                 PFA_USER:
00035e 0183          .dw XT_DOCREATE
00035f 02e3          .dw XT_REVEAL
                 
000360 01a6          .dw XT_COMPILE
000361 7053          .dw PFA_DOUSER
000362 01b1          .dw XT_COMMA
000363 701b          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECURSE:
000364 0007          .dw $0007
000365 6572
000366 7563
000367 7372
000368 0065          .db "recurse",0
000369 0359          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
00036a 7001          .dw DO_COLON
                 PFA_RECURSE:
                 .endif
00036b 017b          .dw XT_LATEST
00036c 7074          .dw XT_FETCH
00036d 01b1          .dw XT_COMMA
00036e 701b          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
00036f ff09          .dw $ff09
000370 6d69
000371 656d
000372 6964
000373 7461
000374 0065          .db "immediate",0
000375 0364          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000376 7001          .dw DO_COLON
                 PFA_IMMEDIATE:
000377 0411          .dw XT_GET_CURRENT
000378 734e          .dw XT_FETCHE
000379 70ac          .dw XT_DUP
00037a 73bb          .dw XT_FETCHI
00037b 7038          .dw XT_DOLITERAL
00037c 7fff          .dw $7fff
00037d 720e          .dw XT_AND
00037e 70bf          .dw XT_SWAP
00037f 7362          .dw XT_STOREI
000380 701b          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
000381 0006          .dw $0006
000382 635b
000383 6168
000384 5d72          .db "[char]"
000385 036f          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000386 7001          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
000387 01a6          .dw XT_COMPILE
000388 7038          .dw XT_DOLITERAL
000389 78e5          .dw XT_CHAR
00038a 01b1          .dw XT_COMMA
00038b 701b          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
00038c 0006          .dw $0006
00038d 6261
00038e 726f
00038f 2274          .db "abort",'"'
000390 0381          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
000391 7001          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
000392 74c1          .dw XT_SQUOTE
000393 01a6          .dw XT_COMPILE
000394 03a3          .dw XT_QABORT
000395 701b          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
000396 ff05          .dw $ff05
000397 6261
000398 726f
000399 0074          .db "abort",0
00039a 038c          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
00039b 7001          .dw DO_COLON
                 PFA_ABORT:
                 .endif
00039c 7146          .dw XT_TRUE
00039d 783c          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
00039e ff06          .dw $ff06
00039f 613f
0003a0 6f62
0003a1 7472          .db "?abort"
0003a2 0396          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
0003a3 7001          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
0003a4 70dc
0003a5 7031              .DW XT_ROT,XT_DOCONDBRANCH
0003a6 03a9              DEST(QABO1)
0003a7 77a3
0003a8 039b              .DW XT_ITYPE,XT_ABORT
0003a9 756e
0003aa 701b      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
0003ab ff09          .dw $ff09
0003ac 6567
0003ad 2d74
0003ae 7473
0003af 6361
0003b0 006b          .db "get-stack",0
0003b1 039e          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
0003b2 7001          .dw DO_COLON
                 .endif
0003b3 70ac          .dw XT_DUP
0003b4 755e          .dw XT_CELLPLUS
0003b5 70bf          .dw XT_SWAP
0003b6 734e          .dw XT_FETCHE
0003b7 70ac          .dw XT_DUP
0003b8 70fa          .dw XT_TO_R
0003b9 714f          .dw XT_ZERO
0003ba 70bf          .dw XT_SWAP    ; go from bigger to smaller addresses
0003bb 0270          .dw XT_QDOCHECK
0003bc 7031          .dw XT_DOCONDBRANCH
0003bd 03c9          DEST(PFA_N_FETCH_E2)
0003be 728a          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
0003bf 729b          .dw XT_I
0003c0 7230          .dw XT_1MINUS
0003c1 7558          .dw XT_CELLS ; ( -- ee-addr i*2 )
0003c2 70ca          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
0003c3 7198          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
0003c4 734e          .dw XT_FETCHE ;( -- ee-addr item_i )
0003c5 70bf          .dw XT_SWAP   ;( -- item_i ee-addr )
0003c6 7146          .dw XT_TRUE  ; shortcut for -1
0003c7 72a9          .dw XT_DOPLUSLOOP
0003c8 03bf          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
0003c9 756e          .dw XT_2DROP
0003ca 70f1          .dw XT_R_FROM
0003cb 701b          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
0003cc ff09          .dw $ff09
0003cd 6573
0003ce 2d74
0003cf 7473
0003d0 6361
0003d1 006b          .db "set-stack",0
0003d2 03ab          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
0003d3 7001          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
0003d4 7565          .dw XT_2DUP
0003d5 732a          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
0003d6 70bf          .dw XT_SWAP    
0003d7 714f          .dw XT_ZERO
0003d8 0270          .dw XT_QDOCHECK
0003d9 7031          .dw XT_DOCONDBRANCH
0003da 03e1          DEST(PFA_SET_STACK2)
0003db 728a          .dw XT_DODO
                 PFA_SET_STACK1:
0003dc 755e          .dw XT_CELLPLUS ; ( -- i_x e-addr )
0003dd 7576          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
0003de 732a          .dw XT_STOREE
0003df 72b8          .dw XT_DOLOOP
0003e0 03dc          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
0003e1 70d4          .dw XT_DROP
0003e2 701b          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
0003e3 ff09          .dw $ff09
0003e4 616d
0003e5 2d70
0003e6 7473
0003e7 6361
0003e8 006b          .db "map-stack",0
0003e9 03cc          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
0003ea 7001          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
0003eb 70ac          .dw XT_DUP
0003ec 755e          .dw XT_CELLPLUS
0003ed 70bf          .dw XT_SWAP
0003ee 734e          .dw XT_FETCHE
0003ef 7558          .dw XT_CELLS
0003f0 7d34          .dw XT_BOUNDS
0003f1 0270          .dw XT_QDOCHECK
0003f2 7031          .dw XT_DOCONDBRANCH
0003f3 0406          DEST(PFA_MAPSTACK3)
0003f4 728a          .dw XT_DODO
                 PFA_MAPSTACK1:
0003f5 729b            .dw XT_I
0003f6 734e            .dw XT_FETCHE   ; -- i*x XT id
0003f7 70bf            .dw XT_SWAP
0003f8 70fa            .dw XT_TO_R
0003f9 7103            .dw XT_R_FETCH
0003fa 7025            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
0003fb 70b4            .dw XT_QDUP
0003fc 7031            .dw XT_DOCONDBRANCH
0003fd 0402            DEST(PFA_MAPSTACK2)
0003fe 70f1               .dw XT_R_FROM
0003ff 70d4               .dw XT_DROP
000400 72c3               .dw XT_UNLOOP
000401 701b               .dw XT_EXIT
                 PFA_MAPSTACK2:
000402 70f1            .dw XT_R_FROM
000403 7d61            .dw XT_TWO
000404 72a9            .dw XT_DOPLUSLOOP
000405 03f5            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
000406 70d4          .dw XT_DROP
000407 714f          .dw XT_ZERO
000408 701b          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000409 ff0b          .dw $ff0b
00040a 6567
00040b 2d74
00040c 7563
00040d 7272
00040e 6e65
00040f 0074          .db "get-current",0
000410 03e3          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000411 7001          .dw DO_COLON
                 PFA_GET_CURRENT:
000412 7038          .dw XT_DOLITERAL
000413 0048          .dw CFG_CURRENT
000414 734e          .dw XT_FETCHE
000415 701b          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_ORDER:
000416 ff09          .dw $ff09
000417 6567
000418 2d74
000419 726f
00041a 6564
00041b 0072          .db "get-order",0
00041c 0409          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
00041d 7001          .dw DO_COLON
                 PFA_GET_ORDER:
                 .endif
00041e 7038          .dw XT_DOLITERAL
00041f 004c          .dw CFG_ORDERLISTLEN
000420 03b2          .dw XT_GET_STACK
000421 701b          .dw XT_EXIT
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000422 ff07          .dw $ff07
000423 6f63
000424 706d
000425 7261
000426 0065          .db "compare",0
000427 0416          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000428 0429          .dw PFA_COMPARE
                 PFA_COMPARE:
000429 93bf          push xh
00042a 93af          push xl
00042b 018c          movw temp0, tosl
00042c 9189
00042d 9199          loadtos
00042e 01dc          movw xl, tosl
00042f 9189
000430 9199          loadtos
000431 019c          movw temp2, tosl
000432 9189
000433 9199          loadtos
000434 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000435 90ed          ld temp4, X+
000436 90f1          ld temp5, Z+
000437 14ef          cp temp4, temp5
000438 f451          brne PFA_COMPARE_NOTEQUAL
000439 950a          dec temp0
00043a f019          breq PFA_COMPARE_ENDREACHED2
00043b 952a          dec temp2
00043c f7c1          brne PFA_COMPARE_LOOP
00043d c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
00043e 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
00043f 2b02          or temp0, temp2
000440 f411          brne PFA_COMPARE_CHECKLASTCHAR
000441 2788          clr tosl
000442 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000443 ef8f          ser tosl
000444 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000445 2f98          mov tosh, tosl
000446 91af          pop xl
000447 91bf          pop xh
000448 940c 7005     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
00044a ff07         .dw $ff07
00044b 666e
00044c 3e61
00044d 666c
00044e 0061         .db "nfa>lfa",0
00044f 0422         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000450 7001          .dw DO_COLON
                 PFA_NFA2LFA:
000451 7c47          .dw XT_NAME2STRING
000452 722a          .dw XT_1PLUS
000453 71ff          .dw XT_2SLASH
000454 7198          .dw XT_PLUS
000455 701b          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTS:
000456 ff02          .dw $ff02
000457 732e          .db ".s"
000458 044a          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000459 7001          .dw DO_COLON
                 PFA_DOTS:
                 .endif
00045a 7a84          .dw XT_DEPTH
00045b 7440          .dw XT_UDOT
00045c 77e5          .dw XT_SPACE
00045d 7a84          .dw XT_DEPTH
00045e 714f          .dw XT_ZERO
00045f 0270          .dw XT_QDOCHECK
000460 7031          .dw XT_DOCONDBRANCH
000461 0468          DEST(PFA_DOTS2)
000462 728a          .dw XT_DODO
                 PFA_DOTS1:
000463 729b          .dw XT_I
000464 74af          .dw XT_PICK
000465 7440          .dw XT_UDOT
000466 72b8          .dw XT_DOLOOP
000467 0463          DEST(PFA_DOTS1)
                 PFA_DOTS2:
000468 701b          .dw XT_EXIT
                 .include "words/spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 1 byte
                 VE_SPIRW:
000469 ff06          .dw $ff06
00046a 2163
00046b 7340
00046c 6970          .db "c!@spi"
00046d 0456          .dw VE_HEAD
                     .set VE_HEAD  = VE_SPIRW
                 XT_SPIRW:
00046e 046f          .dw PFA_SPIRW
                 PFA_SPIRW:
00046f d003          rcall do_spirw
000470 2799          clr tosh
000471 940c 7005     jmp_ DO_NEXT
                 
                 do_spirw:
000473 bd8e          out_ SPDR, tosl
                 do_spirw1:
000474 b50d          in_ temp0, SPSR
000475 7f08          cbr temp0,7
000476 bd0d          out_ SPSR, temp0
000477 b50d          in_ temp0, SPSR
000478 ff07          sbrs temp0, 7
000479 cffa          rjmp do_spirw1   ; wait until complete
00047a b58e          in_ tosl, SPDR
00047b 9508          ret
                 .include "words/n-spi.asm"
                 
                 ; MCU
                 ; read len bytes from SPI to addr
                 VE_N_SPIR:
00047c ff05          .dw $ff05
00047d 406e
00047e 7073
00047f 0069          .db "n@spi",0
000480 0469          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIR
                 XT_N_SPIR:
000481 0482          .dw PFA_N_SPIR
                 PFA_N_SPIR:
000482 018c          movw temp0, tosl
000483 9189
000484 9199          loadtos
000485 01fc          movw zl, tosl
000486 01c8          movw tosl, temp0
                 PFA_N_SPIR_LOOP:
000487 bc2e          out_ SPDR, zerol
                 PFA_N_SPIR_LOOP1:
000488 b52d          in_ temp2, SPSR
000489 ff27          sbrs temp2, SPIF
00048a cffd          rjmp PFA_N_SPIR_LOOP1
00048b b52e          in_ temp2, SPDR
00048c 9321          st Z+, temp2
00048d 9701          sbiw tosl, 1
00048e f7c1          brne PFA_N_SPIR_LOOP
00048f 9189
000490 9199          loadtos
000491 940c 7005     jmp_ DO_NEXT
                 
                 ; ( addr len -- ) 
                 ; MCU
                 ; write len bytes to SPI from addr
                 VE_N_SPIW:
000493 ff05          .dw $ff05
000494 216e
000495 7073
000496 0069          .db "n!spi",0
000497 047c          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIW
                 XT_N_SPIW:
000498 0499          .dw PFA_N_SPIW
                 PFA_N_SPIW:
000499 018c          movw temp0, tosl
00049a 9189
00049b 9199          loadtos
00049c 01fc          movw zl, tosl
00049d 01c8          movw tosl, temp0
                 PFA_N_SPIW_LOOP:
00049e 9121          ld temp2, Z+
00049f bd2e          out_ SPDR, temp2
                 PFA_N_SPIW_LOOP1:
0004a0 b52d          in_ temp2, SPSR
0004a1 ff27          sbrs temp2, SPIF
0004a2 cffd          rjmp PFA_N_SPIW_LOOP1
0004a3 b52e          in_ temp2, SPDR ; ignore the data
0004a4 9701          sbiw tosl, 1
0004a5 f7c1          brne PFA_N_SPIW_LOOP
0004a6 9189
0004a7 9199          loadtos
0004a8 940c 7005     jmp_ DO_NEXT
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
0004aa ff0b          .dw $ff0b
0004ab 7061
0004ac 6c70
0004ad 7574
0004ae 6e72
0004af 656b
0004b0 0079          .db "applturnkey",0
0004b1 0493          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
0004b2 7001          .dw DO_COLON
                 PFA_APPLTURNKEY:
0004b3 00b8          .dw XT_USART
0004b4 7471          .dw XT_INTON
0004b5 7b39          .dw XT_DOT_VER
0004b6 77e5          .dw XT_SPACE
0004b7 7540          .dw XT_F_CPU
0004b8 7038          .dw XT_DOLITERAL
0004b9 03e8          .dw 1000
0004ba 71bd          .dw XT_UMSLASHMOD
0004bb 70eb          .dw XT_NIP
0004bc 75dd          .dw XT_DECIMAL
0004bd 7725          .dw XT_DOT
0004be 7770          .dw XT_DOSLITERAL
0004bf 0004          .dw 4
0004c0 486b
0004c1 207a          .db "kHz "
0004c2 77a3          .dw XT_ITYPE
0004c3 701b          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
0004c4 ff0b          .dw $ff0b
0004c5 6573
0004c6 2d74
0004c7 7563
0004c8 7272
0004c9 6e65
0004ca 0074          .db "set-current",0
0004cb 04aa          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
0004cc 7001          .dw DO_COLON
                 PFA_SET_CURRENT:
0004cd 7038          .dw XT_DOLITERAL
0004ce 0048          .dw CFG_CURRENT
0004cf 732a          .dw XT_STOREE
0004d0 701b          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
0004d1 ff08          .dw $ff08
0004d2 6f77
0004d3 6472
0004d4 696c
0004d5 7473          .db "wordlist"
0004d6 04c4          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
0004d7 7001          .dw DO_COLON
                 PFA_WORDLIST:
0004d8 75b7          .dw XT_EHERE
0004d9 714f          .dw XT_ZERO
0004da 70ca          .dw XT_OVER
0004db 732a          .dw XT_STOREE
0004dc 70ac          .dw XT_DUP
0004dd 755e          .dw XT_CELLPLUS
0004de 7b6e          .dw XT_DOTO
0004df 75b8          .dw PFA_EHERE
0004e0 701b          .dw XT_EXIT
                 
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTHWORDLIST:
0004e1 ff0e          .dw $ff0e
0004e2 6f66
0004e3 7472
0004e4 2d68
0004e5 6f77
0004e6 6472
0004e7 696c
0004e8 7473          .db "forth-wordlist"
0004e9 04d1          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHWORDLIST
                 XT_FORTHWORDLIST:
0004ea 7043          .dw PFA_DOVARIABLE
                 PFA_FORTHWORDLIST:
0004eb 004a          .dw CFG_FORTHWORDLIST
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_ORDER:
0004ec ff09          .dw $ff09
0004ed 6573
0004ee 2d74
0004ef 726f
0004f0 6564
0004f1 0072          .db "set-order",0
0004f2 04e1          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
0004f3 7001          .dw DO_COLON
                 PFA_SET_ORDER:
                 .endif
0004f4 7038          .dw XT_DOLITERAL
0004f5 004c          .dw CFG_ORDERLISTLEN
0004f6 03d3          .dw XT_SET_STACK
0004f7 701b          .dw XT_EXIT
                 
                 .include "words/set-recognizer.asm"
                 
                 ; Interpreter
                 ; replace the recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_RECOGNIZERS:
0004f8 ff0f          .dw $ff0f
0004f9 6573
0004fa 2d74
0004fb 6572
0004fc 6f63
0004fd 6e67
0004fe 7a69
0004ff 7265
000500 0073          .db "set-recognizers",0
000501 04ec          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_RECOGNIZERS
                 XT_SET_RECOGNIZERS:
000502 7001          .dw DO_COLON
                 PFA_SET_RECOGNIZERS:
                 .endif
000503 7038          .dw XT_DOLITERAL
000504 005e          .dw CFG_RECOGNIZERLISTLEN
000505 03d3          .dw XT_SET_STACK
000506 701b          .dw XT_EXIT
                 
                 .include "words/get-recognizer.asm"
                 
                 ; Interpreter
                 ; Get the current recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_RECOGNIZERS:
000507 ff0f          .dw $ff0f
000508 6567
000509 2d74
00050a 6572
00050b 6f63
00050c 6e67
00050d 7a69
00050e 7265
00050f 0073          .db "get-recognizers",0
000510 04f8          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_RECOGNIZERS
                 XT_GET_RECOGNIZERS:
000511 7001          .dw DO_COLON
                 PFA_GET_RECOGNIZERS:
                 .endif
000512 7038          .dw XT_DOLITERAL
000513 005e          .dw CFG_RECOGNIZERLISTLEN
000514 03b2          .dw XT_GET_STACK
000515 701b          .dw XT_EXIT
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000516 ff04          .dw $ff04
000517 6f63
000518 6564          .db "code"
000519 0507          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
00051a 7001          .dw DO_COLON
                 PFA_CODE:
00051b 0183          .dw XT_DOCREATE
00051c 02e3          .dw XT_REVEAL
00051d 75ae          .dw XT_DP
00051e 7b80          .dw XT_ICELLPLUS
00051f 01b1          .dw XT_COMMA
000520 701b          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000521 ff08          .dw $ff08
000522 6e65
000523 2d64
000524 6f63
000525 6564          .db "end-code"
000526 0516          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000527 7001          .dw DO_COLON
                 PFA_ENDCODE:
000528 01a6          .dw XT_COMPILE
000529 940c          .dw $940c
00052a 01a6          .dw XT_COMPILE
00052b 7005          .dw DO_NEXT
00052c 701b          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
00052d ff08          .dw $ff08
00052e 6d28
00052f 7261
000530 656b
000531 2972          .db "(marker)"
000532 0521          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000533 706a          .dw PFA_DOVALUE1
                 PFA_MARKER:
000534 006a          .dw EE_MARKER
000535 7b89          .dw XT_EDEFERFETCH
000536 7b93          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
000537 0008          .dw $0008
000538 6f70
000539 7473
00053a 6f70
00053b 656e          .db "postpone"
00053c 052d          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
00053d 7001          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
00053e 79b0          .dw XT_PARSENAME
00053f 7aad          .dw XT_DORECOGNIZER
000540 70ac          .dw XT_DUP
000541 70fa          .dw XT_TO_R
000542 7b80          .dw XT_ICELLPLUS
000543 7b80          .dw XT_ICELLPLUS
000544 73bb          .dw XT_FETCHI
000545 7025          .dw XT_EXECUTE
000546 70f1          .dw XT_R_FROM
000547 7b80          .dw XT_ICELLPLUS
000548 73bb          .dw XT_FETCHI
000549 01b1          .dw XT_COMMA
00054a 701b          .dw XT_EXIT
                 .endif
                 .include "words/2r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_2R_FETCH:
00054b ff03          .dw $ff03
00054c 7232
00054d 0040          .db "2r@",0
00054e 0537          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FETCH
                 XT_2R_FETCH:
00054f 0550          .dw PFA_2R_FETCH
                 PFA_2R_FETCH:
000550 939a
000551 938a          savetos
000552 91ef          pop zl
000553 91ff          pop zh
000554 918f          pop tosl
000555 919f          pop tosh
000556 939f          push tosh
000557 938f          push tosl
000558 93ff          push zh
000559 93ef          push zl
00055a 939a
00055b 938a          savetos
00055c 01cf          movw tosl, zl
00055d 940c 7005     jmp_ DO_NEXT
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
007001 93bf          push XH
007002 93af          push XL          ; PUSH IP
007003 01db          movw XL, wl
007004 9611          adiw xl, 1
                 DO_NEXT:
007005 f06e          brts DO_INTERRUPT
007006 01fd          movw zl, XL        ; READ IP
007007 0fee
007008 1fff
007009 9165
00700a 9175          readflashcell wl, wh
00700b 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00700c 01fb          movw zl, wl
00700d 0fee
00700e 1fff
00700f 9105
007010 9115          readflashcell temp0,temp1
007011 01f8          movw zl, temp0
007012 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
007013 94e8          clt
007014 e96c          ldi wl, LOW(XT_ISREXEC)
007015 e774          ldi wh, HIGH(XT_ISREXEC)
007016 cff5          rjmp DO_EXECUTE
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
007017 ff04          .dw $ff04
007018 7865
007019 7469          .db "exit"
00701a 054b          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00701b 701c          .dw PFA_EXIT
                 PFA_EXIT:
00701c 91af          pop XL
00701d 91bf          pop XH
00701e cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00701f ff07          .dw $ff07
007020 7865
007021 6365
007022 7475
007023 0065          .db "execute",0
007024 7017          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
007025 7026          .dw PFA_EXECUTE
                 PFA_EXECUTE:
007026 01bc          movw wl, tosl
007027 9189
007028 9199          loadtos
007029 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00702a 702b          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00702b 01fd          movw zl, XL
00702c 0fee
00702d 1fff
00702e 91a5
00702f 91b5          readflashcell XL,XH
007030 cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
007031 7032          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
007032 2b98          or tosh, tosl
007033 9189
007034 9199          loadtos
007035 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
007036 9611          adiw XL, 1
007037 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
007038 7039          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
007039 939a
00703a 938a          savetos
00703b 01fd          movw zl, xl
00703c 0fee
00703d 1fff
00703e 9185
00703f 9195          readflashcell tosl,tosh
007040 9611          adiw xl, 1
007041 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
007042 7043          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
007043 939a
007044 938a          savetos
007045 01fb          movw zl, wl
007046 9631          adiw zl,1
007047 0fee
007048 1fff
007049 9185
00704a 9195          readflashcell tosl,tosh
00704b cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00704c 704d          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00704d 939a
00704e 938a          savetos
00704f 01cb          movw tosl, wl
007050 9601          adiw tosl, 1
007051 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
007052 7053          .dw PFA_DOUSER
                 PFA_DOUSER:
007053 939a
007054 938a          savetos
007055 01fb          movw zl, wl
007056 9631          adiw zl, 1
007057 0fee
007058 1fff
007059 9185
00705a 9195          readflashcell tosl,tosh
00705b 0d84          add tosl, upl
00705c 1d95          adc tosh, uph
00705d cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00705e ff07          .dw $ff07
00705f 7628
007060 6c61
007061 6575
007062 0029          .db "(value)", 0
007063 701f          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
007064 7001          .dw DO_COLON
                 PFA_DOVALUE:
007065 0183          .dw XT_DOCREATE
007066 02e3          .dw XT_REVEAL
007067 01a6          .dw XT_COMPILE
007068 706a          .dw PFA_DOVALUE1
007069 701b          .dw XT_EXIT
                 PFA_DOVALUE1:
00706a 940e 02fc     call_ DO_DODOES
00706c 70ac          .dw XT_DUP
00706d 7b80          .dw XT_ICELLPLUS
00706e 73bb          .dw XT_FETCHI
00706f 7025          .dw XT_EXECUTE
007070 701b          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
007071 ff01          .dw $ff01
007072 0040          .db "@",0
007073 705e          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
007074 7075          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
007075 01fc          movw zl, tosl
                     ; low byte is read before the high byte
007076 9181          ld tosl, z+
007077 9191          ld tosh, z+
007078 cf8c          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
007079 ff01          .dw $ff01
00707a 0021          .db "!",0
00707b 7071          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00707c 707d          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00707d 01fc          movw zl, tosl
00707e 9189
00707f 9199          loadtos
                     ; the high byte is written before the low byte
007080 8391          std Z+1, tosh
007081 8380          std Z+0, tosl
007082 9189
007083 9199          loadtos
007084 cf80          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
007085 ff02          .dw $ff02
007086 2163          .db "c!"
007087 7079          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
007088 7089          .dw PFA_CSTORE
                 PFA_CSTORE:
007089 01fc          movw zl, tosl
00708a 9189
00708b 9199          loadtos
00708c 8380          st Z, tosl
00708d 9189
00708e 9199          loadtos
00708f cf75          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
007090 ff02          .dw $ff02
007091 4063          .db "c@"
007092 7085          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
007093 7094          .dw PFA_CFETCH
                 PFA_CFETCH:
007094 01fc          movw zl, tosl
007095 2799          clr tosh
007096 8180          ld tosl, Z
007097 cf6d          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
007098 ff02          .dw $ff02
007099 7540          .db "@u"
00709a 7090          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00709b 7001          .dw DO_COLON
                 PFA_FETCHU:
00709c 72f1          .dw XT_UP_FETCH
00709d 7198          .dw XT_PLUS
00709e 7074          .dw XT_FETCH
00709f 701b          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
0070a0 ff02          .dw $ff02
0070a1 7521          .db "!u"
0070a2 7098          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
0070a3 7001          .dw DO_COLON
                 PFA_STOREU:
0070a4 72f1          .dw XT_UP_FETCH
0070a5 7198          .dw XT_PLUS
0070a6 707c          .dw XT_STORE
0070a7 701b          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
0070a8 ff03          .dw $ff03
0070a9 7564
0070aa 0070          .db "dup",0
0070ab 70a0          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
0070ac 70ad          .dw PFA_DUP
                 PFA_DUP:
0070ad 939a
0070ae 938a          savetos
0070af cf55          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
0070b0 ff04          .dw $ff04
0070b1 643f
0070b2 7075          .db "?dup"
0070b3 70a8          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
0070b4 70b5          .dw PFA_QDUP
                 PFA_QDUP:
0070b5 2f08          mov temp0, tosl
0070b6 2b09          or temp0, tosh
0070b7 f011          breq PFA_QDUP1
0070b8 939a
0070b9 938a          savetos
                 PFA_QDUP1:
0070ba cf4a          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
0070bb ff04          .dw $ff04
0070bc 7773
0070bd 7061          .db "swap"
0070be 70b0          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
0070bf 70c0          .dw PFA_SWAP
                 PFA_SWAP:
0070c0 018c          movw temp0, tosl
0070c1 9189
0070c2 9199          loadtos
0070c3 931a          st -Y, temp1
0070c4 930a          st -Y, temp0
0070c5 cf3f          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
0070c6 ff04          .dw $ff04
0070c7 766f
0070c8 7265          .db "over"
0070c9 70bb          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
0070ca 70cb          .dw PFA_OVER
                 PFA_OVER:
0070cb 939a
0070cc 938a          savetos
0070cd 818a          ldd tosl, Y+2
0070ce 819b          ldd tosh, Y+3
                 
0070cf cf35          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
0070d0 ff04          .dw $ff04
0070d1 7264
0070d2 706f          .db "drop"
0070d3 70c6          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
0070d4 70d5          .dw PFA_DROP
                 PFA_DROP:
0070d5 9189
0070d6 9199          loadtos
0070d7 cf2d          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
0070d8 ff03          .dw $ff03
0070d9 6f72
0070da 0074          .db "rot",0
0070db 70d0          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
0070dc 70dd          .dw PFA_ROT
                 PFA_ROT:
0070dd 018c          movw temp0, tosl
0070de 9129          ld temp2, Y+
0070df 9139          ld temp3, Y+ 
0070e0 9189
0070e1 9199          loadtos
                         
0070e2 933a          st -Y, temp3
0070e3 932a          st -Y, temp2
0070e4 931a          st -Y, temp1
0070e5 930a          st -Y, temp0
                 
0070e6 cf1e          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
0070e7 ff03          .dw $ff03
0070e8 696e
0070e9 0070          .db "nip",0
0070ea 70d8          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
0070eb 70ec          .dw PFA_NIP
                 PFA_NIP:
0070ec 9622          adiw yl, 2
0070ed cf17          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
0070ee ff02          .dw $ff02
0070ef 3e72          .db "r>"
0070f0 70e7          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
0070f1 70f2          .dw PFA_R_FROM
                 PFA_R_FROM:
0070f2 939a
0070f3 938a          savetos
0070f4 918f          pop tosl
0070f5 919f          pop tosh
0070f6 cf0e          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
0070f7 ff02          .dw $ff02
0070f8 723e          .db ">r"
0070f9 70ee          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
0070fa 70fb          .dw PFA_TO_R
                 PFA_TO_R:
0070fb 939f          push tosh
0070fc 938f          push tosl
0070fd 9189
0070fe 9199          loadtos
0070ff cf05          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
007100 ff02          .dw $ff02
007101 4072          .db "r@"
007102 70f7          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
007103 7104          .dw PFA_R_FETCH
                 PFA_R_FETCH:
007104 939a
007105 938a          savetos
007106 918f          pop tosl
007107 919f          pop tosh
007108 939f          push tosh
007109 938f          push tosl
00710a cefa          jmp_ DO_NEXT
                 
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
00710b ff02          .dw $ff02
00710c 3e3c          .db "<>"
00710d 7100          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00710e 7001          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
00710f 7d55
007110 7115
007111 701b          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
007112 ff02          .dw $ff02
007113 3d30          .db "0="
007114 710b          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
007115 7116          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
007116 2b98          or tosh, tosl
007117 f5d1          brne PFA_ZERO1
007118 c030          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
007119 ff02          .dw $ff02
00711a 3c30          .db "0<"
00711b 7112          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
00711c 711d          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
00711d fd97          sbrc tosh,7
00711e c02a          rjmp PFA_TRUE1
00711f c032          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
007120 ff02          .dw $ff02
007121 3e30          .db "0>"
007122 7119          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
007123 7124          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
007124 1582          cp tosl, zerol
007125 0593          cpc tosh, zeroh
007126 f15c          brlt PFA_ZERO1
007127 f151          brbs 1, PFA_ZERO1
007128 c020          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
007129 ff03          .dw $ff03
00712a 3064
00712b 003e          .db "d0>",0
00712c 7120          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00712d 712e          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00712e 1582          cp tosl, zerol
00712f 0593          cpc tosh, zeroh
007130 9189
007131 9199          loadtos
007132 0582          cpc tosl, zerol
007133 0593          cpc tosh, zeroh
007134 f0ec          brlt PFA_ZERO1
007135 f0e1          brbs 1, PFA_ZERO1
007136 c012          rjmp PFA_TRUE1
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
007137 ff03          .dw $ff03
007138 3064
007139 003c          .db "d0<",0
00713a 7129          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
00713b 713c          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
00713c 9622          adiw Y,2
00713d fd97          sbrc tosh,7
00713e 940c 7149     jmp PFA_TRUE1
007140 940c 7152     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
007142 ff04          .dw $ff04
007143 7274
007144 6575          .db "true"
007145 7137          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
007146 7147          .dw PFA_TRUE
                 PFA_TRUE:
007147 939a
007148 938a          savetos
                 PFA_TRUE1:
007149 ef8f          ser tosl
00714a ef9f          ser tosh
00714b ceb9          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00714c ff01          .dw $ff01
00714d 0030          .db "0",0
00714e 7142          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00714f 7150          .dw PFA_ZERO
                 PFA_ZERO:
007150 939a
007151 938a          savetos
                 PFA_ZERO1:
007152 01c1          movw tosl, zerol
007153 ceb1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
007154 ff02          .dw $ff02
007155 3c75          .db "u<"
007156 714c          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
007157 7158          .dw PFA_ULESS
                 PFA_ULESS:
007158 9129          ld temp2, Y+
007159 9139          ld temp3, Y+
00715a 1782          cp tosl, temp2
00715b 0793          cpc tosh, temp3
00715c f3a8          brlo PFA_ZERO1
00715d f3a1          brbs 1, PFA_ZERO1
00715e cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
00715f ff02          .dw $ff02
007160 3e75          .db "u>"
007161 7154          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
007162 7001          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
007163 70bf          .DW XT_SWAP
007164 7157          .dw XT_ULESS
007165 701b          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
007166 ff01          .dw $ff01
007167 003c          .db "<",0
007168 715f          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
007169 716a          .dw PFA_LESS
                 PFA_LESS:
00716a 9129          ld temp2, Y+
00716b 9139          ld temp3, Y+
00716c 1728          cp temp2, tosl
00716d 0739          cpc temp3, tosh
                 PFA_LESSDONE:
00716e f71c          brge PFA_ZERO1
00716f cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
007170 ff01          .dw $ff01
007171 003e          .db ">",0
007172 7166          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
007173 7174          .dw PFA_GREATER
                 PFA_GREATER:
007174 9129          ld temp2, Y+
007175 9139          ld temp3, Y+
007176 1728          cp temp2, tosl
007177 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
007178 f2cc          brlt PFA_ZERO1
007179 f2c1          brbs 1, PFA_ZERO1
00717a cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00717b ff04          .dw $ff04
00717c 6f6c
00717d 3267          .db "log2"
00717e 7170          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00717f 7180          .dw PFA_LOG2
                 PFA_LOG2:
007180 01fc          movw zl, tosl
007181 2799          clr tosh
007182 e180          ldi tosl, 16
                 PFA_LOG2_1:
007183 958a          dec tosl
007184 f022          brmi PFA_LOG2_2 ; wrong data
007185 0fee          lsl  zl
007186 1fff          rol  zh
007187 f7d8          brcc PFA_LOG2_1
007188 ce7c          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
007189 959a          dec tosh
00718a ce7a          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00718b ff01          .dw $ff01
00718c 002d          .db "-",0
00718d 717b          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00718e 718f          .dw PFA_MINUS
                 PFA_MINUS:
00718f 9109          ld temp0, Y+
007190 9119          ld temp1, Y+
007191 1b08          sub temp0, tosl
007192 0b19          sbc temp1, tosh
007193 01c8          movw tosl, temp0
007194 ce70          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
007195 ff01          .dw $ff01
007196 002b          .db "+",0
007197 718b          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
007198 7199          .dw PFA_PLUS
                 PFA_PLUS:
007199 9109          ld temp0, Y+
00719a 9119          ld temp1, Y+
00719b 0f80          add tosl, temp0
00719c 1f91          adc tosh, temp1
00719d ce67          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00719e ff02          .dw $ff02
00719f 2a6d          .db "m*"
0071a0 7195          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
0071a1 71a2          .dw PFA_MSTAR
                 PFA_MSTAR:
0071a2 018c          movw temp0, tosl
0071a3 9189
0071a4 9199          loadtos
0071a5 019c          movw temp2, tosl
                     ; high cell ah*bh
0071a6 0231          muls temp3, temp1
0071a7 0170          movw temp4, r0
                     ; low cell  al*bl
0071a8 9f20          mul  temp2, temp0
0071a9 01c0          movw tosl, r0
                     ; signed ah*bl
0071aa 0330          mulsu temp3, temp0
0071ab 08f3          sbc   temp5, zeroh
0071ac 0d90          add   tosh,  r0
0071ad 1ce1          adc   temp4, r1
0071ae 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
0071af 0312          mulsu temp1, temp2
0071b0 08f3          sbc   temp5, zeroh
0071b1 0d90          add   tosh,  r0
0071b2 1ce1          adc   temp4, r1
0071b3 1cf3          adc   temp5, zeroh
                 
0071b4 939a
0071b5 938a          savetos
0071b6 01c7          movw tosl, temp4
0071b7 ce4d          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
0071b8 ff06          .dw $ff06
0071b9 6d75
0071ba 6d2f
0071bb 646f          .db "um/mod"
0071bc 719e          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
0071bd 71be          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
0071be 017c          movw temp4, tosl
                 
0071bf 9129          ld temp2, Y+
0071c0 9139          ld temp3, Y+
                   
0071c1 9109          ld temp0, Y+
0071c2 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
0071c3 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
0071c4 2755          clr temp7
0071c5 0f00          lsl temp0
0071c6 1f11          rol temp1
0071c7 1f22          rol temp2
0071c8 1f33          rol temp3
0071c9 1f55          rol temp7
                 
                   ; try subtracting divisor
0071ca 152e          cp temp2, temp4
0071cb 053f          cpc temp3, temp5
0071cc 0552          cpc temp7,zerol
                 
0071cd f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
0071ce 9503          inc temp0
0071cf 192e          sub temp2, temp4
0071d0 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
0071d1 954a          dec  temp6
0071d2 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
0071d3 933a          st -Y,temp3
0071d4 932a          st -Y,temp2
                 
                     ; put quotient on stack
0071d5 01c8          movw tosl, temp0
0071d6 ce2e          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
0071d7 ff03          .dw $ff03
0071d8 6d75
0071d9 002a          .db "um*",0
0071da 71b8          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
0071db 71dc          .dw PFA_UMSTAR
                 PFA_UMSTAR:
0071dc 018c          movw temp0, tosl
0071dd 9189
0071de 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
0071df 9f80          mul tosl,temp0
0071e0 01f0          movw zl, r0
0071e1 2722          clr temp2
0071e2 2733          clr temp3
                     ; middle bytes
0071e3 9f90          mul tosh, temp0
0071e4 0df0          add zh, r0
0071e5 1d21          adc temp2, r1
0071e6 1d33          adc temp3, zeroh
                         
0071e7 9f81          mul tosl, temp1
0071e8 0df0          add zh, r0
0071e9 1d21          adc temp2, r1
0071ea 1d33          adc temp3, zeroh
                     
0071eb 9f91          mul tosh, temp1
0071ec 0d20          add temp2, r0
0071ed 1d31          adc temp3, r1
0071ee 01cf          movw tosl, zl
0071ef 939a
0071f0 938a          savetos
0071f1 01c9          movw tosl, temp2
0071f2 ce12          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
0071f3 ff06          .dw $ff06
0071f4 6e69
0071f5 6576
0071f6 7472          .db "invert"
0071f7 71d7          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
0071f8 71f9          .dw PFA_INVERT
                 PFA_INVERT:
0071f9 9580          com tosl
0071fa 9590          com tosh
0071fb ce09          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
0071fc ff02          .dw $ff02
0071fd 2f32          .db "2/"
0071fe 71f3          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
0071ff 7200          .dw PFA_2SLASH
                 PFA_2SLASH:
007200 9595          asr tosh
007201 9587          ror tosl
007202 ce02          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
007203 ff02          .dw $ff02
007204 2a32          .db "2*"
007205 71fc          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
007206 7207          .dw PFA_2STAR
                 PFA_2STAR:
007207 0f88          lsl tosl
007208 1f99          rol tosh
007209 cdfb          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00720a ff03          .dw $ff03
00720b 6e61
00720c 0064          .db "and",0
00720d 7203          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00720e 720f          .dw PFA_AND
                 PFA_AND:
00720f 9109          ld temp0, Y+
007210 9119          ld temp1, Y+
007211 2380          and tosl, temp0
007212 2391          and tosh, temp1
007213 cdf1          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
007214 ff02          .dw $ff02
007215 726f          .db "or"
007216 720a          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
007217 7218          .dw PFA_OR
                 PFA_OR:
007218 9109          ld temp0, Y+
007219 9119          ld temp1, Y+
00721a 2b80          or tosl, temp0
00721b 2b91          or tosh, temp1
00721c cde8          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00721d ff03          .dw $ff03
00721e 6f78
00721f 0072          .db "xor",0
007220 7214          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
007221 7222          .dw PFA_XOR
                 PFA_XOR:
007222 9109          ld temp0, Y+
007223 9119          ld temp1, Y+
007224 2780          eor tosl, temp0
007225 2791          eor tosh, temp1
007226 cdde          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
007227 ff02          .dw $ff02
007228 2b31          .db "1+"
007229 721d          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00722a 722b          .dw PFA_1PLUS
                 PFA_1PLUS:
00722b 9601          adiw tosl,1
00722c cdd8          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00722d ff02          .dw $ff02 
00722e 2d31          .db "1-"
00722f 7227          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
007230 7231          .dw PFA_1MINUS
                 PFA_1MINUS:
007231 9701          sbiw tosl, 1
007232 cdd2          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
007233 ff06          .dw $ff06
007234 736c
007235 6968
007236 7466          .db "lshift"
007237 722d          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
007238 7239          .dw PFA_LSHIFT
                 PFA_LSHIFT:
007239 01fc          movw zl, tosl
00723a 9189
00723b 9199          loadtos
                 PFA_LSHIFT1:
00723c 9731          sbiw zl, 1
00723d f01a          brmi PFA_LSHIFT2
00723e 0f88          lsl tosl
00723f 1f99          rol tosh
007240 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
007241 cdc3          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
007242 ff06          .dw $ff06
007243 7372
007244 6968
007245 7466          .db "rshift"
007246 7233          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
007247 7248          .dw PFA_RSHIFT
                 PFA_RSHIFT:
007248 01fc          movw zl, tosl
007249 9189
00724a 9199          loadtos
                 PFA_RSHIFT1:
00724b 9731          sbiw zl, 1
00724c f01a          brmi PFA_RSHIFT2
00724d 9596          lsr tosh
00724e 9587          ror tosl
00724f cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
007250 cdb4          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
007251 ff02          .dw $ff02
007252 212b          .db "+!"
007253 7242          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
007254 7255          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
007255 01fc          movw zl, tosl
007256 9189
007257 9199          loadtos
007258 8120          ldd temp2, Z+0
007259 8131          ldd temp3, Z+1
00725a 0f82          add tosl, temp2
00725b 1f93          adc tosh, temp3
00725c 8380          std Z+0, tosl
00725d 8391          std Z+1, tosh
00725e 9189
00725f 9199          loadtos
007260 cda4          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
007261 ff03          .dw $ff03
007262 7072
007263 0040          .db "rp@",0
007264 7251          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
007265 7266          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
007266 939a
007267 938a          savetos
007268 b78d          in tosl, SPL
007269 b79e          in tosh, SPH
00726a cd9a          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00726b ff03          .dw $ff03
00726c 7072
00726d 0021          .db "rp!",0
00726e 7261          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00726f 7270          .dw PFA_RP_STORE
                 PFA_RP_STORE:
007270 b72f          in temp2, SREG
007271 94f8          cli
007272 bf8d          out SPL, tosl
007273 bf9e          out SPH, tosh
007274 bf2f          out SREG, temp2
007275 9189
007276 9199          loadtos
007277 cd8d          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
007278 ff03          .dw $ff03
007279 7073
00727a 0040          .db "sp@",0
00727b 726b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00727c 727d          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00727d 939a
00727e 938a          savetos
00727f 01ce          movw tosl, yl
007280 cd84          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
007281 ff03          .dw $ff03
007282 7073
007283 0021          .db "sp!",0
007284 7278          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
007285 7286          .dw PFA_SP_STORE
                 PFA_SP_STORE:
007286 01ec          movw yl, tosl
007287 9189
007288 9199          loadtos
007289 cd7b          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
00728a 728b          .dw PFA_DODO
                 PFA_DODO:
00728b 9129          ld temp2, Y+
00728c 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
00728d e8e0          ldi zl, $80
00728e 0f3e          add temp3, zl
00728f 1b82          sub  tosl, temp2
007290 0b93          sbc  tosh, temp3
                 
007291 933f          push temp3
007292 932f          push temp2    ; limit  ( --> limit + $8000)
007293 939f          push tosh
007294 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
007295 9189
007296 9199          loadtos
007297 cd6d          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
007298 ff01          .dw $FF01
007299 0069          .db "i",0
00729a 7281          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
00729b 729c          .dw PFA_I
                 PFA_I:
00729c 939a
00729d 938a          savetos
00729e 918f          pop tosl
00729f 919f          pop tosh  ; index
0072a0 91ef          pop zl
0072a1 91ff          pop zh    ; limit
0072a2 93ff          push zh
0072a3 93ef          push zl
0072a4 939f          push tosh
0072a5 938f          push tosl
0072a6 0f8e          add tosl, zl
0072a7 1f9f          adc tosh, zh
0072a8 cd5c          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
0072a9 72aa          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
0072aa 91ef          pop zl
0072ab 91ff          pop zh
0072ac 0fe8          add zl, tosl
0072ad 1ff9          adc zh, tosh
0072ae 9189
0072af 9199          loadtos
0072b0 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
0072b1 93ff          push zh
0072b2 93ef          push zl
0072b3 cd77          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
0072b4 910f          pop  temp0
0072b5 911f          pop  temp1  ; remove limit
0072b6 9611          adiw xl, 1  ; skip branch-back address
0072b7 cd4d          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
0072b8 72b9          .dw PFA_DOLOOP
                 PFA_DOLOOP:
0072b9 91ef          pop zl
0072ba 91ff          pop zh
0072bb 9631          adiw zl,1
0072bc f3bb          brvs PFA_DOPLUSLOOP_LEAVE
0072bd cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
0072be ff06          .dw $ff06
0072bf 6e75
0072c0 6f6c
0072c1 706f          .db "unloop"
0072c2 7298          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
0072c3 72c4          .dw PFA_UNLOOP
                 PFA_UNLOOP:
0072c4 911f          pop temp1
0072c5 910f          pop temp0
0072c6 911f          pop temp1
0072c7 910f          pop temp0
0072c8 cd3c          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
0072c9 ff06          .dw $ff06
0072ca 6d63
0072cb 766f
0072cc 3e65          .db "cmove>"
0072cd 72be          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
0072ce 72cf          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
0072cf 93bf          push xh
0072d0 93af          push xl
0072d1 91e9          ld zl, Y+
0072d2 91f9          ld zh, Y+ ; addr-to
0072d3 91a9          ld xl, Y+
0072d4 91b9          ld xh, Y+ ; addr-from
0072d5 2f09          mov temp0, tosh
0072d6 2b08          or temp0, tosl
0072d7 f041          brbs 1, PFA_CMOVE_G1
0072d8 0fe8          add zl, tosl
0072d9 1ff9          adc zh, tosh
0072da 0fa8          add xl, tosl
0072db 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
0072dc 911e          ld temp1, -X
0072dd 9312          st -Z, temp1
0072de 9701          sbiw tosl, 1
0072df f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
0072e0 91af          pop xl
0072e1 91bf          pop xh
0072e2 9189
0072e3 9199          loadtos
0072e4 cd20          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
0072e5 ff02          .dw $ff02
0072e6 3c3e          .db "><"
0072e7 72c9          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
0072e8 72e9          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
0072e9 2f09          mov temp0, tosh
0072ea 2f98          mov tosh, tosl
0072eb 2f80          mov tosl, temp0
0072ec cd18          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
0072ed ff03          .dw $ff03
0072ee 7075
0072ef 0040          .db "up@",0
0072f0 72e5          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
0072f1 72f2          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
0072f2 939a
0072f3 938a          savetos
0072f4 01c2          movw tosl, upl
0072f5 cd0f          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
0072f6 ff03          .dw $ff03
0072f7 7075
0072f8 0021          .db "up!",0
0072f9 72ed          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
0072fa 72fb          .dw PFA_UP_STORE
                 PFA_UP_STORE:
0072fb 012c          movw upl, tosl
0072fc 9189
0072fd 9199          loadtos
0072fe cd06          jmp_ DO_NEXT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
0072ff ff03          .dw $ff03
007300 6d31
007301 0073          .db "1ms",0
007302 72f6          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
007303 7304          .dw PFA_1MS
                 PFA_1MS:
007304 eae0
007305 e0ff
007306 9731
007307 f7f1          delay 1000
007308 ccfc          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
007309 ff03          .dw $ff03
00730a 3e32
00730b 0072          .db "2>r",0
00730c 72ff          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
00730d 730e          .dw PFA_2TO_R
                 PFA_2TO_R:
00730e 01fc          movw zl, tosl
00730f 9189
007310 9199          loadtos
007311 939f          push tosh
007312 938f          push tosl
007313 93ff          push zh
007314 93ef          push zl
007315 9189
007316 9199          loadtos
007317 cced          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
007318 ff03          .dw $ff03
007319 7232
00731a 003e          .db "2r>",0
00731b 7309          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
00731c 731d          .dw PFA_2R_FROM
                 PFA_2R_FROM:
00731d 939a
00731e 938a          savetos
00731f 91ef          pop zl
007320 91ff          pop zh
007321 918f          pop tosl
007322 919f          pop tosh
007323 939a
007324 938a          savetos
007325 01cf          movw tosl, zl
007326 ccde          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
007327 ff02          .dw $ff02
007328 6521          .db "!e"
007329 7318          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
00732a 732b          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
00732b 01fc          movw zl, tosl
00732c 9189
00732d 9199          loadtos
00732e b72f          in_ temp2, SREG
00732f 94f8          cli
007330 d028          rcall PFA_FETCHE2
007331 b500          in_  temp0, EEDR
007332 1708          cp temp0,tosl
007333 f009          breq PFA_STOREE3
007334 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
007335 9631          adiw zl,1
007336 d022          rcall PFA_FETCHE2
007337 b500          in_  temp0, EEDR
007338 1709          cp temp0,tosh
007339 f011          breq PFA_STOREE4
00733a 2f89          mov tosl, tosh
00733b d004          rcall PFA_STOREE1
                 PFA_STOREE4:
00733c bf2f          out_ SREG, temp2
00733d 9189
00733e 9199          loadtos
00733f ccc5          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
007340 99f9          sbic EECR, EEPE
007341 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
007342 b707          in_ temp0, SPMCSR
007343 fd00          sbrc temp0,SPMEN
007344 cffd          rjmp PFA_STOREE2
                 
007345 bdf2          out_ EEARH,zh
007346 bde1          out_ EEARL,zl
007347 bd80          out_ EEDR, tosl
007348 9afa          sbi EECR,EEMPE
007349 9af9          sbi EECR,EEPE
                 
00734a 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
00734b ff02          .dw $ff02
00734c 6540          .db "@e"
00734d 7327          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00734e 734f          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00734f b72f          in_ temp2, SREG
007350 94f8          cli
007351 01fc          movw zl, tosl
007352 d006          rcall PFA_FETCHE2
007353 b580          in_ tosl, EEDR
                 
007354 9631          adiw zl,1
                 
007355 d003          rcall PFA_FETCHE2
007356 b590          in_  tosh, EEDR
007357 bf2f          out_ SREG, temp2
007358 ccac          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
007359 99f9          sbic EECR, EEPE
00735a cffe          rjmp PFA_FETCHE2
                 
00735b bdf2          out_ EEARH,zh
00735c bde1          out_ EEARL,zl
                 
00735d 9af8          sbi EECR,EERE
00735e 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
00735f ff02          .dw $ff02
007360 6921          .db "!i"
007361 734b          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
007362 7be8          .dw PFA_DODEFER1
                 PFA_STOREI:
007363 0068          .dw EE_STOREI
007364 7b89          .dw XT_EDEFERFETCH
007365 7b93          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
007366 ff09          .dw $ff09
007367 2128
007368 2d69
007369 726e
00736a 7777
00736b 0029          .db "(!i-nrww)",0
00736c 735f          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
00736d 736e          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
00736e b71f        in temp1,SREG
00736f 931f        push temp1
007370 94f8        cli
                 
007371 019c        movw temp2, tosl ; save the (word) address
007372 9189
007373 9199        loadtos          ; get the new value for the flash cell
007374 93af        push xl
007375 93bf        push xh
007376 93cf        push yl
007377 93df        push yh
007378 d009        rcall DO_STOREI_atmega
007379 91df        pop yh
00737a 91cf        pop yl
00737b 91bf        pop xh
00737c 91af        pop xl
                   ; finally clear the stack
00737d 9189
00737e 9199        loadtos
00737f 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
007380 bf1f        out SREG,temp1
                 
007381 cc83        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
007382 d011        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
007383 94e0        com temp4
007384 94f0        com temp5
007385 218e        and tosl, temp4
007386 219f        and tosh, temp5
007387 2b98        or tosh, tosl
007388 f021        breq DO_STOREI_writepage 
007389 94b3          inc erase_counter
00738a 01f9          movw zl, temp2
00738b e002          ldi temp0,(1<<PGERS)
00738c d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
00738d 01f9        movw zl, temp2
00738e e004        ldi temp0,(1<<PGWRT)
00738f d01d        rcall dospm
                 
                   ; reenable RWW section
007390 01f9        movw zl, temp2
007391 e100        ldi temp0,(1<<RWWSRE)
007392 d01a        rcall dospm
007393 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
007394 01f9        movw zl, temp2
                   ; get the beginning of page
007395 78e0        andi zl,low(pagemask)
007396 7fff        andi zh,high(pagemask)
007397 01ef        movw y, z
                   ; loop counter (in words)
007398 e8a0        ldi xl,low(pagesize)
007399 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
00739a 01fe        movw z, y
00739b 0fee
00739c 1fff
00739d 9145
00739e 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
00739f 01fe        movw z, y
0073a0 17e2        cp zl, temp2
0073a1 07f3        cpc zh, temp3
0073a2 f011        breq pageload_newdata
0073a3 010a          movw r0, temp6
0073a4 c002          rjmp pageload_cont
                 pageload_newdata:
0073a5 017a          movw temp4, temp6
0073a6 010c          movw r0, tosl
                 pageload_cont:
0073a7 2700        clr temp0
0073a8 d004        rcall dospm
0073a9 9621        adiw y, 1
0073aa 9711        sbiw x, 1
0073ab f771        brne pageload_loop
                 
                 pageload_done:
0073ac 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
0073ad 99f9        sbic EECR, EEPE
0073ae cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
0073af b717        in_  temp1, SPMCSR
0073b0 fd10        sbrc temp1, SPMEN
0073b1 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
0073b2 0fee
0073b3 1fff        writeflashcell
                   ; execute spm
0073b4 6001        ori temp0, (1<<SPMEN)
0073b5 bf07        out_ SPMCSR,temp0
0073b6 95e8        spm
0073b7 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
0073b8 ff02          .dw $ff02
0073b9 6940          .db "@i"
0073ba 7366          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
0073bb 73bc          .dw PFA_FETCHI
                 PFA_FETCHI:
0073bc 01fc          movw zl, tosl
0073bd 0fee
0073be 1fff
0073bf 9185
0073c0 9195          readflashcell tosl,tosh
0073c1 cc43          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .include "dict/core_8k.inc"
                 
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
0073c2 ff03          .dw $ff03
0073c3 3e6e
0073c4 0072          .db "n>r",0
0073c5 73b8          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
0073c6 73c7          .dw PFA_N_TO_R
                 PFA_N_TO_R:
0073c7 01fc          movw zl, tosl
0073c8 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
0073c9 9189
0073ca 9199          loadtos
0073cb 939f          push tosh
0073cc 938f          push tosl
0073cd 950a          dec temp0
0073ce f7d1          brne PFA_N_TO_R1
0073cf 93ef          push zl
0073d0 93ff          push zh
0073d1 9189
0073d2 9199          loadtos
0073d3 cc31          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
0073d4 ff03          .dw $ff03
0073d5 726e
0073d6 003e          .db "nr>",0
0073d7 73c2          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
0073d8 73d9          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
0073d9 939a
0073da 938a          savetos
0073db 91ff          pop zh
0073dc 91ef          pop zl
0073dd 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
0073de 918f          pop tosl
0073df 919f          pop tosh
0073e0 939a
0073e1 938a          savetos
0073e2 950a          dec temp0
0073e3 f7d1          brne PFA_N_R_FROM1
0073e4 01cf          movw tosl, zl
0073e5 cc1f          jmp_ DO_NEXT
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
0073e6 ff03          .dw $ff03
0073e7 3264
0073e8 002a          .db "d2*",0
0073e9 73d4          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
0073ea 73eb          .dw PFA_D2STAR
                 PFA_D2STAR:
0073eb 9109          ld temp0, Y+
0073ec 9119          ld temp1, Y+
0073ed 0f00          lsl temp0
0073ee 1f11          rol temp1
0073ef 1f88          rol tosl
0073f0 1f99          rol tosh
0073f1 931a          st -Y, temp1
0073f2 930a          st -Y, temp0
0073f3 cc11          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
0073f4 ff03          .dw $ff03
0073f5 3264
0073f6 002f          .db "d2/",0
0073f7 73e6          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
0073f8 73f9          .dw PFA_D2SLASH
                 PFA_D2SLASH:
0073f9 9109          ld temp0, Y+
0073fa 9119          ld temp1, Y+
0073fb 9595          asr tosh
0073fc 9587          ror tosl
0073fd 9517          ror temp1
0073fe 9507          ror temp0
0073ff 931a          st -Y, temp1
007400 930a          st -Y, temp0
007401 cc03          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
007402 ff02          .dw $ff02
007403 2b64          .db "d+"
007404 73f4          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
007405 7406          .dw PFA_DPLUS
                 PFA_DPLUS:
007406 9129          ld temp2, Y+
007407 9139          ld temp3, Y+
                 
007408 90e9          ld temp4, Y+
007409 90f9          ld temp5, Y+
00740a 9149          ld temp6, Y+
00740b 9159          ld temp7, Y+
                 
00740c 0f24          add temp2, temp6
00740d 1f35          adc temp3, temp7
00740e 1d8e          adc tosl, temp4
00740f 1d9f          adc tosh, temp5
                     
007410 933a          st -Y, temp3
007411 932a          st -Y, temp2
007412 cbf2          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
007413 ff02          .dw $ff02
007414 2d64          .db "d-"
007415 7402          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
007416 7417          .dw PFA_DMINUS
                 PFA_DMINUS:
007417 9129          ld temp2, Y+
007418 9139          ld temp3, Y+
                 
007419 90e9          ld temp4, Y+
00741a 90f9          ld temp5, Y+
00741b 9149          ld temp6, Y+
00741c 9159          ld temp7, Y+
                 
00741d 1b42          sub temp6, temp2
00741e 0b53          sbc temp7, temp3
00741f 0ae8          sbc temp4, tosl
007420 0af9          sbc temp5, tosh
                 
007421 935a          st -Y, temp7
007422 934a          st -Y, temp6
007423 01c7          movw tosl, temp4
007424 cbe0          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
007425 ff07          .dw $ff07
007426 6964
007427 766e
007428 7265
007429 0074          .db "dinvert",0
00742a 7413          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
00742b 742c          .dw PFA_DINVERT
                 PFA_DINVERT:
00742c 9109          ld temp0, Y+
00742d 9119          ld temp1, Y+
00742e 9580          com tosl
00742f 9590          com tosh
007430 9500          com temp0
007431 9510          com temp1
007432 931a          st -Y, temp1
007433 930a          st -Y, temp0
007434 cbd0          jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
007435 ff02          .dw $ff02
007436 3d64          .db "d="
007437 7425          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
007438 7001          .dw DO_COLON
                 PFA_DEQUAL:
007439 7416          .dw XT_DMINUS
00743a 7217          .dw XT_OR
00743b 7115          .dw XT_ZEROEQUAL
00743c 701b          .dw XT_EXIT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
00743d ff02          .dw $ff02
00743e 2e75          .db "u."
00743f 7435          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
007440 7001          .dw DO_COLON
                 PFA_UDOT:
                 .endif
007441 714f          .dw XT_ZERO
007442 772d          .dw XT_UDDOT
007443 701b          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
007444 ff03          .dw $ff03
007445 2e75
007446 0072          .db "u.r",0
007447 743d          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
007448 7001          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
007449 714f          .dw XT_ZERO
00744a 70bf          .dw XT_SWAP
00744b 7736          .dw XT_UDDOTR
00744c 701b          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
00744d ff0d          .dw $ff0d
00744e 6873
00744f 776f
007450 772d
007451 726f
007452 6c64
007453 7369
007454 0074          .db "show-wordlist",0
007455 7444          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
007456 7001          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
007457 7038          .dw XT_DOLITERAL
007458 745c          .dw XT_SHOWWORD
007459 70bf          .dw XT_SWAP
00745a 7c2c          .dw XT_TRAVERSEWORDLIST
00745b 701b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
00745c 7001          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
00745d 7c47          .dw XT_NAME2STRING
00745e 77a3          .dw XT_ITYPE
00745f 77e5          .dw XT_SPACE         ; ( -- addr n)
007460 7146          .dw XT_TRUE
007461 701b          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_WORDS:
007462 ff05          .dw $ff05
007463 6f77
007464 6472
007465 0073          .db "words",0
007466 744d          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
007467 7001          .dw DO_COLON
                 PFA_WORDS:
                 .endif
007468 7038          .dw XT_DOLITERAL
007469 004e          .dw CFG_ORDERLISTLEN+2
00746a 734e          .dw XT_FETCHE
00746b 7456          .dw XT_SHOWWORDLIST
00746c 701b          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
00746d ff04          .dw $ff04
00746e 692b
00746f 746e          .db "+int"
007470 7462          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
007471 7472          .dw PFA_INTON
                 PFA_INTON:
007472 9478          sei
007473 cb91          jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
007474 ff04          .dw $ff04
007475 692d
007476 746e          .db "-int"
007477 746d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
007478 7479          .dw PFA_INTOFF
                 PFA_INTOFF:
007479 94f8          cli
00747a cb8a          jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
00747b ff04          .dw $ff04
00747c 6e69
00747d 2174          .db "int!"
00747e 7474          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
00747f 7001          .dw DO_COLON
                 PFA_INTSTORE:
007480 7038          .dw XT_DOLITERAL
007481 0000          .dw intvec
007482 7198          .dw XT_PLUS
007483 732a          .dw XT_STOREE
007484 701b          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
007485 ff04          .dw $ff04
007486 6e69
007487 4074          .db "int@"
007488 747b          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
007489 7001          .dw DO_COLON
                 PFA_INTFETCH:
00748a 7038          .dw XT_DOLITERAL
00748b 0000          .dw intvec
00748c 7198          .dw XT_PLUS
00748d 734e          .dw XT_FETCHE
00748e 701b          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
00748f ff08          .dw $ff08
007490 6e69
007491 2d74
007492 7274
007493 7061          .db "int-trap"
007494 7485          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
007495 7496          .dw PFA_INTTRAP
                 PFA_INTTRAP:
007496 9380 0116     sts intcur, tosl
007498 9189
007499 9199          loadtos
00749a 9468          set ; set the interrupt flag for the inner interpreter
00749b cb69          jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
00749c 7001          .dw DO_COLON
                 PFA_ISREXEC:
00749d 7038          .dw XT_DOLITERAL
00749e 0116          .dw intcur
00749f 7093          .dw XT_CFETCH
0074a0 7038          .dw XT_DOLITERAL
0074a1 0000          .dw intvec
0074a2 7198          .dw XT_PLUS
0074a3 734e          .dw XT_FETCHE
0074a4 7025          .dw XT_EXECUTE
0074a5 74a7          .dw XT_ISREND
0074a6 701b          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
0074a7 74a8          .dw PFA_ISREND
                 PFA_ISREND:
0074a8 d001          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
0074a9 cb5b          jmp_ DO_NEXT
                 PFA_ISREND1:
0074aa 9518          reti
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
0074ab ff04          .dw $ff04
0074ac 6970
0074ad 6b63          .db "pick"
0074ae 748f          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
0074af 7001          .dw DO_COLON
                 PFA_PICK:
                 .endif
0074b0 722a          .dw XT_1PLUS
0074b1 7558          .dw XT_CELLS
0074b2 727c          .dw XT_SP_FETCH
0074b3 7198          .dw XT_PLUS
0074b4 7074          .dw XT_FETCH
0074b5 701b          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
0074b6 0002          .dw $0002
0074b7 222e          .db ".",$22
0074b8 74ab          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
0074b9 7001          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
0074ba 74c1          .dw XT_SQUOTE
0074bb 01a6          .dw XT_COMPILE
0074bc 77a3          .dw XT_ITYPE
0074bd 701b          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
0074be 0002        .dw $0002
0074bf 2273        .db "s",$22
0074c0 74b6        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
0074c1 7001          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
0074c2 7038          .dw XT_DOLITERAL
0074c3 0022          .dw 34   ; 0x22 
0074c4 7983          .dw XT_PARSE       ; ( -- addr n)
0074c5 754b          .dw XT_STATE
0074c6 7074          .dw XT_FETCH
0074c7 7031          .dw XT_DOCONDBRANCH
0074c8 74ca          DEST(PFA_SQUOTE1)
0074c9 01d2            .dw XT_SLITERAL
                 PFA_SQUOTE1:
0074ca 701b          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
0074cb ff04          .dw $ff04
0074cc 6966
0074cd 6c6c          .db "fill"
0074ce 74be          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
0074cf 7001          .dw DO_COLON
                 PFA_FILL:
0074d0 70dc          .dw XT_ROT
0074d1 70dc          .dw XT_ROT
0074d2 70b4
0074d3 7031          .dw XT_QDUP,XT_DOCONDBRANCH
0074d4 74dc          DEST(PFA_FILL2)
0074d5 7d34          .dw XT_BOUNDS
0074d6 728a          .dw XT_DODO
                 PFA_FILL1:
0074d7 70ac          .dw XT_DUP
0074d8 729b          .dw XT_I
0074d9 7088          .dw XT_CSTORE  ; ( -- c c-addr)
0074da 72b8          .dw XT_DOLOOP
0074db 74d7          .dw PFA_FILL1
                 PFA_FILL2:
0074dc 70d4          .dw XT_DROP
0074dd 701b          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
0074de ff0b          .dw $ff0b
0074df 6e65
0074e0 6976
0074e1 6f72
0074e2 6d6e
0074e3 6e65
0074e4 0074          .db "environment",0
0074e5 74cb          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
0074e6 7043          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
0074e7 0046          .dw CFG_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
0074e8 ff09          .dw $ff09
0074e9 6f77
0074ea 6472
0074eb 696c
0074ec 7473
0074ed 0073          .db "wordlists",0
0074ee 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
0074ef 7001          .dw DO_COLON
                 PFA_ENVWORDLISTS:
0074f0 7038          .dw XT_DOLITERAL
0074f1 0008          .dw NUMWORDLISTS
0074f2 701b          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
0074f3 ff04          .dw $ff04
0074f4 702f
0074f5 6461          .db "/pad"
0074f6 74e8          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
0074f7 7001          .dw DO_COLON
                 PFA_ENVSLASHPAD:
0074f8 727c          .dw XT_SP_FETCH
0074f9 7584          .dw XT_PAD
0074fa 718e          .dw XT_MINUS
0074fb 701b          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENVSLASHHOLD:
0074fc ff05          .dw $ff05
0074fd 682f
0074fe 6c6f
0074ff 0064          .db "/hold",0
007500 74f3          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
007501 7001          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
                 .endif
007502 7584          .dw XT_PAD
007503 75bf          .dw XT_HERE
007504 718e          .dw XT_MINUS
007505 701b          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
007506 ff0a          .dw $ff0a
007507 6f66
007508 7472
007509 2d68
00750a 616e
00750b 656d          .db "forth-name"
00750c 74fc          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
00750d 7001          .dw DO_COLON
                 PFA_EN_FORTHNAME:
00750e 7770          .dw XT_DOSLITERAL
00750f 0007          .dw 7
                 .endif
007510 6d61
007511 6f66
007512 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
007513 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
007514 701b          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
007515 ff07          .dw $ff07
007516 6576
007517 7372
007518 6f69
007519 006e          .db "version",0
00751a 7506          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
00751b 7001          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
00751c 7038          .dw XT_DOLITERAL
00751d 003d          .dw 61
00751e 701b          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
00751f ff03          .dw $ff03
007520 7063
007521 0075          .db "cpu",0
007522 7515          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
007523 7001          .dw DO_COLON
                 PFA_EN_CPU:
                 .endif
007524 7038          .dw XT_DOLITERAL
007525 003b          .dw mcu_name
007526 77cf          .dw XT_ICOUNT
007527 701b          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
007528 ff08          .dw $ff08
007529 636d
00752a 2d75
00752b 6e69
00752c 6f66          .db "mcu-info"
00752d 751f          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
00752e 7001          .dw DO_COLON
                 PFA_EN_MCUINFO:
00752f 7038          .dw XT_DOLITERAL
007530 0037          .dw mcu_info
007531 701b          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_ENVUSERSIZE:
007532 ff05          .dw $ff05
007533 752f
007534 6573
007535 0072          .db "/user",0
007536 7528          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
007537 7001          .dw DO_COLON
                 PFA_ENVUSERSIZE:
                 .endif
007538 7038          .dw XT_DOLITERAL
007539 0026          .dw SYSUSERSIZE + APPUSERSIZE
00753a 701b          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
00753b ff05          .dw $ff05
00753c 5f66
00753d 7063
00753e 0075          .db "f_cpu",0
00753f 74de          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
007540 7001          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
007541 7038          .dw XT_DOLITERAL
007542 2400          .dw (F_CPU % 65536)
007543 7038          .dw XT_DOLITERAL
007544 00f4          .dw (F_CPU / 65536)
007545 701b          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
007546 ff05          .dw $ff05
007547 7473
007548 7461
007549 0065          .db "state",0
00754a 753b          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00754b 7043          .dw PFA_DOVARIABLE
                 PFA_STATE:
00754c 011f          .dw ram_state
                 
                 .dseg
00011f           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
00754d ff04          .dw $ff04
00754e 6162
00754f 6573          .db "base"
007550 7546          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
007551 7053          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
007552 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
007553 ff05          .dw $ff05
007554 6563
007555 6c6c
007556 0073          .db "cells",0
007557 754d          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
007558 7207          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
007559 ff05          .dw $ff05
00755a 6563
00755b 6c6c
00755c 002b          .db "cell+",0
00755d 7553          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
00755e 755f          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
00755f 9602          adiw tosl, CELLSIZE
007560 caa4          jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
007561 ff04          .dw $ff04
007562 6432
007563 7075          .db "2dup"
007564 7559          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
007565 7001          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
007566 70ca          .dw XT_OVER
007567 70ca          .dw XT_OVER
007568 701b          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
007569 ff05          .dw $ff05
00756a 6432
00756b 6f72
00756c 0070          .db "2drop",0
00756d 7561          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
00756e 7001          .dw DO_COLON
                 PFA_2DROP:
                 .endif
00756f 70d4          .dw XT_DROP
007570 70d4          .dw XT_DROP
007571 701b          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
007572 ff04          .dw $ff04
007573 7574
007574 6b63          .db "tuck"
007575 7569          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
007576 7001          .dw DO_COLON
                 PFA_TUCK:
                 .endif
007577 70bf          .dw XT_SWAP
007578 70ca          .dw XT_OVER
007579 701b          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
00757a ff03          .dw $ff03
00757b 693e
00757c 006e          .db ">in",0
00757d 7572          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
00757e 7053          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
00757f 0018          .dw USER_TO_IN
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PAD:
007580 ff03          .dw $ff03
007581 6170
007582 0064          .db "pad",0
007583 757a          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
007584 7001          .dw DO_COLON
                 PFA_PAD:
                 .endif
007585 75bf          .dw XT_HERE
007586 7038          .dw XT_DOLITERAL
007587 0028          .dw 40
007588 7198          .dw XT_PLUS
007589 701b          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMIT:
00758a ff04          .dw $ff04
00758b 6d65
00758c 7469          .db "emit"
00758d 7580          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
00758e 7be8          .dw PFA_DODEFER1
                 PFA_EMIT:
                 .endif
00758f 000e          .dw USER_EMIT
007590 7bb1          .dw XT_UDEFERFETCH
007591 7bbd          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMITQ:
007592 ff05          .dw $ff05
007593 6d65
007594 7469
007595 003f          .db "emit?",0
007596 758a          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
007597 7be8          .dw PFA_DODEFER1
                 PFA_EMITQ:
                 .endif
007598 0010          .dw USER_EMITQ
007599 7bb1          .dw XT_UDEFERFETCH
00759a 7bbd          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEY:
00759b ff03          .dw $ff03
00759c 656b
00759d 0079          .db "key",0
00759e 7592          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
00759f 7be8          .dw PFA_DODEFER1
                 PFA_KEY:
                 .endif
0075a0 0012          .dw USER_KEY
0075a1 7bb1          .dw XT_UDEFERFETCH
0075a2 7bbd          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEYQ:
0075a3 ff04          .dw $ff04
0075a4 656b
0075a5 3f79          .db "key?"
0075a6 759b          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
0075a7 7be8          .dw PFA_DODEFER1
                 PFA_KEYQ:
                 .endif
0075a8 0014          .dw USER_KEYQ
0075a9 7bb1          .dw XT_UDEFERFETCH
0075aa 7bbd          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
0075ab ff02          .dw $ff02
0075ac 7064          .db "dp"
0075ad 75a3          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
0075ae 706a          .dw PFA_DOVALUE1
                 PFA_DP:
0075af 003a          .dw CFG_DP
0075b0 7b89          .dw XT_EDEFERFETCH
0075b1 7b93          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
0075b2 ff05          .dw $ff05
0075b3 6865
0075b4 7265
0075b5 0065          .db "ehere",0
0075b6 75ab          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
0075b7 706a          .dw PFA_DOVALUE1
                 PFA_EHERE:
0075b8 003e          .dw EE_EHERE
0075b9 7b89          .dw XT_EDEFERFETCH
0075ba 7b93          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
0075bb ff04          .dw $ff04
0075bc 6568
0075bd 6572          .db "here"
0075be 75b2          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
0075bf 706a          .dw PFA_DOVALUE1
                 PFA_HERE:
0075c0 003c          .dw EE_HERE
0075c1 7b89          .dw XT_EDEFERFETCH
0075c2 7b93          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
0075c3 ff05          .dw $ff05
0075c4 6c61
0075c5 6f6c
0075c6 0074          .db "allot",0
0075c7 75bb          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
0075c8 7001          .dw DO_COLON
                 PFA_ALLOT:
0075c9 75bf          .dw XT_HERE
0075ca 7198          .dw XT_PLUS
0075cb 7b6e          .dw XT_DOTO
0075cc 75c0          .dw PFA_HERE
0075cd 701b          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
0075ce ff03          .dw $ff03
0075cf 6962
0075d0 006e          .db "bin",0
0075d1 75c3          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
0075d2 7001          .dw DO_COLON
                 PFA_BIN:
                 .endif
0075d3 7d61          .dw XT_TWO
0075d4 7551          .dw XT_BASE
0075d5 707c          .dw XT_STORE
0075d6 701b          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
0075d7 ff07          .dw $ff07
0075d8 6564
0075d9 6963
0075da 616d
0075db 006c          .db "decimal",0
0075dc 75ce          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
0075dd 7001          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
0075de 7038          .dw XT_DOLITERAL
0075df 000a          .dw 10
0075e0 7551          .dw XT_BASE
0075e1 707c          .dw XT_STORE
0075e2 701b          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
0075e3 ff03          .dw $ff03
0075e4 6568
0075e5 0078          .db "hex",0
0075e6 75d7          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
0075e7 7001          .dw DO_COLON
                 PFA_HEX:
                 .endif
0075e8 7038          .dw XT_DOLITERAL
0075e9 0010          .dw 16
0075ea 7551          .dw XT_BASE
0075eb 707c          .dw XT_STORE
0075ec 701b          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
0075ed ff02          .dw $ff02
0075ee 6c62          .db "bl"
0075ef 75e3          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
0075f0 7043          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
0075f1 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
0075f2 ff07          .dw $ff07
0075f3 7574
0075f4 6e72
0075f5 656b
0075f6 0079          .db "turnkey",0
0075f7 75ed          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
0075f8 7be8          .dw PFA_DODEFER1
                 PFA_TURNKEY:
0075f9 0044          .dw CFG_TURNKEY
0075fa 7b89          .dw XT_EDEFERFETCH
0075fb 7b93          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
0075fc ff04          .dw $ff04
0075fd 6d2f
0075fe 646f          .db "/mod"
0075ff 75f2          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
007600 7601          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
007601 019c          movw temp2, tosl
                     
007602 9109          ld temp0, Y+
007603 9119          ld temp1, Y+
                 
007604 2f41          mov	temp6,temp1	;move dividend High to sign register
007605 2743          eor	temp6,temp3	;xor divisor High with sign register
007606 ff17          sbrs	temp1,7	;if MSB in dividend set
007607 c004          rjmp	PFA_SLASHMOD_1
007608 9510          com	temp1		;    change sign of dividend
007609 9500          com	temp0		
00760a 5f0f          subi	temp0,low(-1)
00760b 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
00760c ff37          sbrs	temp3,7	;if MSB in divisor set
00760d c004          rjmp	PFA_SLASHMOD_2
00760e 9530          com	temp3		;    change sign of divisor
00760f 9520          com	temp2		
007610 5f2f          subi	temp2,low(-1)
007611 4f3f          sbci	temp3,high(-1)
007612 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
007613 18ff          sub	temp5,temp5;clear remainder High byte and carry
007614 e151          ldi	temp7,17	;init loop counter
                 
007615 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
007616 1f11          rol	temp1
007617 955a          dec	temp7		;decrement counter
007618 f439          brne	PFA_SLASHMOD_5		;if done
007619 ff47          sbrs	temp6,7		;    if MSB in sign register set
00761a c004          rjmp	PFA_SLASHMOD_4
00761b 9510          com	temp1	;        change sign of result
00761c 9500          com	temp0
00761d 5f0f          subi	temp0,low(-1)
00761e 4f1f          sbci	temp1,high(-1)
00761f c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
007620 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
007621 1cff          rol	temp5
007622 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
007623 0af3          sbc	temp5,temp3	;
007624 f420          brcc	PFA_SLASHMOD_6		;if result negative
007625 0ee2          add	temp4,temp2	;    restore remainder
007626 1ef3          adc	temp5,temp3
007627 9488          clc			;    clear carry to be shifted into result
007628 cfec          rjmp	PFA_SLASHMOD_3		;else
007629 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
00762a cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
00762b 92fa          st -Y,temp5
00762c 92ea          st -Y,temp4
                 
                     ; put quotient on stack
00762d 01c8          movw tosl, temp0
00762e c9d6          jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
00762f ff05          .dw $ff05
007630 2f75
007631 6f6d
007632 0064          .db "u/mod",0
007633 75fc          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
007634 7001          .dw DO_COLON
                 PFA_USLASHMOD:
007635 70fa          .dw XT_TO_R
007636 714f          .dw XT_ZERO
007637 70f1          .dw XT_R_FROM
007638 71bd          .dw XT_UMSLASHMOD
007639 701b          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
00763a ff06          .dw $ff06
00763b 656e
00763c 6167
00763d 6574          .db "negate"
00763e 762f          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
00763f 7001          .dw DO_COLON
                 PFA_NEGATE:
007640 71f8          .dw XT_INVERT
007641 722a          .dw XT_1PLUS
007642 701b          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
007643 ff01          .dw $ff01
007644 002f          .db "/",0
007645 763a          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
007646 7001          .dw DO_COLON
                 PFA_SLASH:
                 .endif
007647 7600          .dw XT_SLASHMOD
007648 70eb          .dw XT_NIP
007649 701b          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
00764a ff03          .dw $ff03
00764b 6f6d
00764c 0064          .db "mod",0
00764d 7643          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
00764e 7001          .dw DO_COLON
                 PFA_MOD:
                 .endif
00764f 7600          .dw XT_SLASHMOD
007650 70d4          .dw XT_DROP
007651 701b          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
007652 ff03          .dw $ff03
007653 6261
007654 0073          .db "abs",0
007655 764a          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
007656 7657          .dw PFA_ABS
                 PFA_ABS:
007657 2399          tst tosh
007658 f41a          brpl PFA_ABS1
007659 9580          com tosl
00765a 9590          com tosh
00765b 9601          adiw tosl, 1
                 PFA_ABS1:
00765c c9a8          jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
00765d ff03          .dw $ff03
00765e 696d
00765f 006e          .db "min",0
007660 7652          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
007661 7001          .dw DO_COLON
                 PFA_MIN:
                 .endif
007662 7565          .dw XT_2DUP
007663 7173          .dw XT_GREATER
007664 7031          .dw XT_DOCONDBRANCH
007665 7667          DEST(PFA_MIN1)
007666 70bf          .dw XT_SWAP
                 PFA_MIN1:
007667 70d4          .dw XT_DROP
007668 701b          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
007669 ff03          .dw $ff03
00766a 616d
00766b 0078          .db "max",0
00766c 765d          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
00766d 7001          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
00766e 7565          .dw XT_2DUP
00766f 7169          .dw XT_LESS
007670 7031          .dw XT_DOCONDBRANCH
007671 7673          DEST(PFA_MAX1)
007672 70bf          .dw XT_SWAP
                 PFA_MAX1:
007673 70d4          .dw XT_DROP
007674 701b          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
007675 ff06          .dw $ff06
007676 6977
007677 6874
007678 6e69          .db "within"
007679 7669          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
00767a 7001          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
00767b 70ca          .dw XT_OVER
00767c 718e          .dw XT_MINUS
00767d 70fa          .dw XT_TO_R
00767e 718e          .dw XT_MINUS
00767f 70f1          .dw XT_R_FROM
007680 7157          .dw XT_ULESS
007681 701b          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
007682 ff07          .dw $ff07 
007683 6f74
007684 7075
007685 6570
007686 0072          .db "toupper",0
007687 7675          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
007688 7001          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
007689 70ac          .dw XT_DUP 
00768a 7038          .dw XT_DOLITERAL 
00768b 0061          .dw 'a' 
00768c 7038          .dw XT_DOLITERAL 
00768d 007b          .dw 'z'+1
00768e 767a          .dw XT_WITHIN 
00768f 7031          .dw XT_DOCONDBRANCH
007690 7694          DEST(PFA_TOUPPER0)
007691 7038          .dw XT_DOLITERAL
007692 00df          .dw 223 ; inverse of 0x20: 0xdf
007693 720e          .dw XT_AND 
                 PFA_TOUPPER0:
007694 701b          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
007695 ff07          .dw $ff07
007696 6f74
007697 6f6c
007698 6577
007699 0072          .db "tolower",0
00769a 7682          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
00769b 7001          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
00769c 70ac          .dw XT_DUP
00769d 7038          .dw XT_DOLITERAL
00769e 0041          .dw 'A'
00769f 7038          .dw XT_DOLITERAL
0076a0 005b          .dw 'Z'+1
0076a1 767a          .dw XT_WITHIN
0076a2 7031          .dw XT_DOCONDBRANCH
0076a3 76a7          DEST(PFA_TOLOWER0)
0076a4 7038          .dw XT_DOLITERAL
0076a5 0020          .dw 32
0076a6 7217          .dw XT_OR 
                 PFA_TOLOWER0:
0076a7 701b          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0076a8 ff03          .dw $ff03
0076a9 6c68
0076aa 0064          .db "hld",0
0076ab 7695          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
0076ac 7043          .dw PFA_DOVARIABLE
                 PFA_HLD:
0076ad 0121          .dw ram_hld
                 
                 .dseg
000121           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
0076ae ff04          .dw $ff04
0076af 6f68
0076b0 646c          .db "hold"
0076b1 76a8          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
0076b2 7001          .dw DO_COLON
                 PFA_HOLD:
                 .endif
0076b3 76ac          .dw XT_HLD
0076b4 70ac          .dw XT_DUP
0076b5 7074          .dw XT_FETCH
0076b6 7230          .dw XT_1MINUS
0076b7 70ac          .dw XT_DUP
0076b8 70fa          .dw XT_TO_R
0076b9 70bf          .dw XT_SWAP
0076ba 707c          .dw XT_STORE
0076bb 70f1          .dw XT_R_FROM
0076bc 7088          .dw XT_CSTORE
0076bd 701b          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
0076be ff02          .dw $ff02
0076bf 233c          .db "<#"
0076c0 76ae          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
0076c1 7001          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
0076c2 7584          .dw XT_PAD
0076c3 76ac          .dw XT_HLD
0076c4 707c          .dw XT_STORE
0076c5 701b          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
0076c6 ff01          .dw $ff01
0076c7 0023          .db "#",0
0076c8 76be          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
0076c9 7001          .dw DO_COLON
                 PFA_SHARP:
                 .endif
0076ca 7551          .dw XT_BASE
0076cb 7074          .dw XT_FETCH
0076cc 7746          .dw XT_UDSLASHMOD
0076cd 70dc          .dw XT_ROT
0076ce 7038          .dw XT_DOLITERAL
0076cf 0009          .dw 9
0076d0 70ca          .dw XT_OVER
0076d1 7169          .dw XT_LESS
0076d2 7031          .dw XT_DOCONDBRANCH
0076d3 76d7          DEST(PFA_SHARP1)
0076d4 7038          .dw XT_DOLITERAL
0076d5 0007          .dw 7
0076d6 7198          .dw XT_PLUS
                 PFA_SHARP1:
0076d7 7038          .dw XT_DOLITERAL
0076d8 0030          .dw 48 ; ASCII 0
0076d9 7198          .dw XT_PLUS
0076da 76b2          .dw XT_HOLD
0076db 701b          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
0076dc ff02          .dw $ff02
0076dd 7323          .db "#s"
0076de 76c6          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
0076df 7001          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
0076e0 76c9          .dw XT_SHARP
0076e1 7565          .dw XT_2DUP
0076e2 7217          .dw XT_OR
0076e3 7115          .dw XT_ZEROEQUAL
0076e4 7031          .dw XT_DOCONDBRANCH
0076e5 76e0          DEST(NUMS1) ; PFA_SHARP_S
0076e6 701b          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
0076e7 ff02          .dw $ff02
0076e8 3e23          .db "#>"
0076e9 76dc          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
0076ea 7001          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
0076eb 756e          .dw XT_2DROP
0076ec 76ac          .dw XT_HLD
0076ed 7074          .dw XT_FETCH
0076ee 7584          .dw XT_PAD
0076ef 70ca          .dw XT_OVER
0076f0 718e          .dw XT_MINUS
0076f1 701b          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
0076f2 ff04          .dw $ff04
0076f3 6973
0076f4 6e67          .db "sign"
0076f5 76e7          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
0076f6 7001          .dw DO_COLON
                 PFA_SIGN:
                 .endif
0076f7 711c          .dw XT_ZEROLESS
0076f8 7031          .dw XT_DOCONDBRANCH
0076f9 76fd          DEST(PFA_SIGN1)
0076fa 7038          .dw XT_DOLITERAL
0076fb 002d          .dw 45 ; ascii -
0076fc 76b2          .dw XT_HOLD
                 PFA_SIGN1:
0076fd 701b          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
0076fe ff03          .dw $ff03
0076ff 2e64
007700 0072          .db "d.r",0
007701 76f2          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
007702 7001          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
007703 70fa          .dw XT_TO_R
007704 7576          .dw XT_TUCK
007705 7ca9          .dw XT_DABS
007706 76c1          .dw XT_L_SHARP
007707 76df          .dw XT_SHARP_S
007708 70dc          .dw XT_ROT
007709 76f6          .dw XT_SIGN
00770a 76ea          .dw XT_SHARP_G
00770b 70f1          .dw XT_R_FROM
00770c 70ca          .dw XT_OVER
00770d 718e          .dw XT_MINUS
00770e 77ee          .dw XT_SPACES
00770f 77fe          .dw XT_TYPE
007710 701b          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
007711 ff02          .dw $ff02
007712 722e          .db ".r"
007713 76fe          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
007714 7001          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
007715 70fa          .dw XT_TO_R
007716 7d3d          .dw XT_S2D
007717 70f1          .dw XT_R_FROM
007718 7702          .dw XT_DDOTR
007719 701b          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
00771a ff02          .dw $ff02
00771b 2e64          .db "d."
00771c 7711          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
00771d 7001          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
00771e 714f          .dw XT_ZERO
00771f 7702          .dw XT_DDOTR
007720 77e5          .dw XT_SPACE
007721 701b          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
007722 ff01          .dw $ff01
007723 002e          .db ".",0
007724 771a          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
007725 7001          .dw DO_COLON
                 PFA_DOT:
                 .endif
007726 7d3d          .dw XT_S2D
007727 771d          .dw XT_DDOT
007728 701b          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
007729 ff03          .dw $ff03
00772a 6475
00772b 002e          .db "ud.",0
00772c 7722          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
00772d 7001          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
00772e 714f          .dw XT_ZERO
00772f 7736          .dw XT_UDDOTR
007730 77e5          .dw XT_SPACE
007731 701b          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
007732 ff04          .dw $ff04
007733 6475
007734 722e          .db "ud.r"
007735 7729          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
007736 7001          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
007737 70fa          .dw XT_TO_R
007738 76c1          .dw XT_L_SHARP
007739 76df          .dw XT_SHARP_S
00773a 76ea          .dw XT_SHARP_G
00773b 70f1          .dw XT_R_FROM
00773c 70ca          .dw XT_OVER
00773d 718e          .dw XT_MINUS
00773e 77ee          .dw XT_SPACES
00773f 77fe          .dw XT_TYPE
007740 701b          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
007741 ff06          .dw $ff06
007742 6475
007743 6d2f
007744 646f          .db "ud/mod"
007745 7732          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
007746 7001          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
007747 70fa          .dw XT_TO_R
007748 714f          .dw XT_ZERO
007749 7103          .dw XT_R_FETCH
00774a 71bd          .dw XT_UMSLASHMOD
00774b 70f1          .dw XT_R_FROM
00774c 70bf          .dw XT_SWAP
00774d 70fa          .dw XT_TO_R
00774e 71bd          .dw XT_UMSLASHMOD
00774f 70f1          .dw XT_R_FROM
007750 701b          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
007751 ff06          .dw $ff06 
007752 6964
007753 6967
007754 3f74          .db "digit?"
007755 7741          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
007756 7001          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
007757 7688          .dw XT_TOUPPER
007758 70ac
007759 7038
00775a 0039
00775b 7173
00775c 7038
00775d 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
00775e 720e
00775f 7198
007760 70ac
007761 7038
007762 0140
007763 7173          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
007764 7038
007765 0107
007766 720e
007767 718e
007768 7038
007769 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
00776a 718e
00776b 70ac
00776c 7551
00776d 7074
00776e 7157          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
00776f 701b          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
007770 7001        .dw DO_COLON
                 PFA_DOSLITERAL:
007771 7103        .dw XT_R_FETCH   ; ( -- addr )
007772 77cf        .dw XT_ICOUNT
007773 70f1        .dw XT_R_FROM
007774 70ca        .dw XT_OVER     ; ( -- addr' n addr n)
007775 722a        .dw XT_1PLUS
007776 71ff        .dw XT_2SLASH   ; ( -- addr' n addr k )
007777 7198        .dw XT_PLUS     ; ( -- addr' n addr'' )
007778 722a        .dw XT_1PLUS
007779 70fa        .dw XT_TO_R     ; ( -- )
00777a 701b        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
00777b ff02        .dw $ff02
00777c 2c73        .db "s",$2c
00777d 7751        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
00777e 7001          .dw DO_COLON
                 PFA_SCOMMA:
00777f 70ac          .dw XT_DUP
007780 7782          .dw XT_DOSCOMMA
007781 701b          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
007782 7001          .dw DO_COLON
                 PFA_DOSCOMMA:
007783 01b1          .dw XT_COMMA
007784 70ac          .dw XT_DUP   ; ( --addr len len)
007785 71ff          .dw XT_2SLASH ; ( -- addr len len/2
007786 7576          .dw XT_TUCK   ; ( -- addr len/2 len len/2
007787 7206          .dw XT_2STAR  ; ( -- addr len/2 len len'
007788 718e          .dw XT_MINUS  ; ( -- addr len/2 rem
007789 70fa          .dw XT_TO_R
00778a 714f          .dw XT_ZERO
00778b 0270          .dw XT_QDOCHECK
00778c 7031          .dw XT_DOCONDBRANCH
00778d 7795          .dw PFA_SCOMMA2
00778e 728a          .dw XT_DODO
                 PFA_SCOMMA1:
00778f 70ac          .dw XT_DUP         ; ( -- addr addr )
007790 7074          .dw XT_FETCH       ; ( -- addr c1c2 )
007791 01b1          .dw XT_COMMA       ; ( -- addr )
007792 755e          .dw XT_CELLPLUS    ; ( -- addr+cell )
007793 72b8          .dw XT_DOLOOP
007794 778f          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
007795 70f1          .dw XT_R_FROM
007796 7123          .dw XT_GREATERZERO
007797 7031          .dw XT_DOCONDBRANCH
007798 779c          .dw PFA_SCOMMA3
007799 70ac            .dw XT_DUP     ; well, tricky
00779a 7093            .dw XT_CFETCH
00779b 01b1            .dw XT_COMMA
                 PFA_SCOMMA3:
00779c 70d4          .dw XT_DROP        ; ( -- )
00779d 701b          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
00779e ff05          .dw $ff05
00779f 7469
0077a0 7079
0077a1 0065          .db "itype",0
0077a2 777b          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
0077a3 7001          .dw DO_COLON
                 PFA_ITYPE:
0077a4 70ac          .dw XT_DUP    ; ( --addr len len)
0077a5 71ff          .dw XT_2SLASH ; ( -- addr len len/2
0077a6 7576          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0077a7 7206          .dw XT_2STAR  ; ( -- addr len/2 len len'
0077a8 718e          .dw XT_MINUS  ; ( -- addr len/2 rem
0077a9 70fa          .dw XT_TO_R
0077aa 714f          .dw XT_ZERO
0077ab 0270          .dw XT_QDOCHECK
0077ac 7031          .dw XT_DOCONDBRANCH
0077ad 77b7          .dw PFA_ITYPE2
0077ae 728a          .dw XT_DODO
                 PFA_ITYPE1:
0077af 70ac          .dw XT_DUP         ; ( -- addr addr )
0077b0 73bb          .dw XT_FETCHI      ; ( -- addr c1c2 )
0077b1 70ac          .dw XT_DUP
0077b2 77c4          .dw XT_LOWEMIT
0077b3 77c0          .dw XT_HIEMIT
0077b4 722a          .dw XT_1PLUS    ; ( -- addr+cell )
0077b5 72b8          .dw XT_DOLOOP
0077b6 77af          .dw PFA_ITYPE1
                 PFA_ITYPE2:
0077b7 70f1          .dw XT_R_FROM
0077b8 7123          .dw XT_GREATERZERO
0077b9 7031          .dw XT_DOCONDBRANCH
0077ba 77be          .dw PFA_ITYPE3
0077bb 70ac            .dw XT_DUP     ; make sure the drop below has always something to do
0077bc 73bb            .dw XT_FETCHI
0077bd 77c4            .dw XT_LOWEMIT
                 PFA_ITYPE3:
0077be 70d4          .dw XT_DROP
0077bf 701b          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
0077c0 7001          .dw DO_COLON
                 PFA_HIEMIT:
0077c1 72e8          .dw XT_BYTESWAP
0077c2 77c4          .dw XT_LOWEMIT
0077c3 701b          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
0077c4 7001          .dw DO_COLON
                 PFA_LOWEMIT:
0077c5 7038          .dw XT_DOLITERAL
0077c6 00ff          .dw $00ff
0077c7 720e          .dw XT_AND
0077c8 758e          .dw XT_EMIT
0077c9 701b          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
0077ca ff06          .dw $ff06
0077cb 6369
0077cc 756f
0077cd 746e          .db "icount"
0077ce 779e          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
0077cf 7001          .dw DO_COLON
                 PFA_ICOUNT:
0077d0 70ac          .dw XT_DUP
0077d1 722a          .dw XT_1PLUS
0077d2 70bf          .dw XT_SWAP
0077d3 73bb          .dw XT_FETCHI
0077d4 701b          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
0077d5 ff02          .dw 0xff02
0077d6 7263          .db "cr"
0077d7 77ca          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
0077d8 7001          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
0077d9 7038          .dw XT_DOLITERAL
0077da 000d          .dw 13
0077db 758e          .dw XT_EMIT
0077dc 7038          .dw XT_DOLITERAL
0077dd 000a          .dw 10
0077de 758e          .dw XT_EMIT
0077df 701b          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
0077e0 ff05          .dw $ff05
0077e1 7073
0077e2 6361
0077e3 0065          .db "space",0
0077e4 77d5          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
0077e5 7001          .dw DO_COLON
                 PFA_SPACE:
                 .endif
0077e6 75f0          .dw XT_BL
0077e7 758e          .dw XT_EMIT
0077e8 701b          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
0077e9 ff06          .dw $ff06
0077ea 7073
0077eb 6361
0077ec 7365          .db "spaces"
0077ed 77e0          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
0077ee 7001          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
0077ef 714f
0077f0 766d      	.DW XT_ZERO, XT_MAX
0077f1 70ac
0077f2 7031      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
0077f3 77f8              DEST(SPCS2)
0077f4 77e5
0077f5 7230
0077f6 702a              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
0077f7 77f1              DEST(SPCS1)
0077f8 70d4
0077f9 701b      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
0077fa ff04          .dw $ff04
0077fb 7974
0077fc 6570          .db "type"
0077fd 77e9          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
0077fe 7001          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
0077ff 7d34          .dw XT_BOUNDS
007800 0270          .dw XT_QDOCHECK
007801 7031          .dw XT_DOCONDBRANCH
007802 7809          DEST(PFA_TYPE2)
007803 728a          .dw XT_DODO
                 PFA_TYPE1:
007804 729b          .dw XT_I
007805 7093          .dw XT_CFETCH
007806 758e          .dw XT_EMIT
007807 72b8          .dw XT_DOLOOP
007808 7804          DEST(PFA_TYPE1)
                 PFA_TYPE2:
007809 701b          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
00780a ff01          .dw $ff01
00780b 0027          .db "'",0
00780c 77fa          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
00780d 7001          .dw DO_COLON
                 PFA_TICK:
                 .endif
00780e 79b0          .dw XT_PARSENAME
00780f 7aad          .dw XT_DORECOGNIZER
007810 7b0a          .dw XT_R_WORD
007811 7d55          .dw XT_EQUAL
007812 7031          .dw XT_DOCONDBRANCH
007813 7816          DEST(PFA_TICK1)
007814 70d4          .dw XT_DROP
007815 701b          .dw XT_EXIT
                 PFA_TICK1:
007816 7038          .dw XT_DOLITERAL
007817 fff3          .dw -13
007818 783c          .dw XT_THROW
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
007819 ff07          .dw $ff07
00781a 6168
00781b 646e
00781c 656c
00781d 0072          .db "handler",0
00781e 780a          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
00781f 7053          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
007820 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
007821 ff05          .dw $ff05
007822 6163
007823 6374
007824 0068          .db "catch",0
007825 7819          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
007826 7001          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
007827 727c          .dw XT_SP_FETCH
007828 70fa          .dw XT_TO_R
                     ; handler @ >r
007829 781f          .dw XT_HANDLER
00782a 7074          .dw XT_FETCH
00782b 70fa          .dw XT_TO_R
                     ; rp@ handler !
00782c 7265          .dw XT_RP_FETCH
00782d 781f          .dw XT_HANDLER
00782e 707c          .dw XT_STORE
00782f 7025          .dw XT_EXECUTE
                     ; r> handler !
007830 70f1          .dw XT_R_FROM
007831 781f          .dw XT_HANDLER
007832 707c          .dw XT_STORE
007833 70f1          .dw XT_R_FROM
007834 70d4          .dw XT_DROP
007835 714f          .dw XT_ZERO
007836 701b          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
007837 ff05          .dw $ff05
007838 6874
007839 6f72
00783a 0077          .db "throw",0
00783b 7821          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
00783c 7001          .dw DO_COLON
                 PFA_THROW:
                 .endif
00783d 70ac          .dw XT_DUP
00783e 7115          .dw XT_ZEROEQUAL
00783f 7031          .dw XT_DOCONDBRANCH
007840 7843          DEST(PFA_THROW1)
007841 70d4      	.dw XT_DROP
007842 701b      	.dw XT_EXIT
                 PFA_THROW1:
007843 781f          .dw XT_HANDLER
007844 7074          .dw XT_FETCH
007845 726f          .dw XT_RP_STORE
007846 70f1          .dw XT_R_FROM
007847 781f          .dw XT_HANDLER
007848 707c          .dw XT_STORE
007849 70f1          .dw XT_R_FROM
00784a 70bf          .dw XT_SWAP
00784b 70fa          .dw XT_TO_R
00784c 7285          .dw XT_SP_STORE
00784d 70d4          .dw XT_DROP
00784e 70f1          .dw XT_R_FROM    
00784f 701b          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
007850 ff05          .dw $ff05
007851 7363
007852 696b
007853 0070          .db "cskip",0
007854 7837          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
007855 7001          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
007856 70fa          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
007857 70ac          .dw XT_DUP            ; ( -- addr' n' n' )
007858 7031          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
007859 7864          DEST(PFA_CSKIP2)
00785a 70ca          .dw XT_OVER           ; ( -- addr' n' addr' )
00785b 7093          .dw XT_CFETCH         ; ( -- addr' n' c' )
00785c 7103          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
00785d 7d55          .dw XT_EQUAL          ; ( -- addr' n' f )
00785e 7031          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00785f 7864          DEST(PFA_CSKIP2)
007860 7d5c          .dw XT_ONE
007861 79a1          .dw XT_SLASHSTRING
007862 702a          .dw XT_DOBRANCH
007863 7857          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
007864 70f1          .dw XT_R_FROM
007865 70d4          .dw XT_DROP           ; ( -- addr2 n2)
007866 701b          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
007867 ff05          .dw $ff05
007868 7363
007869 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
00786a 006e          .db "cscan"
00786b 7850          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
00786c 7001          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
00786d 70fa          .dw XT_TO_R
00786e 70ca          .dw XT_OVER
                 PFA_CSCAN1:
00786f 70ac          .dw XT_DUP
007870 7093          .dw XT_CFETCH
007871 7103          .dw XT_R_FETCH
007872 7d55          .dw XT_EQUAL
007873 7115          .dw XT_ZEROEQUAL
007874 7031          .dw XT_DOCONDBRANCH
007875 7881          DEST(PFA_CSCAN2)
007876 70bf            .dw XT_SWAP
007877 7230            .dw XT_1MINUS
007878 70bf            .dw XT_SWAP
007879 70ca            .dw XT_OVER
00787a 711c            .dw XT_ZEROLESS ; not negative
00787b 7115            .dw XT_ZEROEQUAL
00787c 7031            .dw XT_DOCONDBRANCH
00787d 7881            DEST(PFA_CSCAN2)
00787e 722a              .dw XT_1PLUS
00787f 702a              .dw XT_DOBRANCH
007880 786f              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
007881 70eb          .dw XT_NIP
007882 70ca          .dw XT_OVER
007883 718e          .dw XT_MINUS
007884 70f1          .dw XT_R_FROM
007885 70d4          .dw XT_DROP
007886 701b          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
007887 ff06          .dw $ff06
007888 6361
007889 6563
00788a 7470          .db "accept"
00788b 7867          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
00788c 7001          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
00788d 70ca
00788e 7198
00788f 7230
007890 70ca              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
007891 759f
007892 70ac
007893 78cd
007894 7115
007895 7031      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
007896 78bf              DEST(ACC5)
007897 70ac
007898 7038
007899 0008
00789a 7d55
00789b 7031              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
00789c 78af              DEST(ACC3)
00789d 70d4
00789e 70dc
00789f 7565
0078a0 7173
0078a1 70fa
0078a2 70dc
0078a3 70dc
0078a4 70f1
0078a5 7031              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
0078a6 78ad      	DEST(ACC6)
0078a7 78c5
0078a8 7230
0078a9 70fa
0078aa 70ca
0078ab 70f1
0078ac 0142      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
0078ad 702a      ACC6:   .DW XT_DOBRANCH
0078ae 78bd              DEST(ACC4)
                     
                 
                 ACC3:    ; check for remaining control characters, replace them with blank
0078af 70ac      	.dw XT_DUP            ; ( -- addr k k )
0078b0 75f0              .dw XT_BL
0078b1 7169              .dw XT_LESS
0078b2 7031              .dw XT_DOCONDBRANCH
0078b3 78b6              DEST(PFA_ACCEPT6)
0078b4 70d4              .dw XT_DROP
0078b5 75f0              .dw XT_BL
                 PFA_ACCEPT6:
0078b6 70ac
0078b7 758e
0078b8 70ca
0078b9 7088
0078ba 722a
0078bb 70ca
0078bc 014e      	.DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
0078bd 702a      ACC4:   .DW XT_DOBRANCH
0078be 7891              DEST(ACC1)
0078bf 70d4
0078c0 70eb
0078c1 70bf
0078c2 718e
0078c3 77d8
0078c4 701b      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
0078c5 7001          .dw DO_COLON
                 .endif
0078c6 7038          .dw XT_DOLITERAL
0078c7 0008          .dw 8
0078c8 70ac          .dw XT_DUP
0078c9 758e          .dw XT_EMIT
0078ca 77e5          .dw XT_SPACE
0078cb 758e          .dw XT_EMIT
0078cc 701b          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
0078cd 7001          .dw DO_COLON
                 .endif
0078ce 70ac          .dw XT_DUP
0078cf 7038          .dw XT_DOLITERAL
0078d0 000d          .dw 13
0078d1 7d55          .dw XT_EQUAL
0078d2 70bf          .dw XT_SWAP
0078d3 7038          .dw XT_DOLITERAL
0078d4 000a          .dw 10
0078d5 7d55          .dw XT_EQUAL
0078d6 7217          .dw XT_OR
0078d7 701b          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILL:
0078d8 ff06          .dw $ff06
0078d9 6572
0078da 6966
0078db 6c6c          .db "refill"
0078dc 7887          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0078dd 7be8          .dw PFA_DODEFER1
                 PFA_REFILL:
                 .endif
0078de 001a          .dw USER_REFILL
0078df 7bb1          .dw XT_UDEFERFETCH
0078e0 7bbd          .dw XT_UDEFERSTORE
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
0078e1 ff04          .dw $ff04
0078e2 6863
0078e3 7261          .db "char"
0078e4 78d8          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
0078e5 7001          .dw DO_COLON
                 PFA_CHAR:
                 .endif
0078e6 79b0          .dw XT_PARSENAME
0078e7 70d4          .dw XT_DROP
0078e8 7093          .dw XT_CFETCH
0078e9 701b          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
0078ea ff06          .dw $ff06
0078eb 756e
0078ec 626d
0078ed 7265          .db "number"
0078ee 78e1          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0078ef 7001          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
0078f0 7551          .dw XT_BASE
0078f1 7074          .dw XT_FETCH
0078f2 70fa          .dw XT_TO_R
0078f3 7933          .dw XT_QSIGN
0078f4 70fa          .dw XT_TO_R
0078f5 7946          .dw XT_SET_BASE
0078f6 7933          .dw XT_QSIGN
0078f7 70f1          .dw XT_R_FROM
0078f8 7217          .dw XT_OR
0078f9 70fa          .dw XT_TO_R
                     ; check whether something is left
0078fa 70ac          .dw XT_DUP
0078fb 7115          .dw XT_ZEROEQUAL
0078fc 7031          .dw XT_DOCONDBRANCH
0078fd 7906          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
0078fe 756e            .dw XT_2DROP
0078ff 70f1            .dw XT_R_FROM
007900 70d4            .dw XT_DROP
007901 70f1            .dw XT_R_FROM
007902 7551            .dw XT_BASE
007903 707c            .dw XT_STORE
007904 714f            .dw XT_ZERO
007905 701b            .dw XT_EXIT
                 PFA_NUMBER0:
007906 730d          .dw XT_2TO_R
007907 714f          .dw XT_ZERO       ; starting value
007908 714f          .dw XT_ZERO
007909 731c          .dw XT_2R_FROM
00790a 7964          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
00790b 70b4          .dw XT_QDUP
00790c 7031          .dw XT_DOCONDBRANCH
00790d 7928          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
00790e 7d5c          .dw XT_ONE
00790f 7d55          .dw XT_EQUAL
007910 7031          .dw XT_DOCONDBRANCH
007911 791f          DEST(PFA_NUMBER2)
                 	; excatly one character is left
007912 7093      	.dw XT_CFETCH
007913 7038      	.dw XT_DOLITERAL
007914 002e      	.dw 46 ; .
007915 7d55      	.dw XT_EQUAL
007916 7031      	.dw XT_DOCONDBRANCH
007917 7920      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
007918 70f1      	.dw XT_R_FROM
007919 7031              .dw XT_DOCONDBRANCH
00791a 791c      	DEST(PFA_NUMBER3)
00791b 7cb6              .dw XT_DNEGATE
                 PFA_NUMBER3:
00791c 7d61      	.dw XT_TWO
00791d 702a      	.dw XT_DOBRANCH
00791e 792e      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
00791f 70d4      	.dw XT_DROP
                 PFA_NUMBER6:
007920 756e      	.dw XT_2DROP
007921 70f1      	.dw XT_R_FROM
007922 70d4      	.dw XT_DROP
007923 70f1              .dw XT_R_FROM
007924 7551              .dw XT_BASE
007925 707c              .dw XT_STORE
007926 714f      	.dw XT_ZERO
007927 701b      	.dw XT_EXIT
                 PFA_NUMBER1:
007928 756e          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
007929 70f1          .dw XT_R_FROM
00792a 7031          .dw XT_DOCONDBRANCH
00792b 792d          DEST(PFA_NUMBER4)
00792c 763f          .dw XT_NEGATE
                 PFA_NUMBER4:
00792d 7d5c          .dw XT_ONE
                 PFA_NUMBER5:
00792e 70f1          .dw XT_R_FROM
00792f 7551          .dw XT_BASE
007930 707c          .dw XT_STORE
007931 7146          .dw XT_TRUE
007932 701b          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
007933 7001          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
007934 70ca          .dw XT_OVER    ; ( -- addr len addr )
007935 7093          .dw XT_CFETCH
007936 7038          .dw XT_DOLITERAL
007937 002d          .dw '-'
007938 7d55          .dw XT_EQUAL  ; ( -- addr len flag )
007939 70ac          .dw XT_DUP
00793a 70fa          .dw XT_TO_R
00793b 7031          .dw XT_DOCONDBRANCH
00793c 793f          DEST(PFA_NUMBERSIGN_DONE)
00793d 7d5c          .dw XT_ONE    ; skip sign character
00793e 79a1          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
00793f 70f1          .dw XT_R_FROM
007940 701b          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
007941 704d          .dw PFA_DOCONSTANT
                 .endif
007942 000a
007943 0010
007944 0002
007945 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
007946 7001          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
007947 70ca          .dw XT_OVER
007948 7093          .dw XT_CFETCH
007949 7038          .dw XT_DOLITERAL
00794a 0023          .dw 35
00794b 718e          .dw XT_MINUS
00794c 70ac          .dw XT_DUP
00794d 714f          .dw XT_ZERO
00794e 7038          .dw XT_DOLITERAL
00794f 0004          .dw 4
007950 767a          .dw XT_WITHIN
007951 7031          .dw XT_DOCONDBRANCH
007952 795c          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
007953 7941      	.dw XT_BASES
007954 7198      	.dw XT_PLUS
007955 73bb      	.dw XT_FETCHI
007956 7551      	.dw XT_BASE
007957 707c      	.dw XT_STORE
007958 7d5c      	.dw XT_ONE
007959 79a1      	.dw XT_SLASHSTRING
00795a 702a      	.dw XT_DOBRANCH
00795b 795d      	DEST(SET_BASE2)
                 SET_BASE1:
00795c 70d4      	.dw XT_DROP
                 SET_BASE2:
00795d 701b          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
00795e ff07          .dw $ff07
00795f 6e3e
007960 6d75
007961 6562
007962 0072          .db ">number",0
007963 78ea          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
007964 7001          .dw DO_COLON
                 
                 .endif
                 
007965 70ac
007966 7031      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
007967 797d              DEST(TONUM3)
007968 70ca
007969 7093
00796a 7756              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
00796b 7115
00796c 7031              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
00796d 7970              DEST(TONUM2)
00796e 70d4
00796f 701b              .DW XT_DROP,XT_EXIT
007970 70fa
007971 7cdb
007972 7551
007973 7074
007974 0133      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
007975 70f1
007976 012b
007977 7cdb              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
007978 7038
007979 0001
00797a 79a1
00797b 702a              .DW XT_DOLITERAL,1,XT_SLASHSTRING,XT_DOBRANCH
00797c 7965              DEST(TONUM1)
00797d 701b      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
00797e ff05          .dw $ff05
00797f 6170
007980 7372
007981 0065          .db "parse",0
007982 795e          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
007983 7001          .dw DO_COLON
                 PFA_PARSE:
                 .endif
007984 70fa          .dw XT_TO_R     ; ( -- )
007985 7997          .dw XT_SOURCE   ; ( -- addr len)
007986 757e          .dw XT_TO_IN     ; ( -- addr len >in)
007987 7074          .dw XT_FETCH
007988 79a1          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
007989 70f1          .dw XT_R_FROM      ; ( -- addr' len' c)
00798a 786c          .dw XT_CSCAN       ; ( -- addr' len'')
00798b 70ac          .dw XT_DUP         ; ( -- addr' len'' len'')
00798c 722a          .dw XT_1PLUS
00798d 757e          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
00798e 7254          .dw XT_PLUSSTORE   ; ( -- addr' len')
00798f 7d5c          .dw XT_ONE
007990 79a1          .dw XT_SLASHSTRING
007991 701b          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCE:
007992 ff06          .dw $FF06
007993 6f73
007994 7275
007995 6563          .db "source"
007996 797e          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
007997 7be8          .dw PFA_DODEFER1
                 PFA_SOURCE:
                 .endif
007998 0016          .dw USER_SOURCE
007999 7bb1          .dw XT_UDEFERFETCH
00799a 7bbd          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
00799b ff07          .dw $ff07
00799c 732f
00799d 7274
00799e 6e69
00799f 0067          .db "/string",0
0079a0 7992          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0079a1 7001          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
0079a2 70dc          .dw XT_ROT
0079a3 70ca          .dw XT_OVER
0079a4 7198          .dw XT_PLUS
0079a5 70dc          .dw XT_ROT
0079a6 70dc          .dw XT_ROT
0079a7 718e          .dw XT_MINUS
0079a8 701b          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
0079a9 ff0a          .dw $FF0A 
0079aa 6170
0079ab 7372
0079ac 2d65
0079ad 616e
0079ae 656d          .db "parse-name"
0079af 799b          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0079b0 7001          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
0079b1 75f0          .dw XT_BL
0079b2 79b4          .dw XT_SKIPSCANCHAR
0079b3 701b          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0079b4 7001          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
0079b5 70fa          .dw XT_TO_R
0079b6 7997          .dw XT_SOURCE 
0079b7 757e          .dw XT_TO_IN 
0079b8 7074          .dw XT_FETCH 
0079b9 79a1          .dw XT_SLASHSTRING 
                 
0079ba 7103          .dw XT_R_FETCH
0079bb 7855          .dw XT_CSKIP
0079bc 70f1          .dw XT_R_FROM
0079bd 786c          .dw XT_CSCAN
                 
                     ; adjust >IN
0079be 7565          .dw XT_2DUP
0079bf 7198          .dw XT_PLUS
0079c0 7997          .dw XT_SOURCE 
0079c1 70d4          .dw XT_DROP
0079c2 718e          .dw XT_MINUS
0079c3 757e          .dw XT_TO_IN
0079c4 707c          .dw XT_STORE
0079c5 701b          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the name from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDNAME:
0079c6 ff09          .dw $ff09
0079c7 6966
0079c8 646e
0079c9 6e2d
0079ca 6d61
0079cb 0065          .db "find-name",0
0079cc 79a9          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
0079cd 7001          .dw DO_COLON
                 PFA_FINDNAME:
                 .endif
0079ce 7038          .dw XT_DOLITERAL
0079cf 79d9          .dw XT_FINDNAMEA
0079d0 7038          .dw XT_DOLITERAL
0079d1 004c          .dw CFG_ORDERLISTLEN
0079d2 03ea          .dw XT_MAPSTACK
0079d3 7115          .dw XT_ZEROEQUAL
0079d4 7031          .dw XT_DOCONDBRANCH
0079d5 79d8          DEST(PFA_FINDNAME1)
0079d6 756e            .dw XT_2DROP
0079d7 714f            .dw XT_ZERO
                 PFA_FINDNAME1:
0079d8 701b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDNAMEA:
0079d9 7001          .dw DO_COLON
                 PFA_FINDNAMEA:
                 .endif
0079da 70fa          .dw XT_TO_R
0079db 7565          .dw XT_2DUP
0079dc 70f1          .dw XT_R_FROM
0079dd 7bfa          .dw XT_SEARCH_WORDLIST
0079de 70ac          .dw XT_DUP
0079df 7031          .dw XT_DOCONDBRANCH
0079e0 79e6          DEST(PFA_FINDNAMEA1)
0079e1 70fa            .dw XT_TO_R
0079e2 70eb            .dw XT_NIP
0079e3 70eb            .dw XT_NIP
0079e4 70f1            .dw XT_R_FROM
0079e5 7146            .dw XT_TRUE
                 PFA_FINDNAMEA1:
0079e6 701b          .dw XT_EXIT
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
0079e7 7001          .dw DO_COLON
                 PFA_PROMPTOK:
0079e8 7770          .dw XT_DOSLITERAL
0079e9 0003          .dw 3
0079ea 6f20
0079eb 006b          .db " ok",0
                 .endif
0079ec 77a3          .dw XT_ITYPE
0079ed 701b          .dw XT_EXIT
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTREADY:
0079ee 7001          .dw DO_COLON
                 PFA_PROMPTREADY:
0079ef 7770          .dw XT_DOSLITERAL
0079f0 0002          .dw 2
0079f1 203e          .db "> "
                 .endif
0079f2 77d8          .dw XT_CR
0079f3 77a3          .dw XT_ITYPE
0079f4 701b          .dw XT_EXIT
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
0079f5 7001          .dw DO_COLON
                 PFA_PROMPTERROR:
0079f6 7770      	.dw XT_DOSLITERAL
0079f7 0004          .dw 4
0079f8 3f20
0079f9 203f          .db " ?? "
                 .endif
0079fa 77a3          .dw XT_ITYPE
0079fb 7551          .dw XT_BASE
0079fc 7074          .dw XT_FETCH
0079fd 70fa          .dw XT_TO_R
0079fe 75dd          .dw XT_DECIMAL
0079ff 7725          .dw XT_DOT
007a00 757e          .dw XT_TO_IN
007a01 7074          .dw XT_FETCH
007a02 7725          .dw XT_DOT
007a03 70f1          .dw XT_R_FROM
007a04 7551          .dw XT_BASE
007a05 707c          .dw XT_STORE
007a06 701b          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
007a07 ff04          .dw $ff04
007a08 7571
007a09 7469          .db "quit"
007a0a 79c6          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
007a0b 7001          .dw DO_COLON
                 PFA_QUIT:
                 .endif
                 PFA_QUIT1:
007a0c 02a6
007a0d 02ad
007a0e 707c          .dw XT_LP0,XT_LP,XT_STORE
007a0f 7a6c          .dw XT_SP0
007a10 7285          .dw XT_SP_STORE
007a11 7a79          .dw XT_RP0
007a12 726f          .dw XT_RP_STORE
007a13 033b          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
007a14 754b          .dw XT_STATE
007a15 7074          .dw XT_FETCH
007a16 7115          .dw XT_ZEROEQUAL
007a17 7031          .dw XT_DOCONDBRANCH
007a18 7a1a          DEST(PFA_QUIT4)
007a19 79ee          .dw XT_PROMPTREADY
                 PFA_QUIT4:
007a1a 78dd          .dw XT_REFILL
007a1b 7031          .dw XT_DOCONDBRANCH
007a1c 7a14          DEST(PFA_QUIT2)
007a1d 7038          .dw XT_DOLITERAL
007a1e 7a92          .dw XT_INTERPRET
007a1f 7826          .dw XT_CATCH
007a20 70b4          .dw XT_QDUP
007a21 7031          .dw XT_DOCONDBRANCH
007a22 7a2c          DEST(PFA_QUIT3)
007a23 70ac      	.dw XT_DUP
007a24 7038      	.dw XT_DOLITERAL
007a25 fffe      	.dw -2
007a26 7169      	.dw XT_LESS
007a27 7031      	.dw XT_DOCONDBRANCH
007a28 7a2a      	DEST(PFA_QUIT5)
007a29 79f5      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
007a2a 702a      	.dw XT_DOBRANCH
007a2b 7a0c      	DEST(PFA_QUIT1)
                 PFA_QUIT3:
007a2c 79e7          .dw XT_PROMPTOK
007a2d 702a          .dw XT_DOBRANCH
007a2e 7a14          DEST(PFA_QUIT2)
007a2f 701b          .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
007a30 ff05          .dw $ff05
007a31 6170
007a32 7375
007a33 0065          .db "pause",0
007a34 7a07          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
007a35 7be8          .dw PFA_DODEFER1
                 PFA_PAUSE:
007a36 0123          .dw ram_pause
007a37 7b9d          .dw XT_RDEFERFETCH
007a38 7ba7          .dw XT_RDEFERSTORE
                 
                 .dseg
000123           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
007a39 ff04          .dw $ff04
007a3a 6f63
007a3b 646c          .db "cold"
007a3c 7a30          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
007a3d 7a3e          .dw PFA_COLD
                 PFA_COLD:
007a3e b6a4          in_ mcu_boot, MCUSR
007a3f 2422          clr zerol
007a40 2433          clr zeroh
007a41 be24          out_ MCUSR, zerol
                     ; clear RAM
007a42 e0e0          ldi zl, low(ramstart)
007a43 e0f1          ldi zh, high(ramstart)
                 clearloop:
007a44 9221          st Z+, zerol
007a45 30e0          cpi zl, low(sram_size+ramstart)
007a46 f7e9          brne clearloop
007a47 31f1          cpi zh, high(sram_size+ramstart)
007a48 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000125           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
007a49 e2e5          ldi zl, low(ram_user1)
007a4a e0f1          ldi zh, high(ram_user1)
007a4b 012f          movw upl, zl
                     ; init return stack pointer
007a4c ef0f          ldi temp0,low(rstackstart)
007a4d bf0d          out_ SPL,temp0
007a4e 8304          std Z+4, temp0
007a4f e110          ldi temp1,high(rstackstart)
007a50 bf1e          out_ SPH,temp1
007a51 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
007a52 eacf          ldi yl,low(stackstart)
007a53 83c6          std Z+6, yl
007a54 e1d0          ldi yh,high(stackstart)
007a55 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
007a56 e5af          ldi XL, low(PFA_WARM)
007a57 e7ba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
007a58 940c 7005     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WARM:
007a5a ff04          .dw $ff04
007a5b 6177
007a5c 6d72          .db "warm"
007a5d 7a39          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
007a5e 7001          .dw DO_COLON
                 PFA_WARM:
                 .endif
007a5f 7d26          .dw XT_INIT_RAM
007a60 7038          .dw XT_DOLITERAL
007a61 7b54          .dw XT_NOOP
007a62 7038          .dw XT_DOLITERAL
007a63 7a35          .dw XT_PAUSE
007a64 7bc8          .dw XT_DEFERSTORE
007a65 033b          .dw XT_LBRACKET
007a66 75f8          .dw XT_TURNKEY
007a67 7a0b          .dw XT_QUIT     ; never returns
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
007a68 ff03          .dw $ff03
007a69 7073
007a6a 0030          .db "sp0",0
007a6b 7a5a          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
007a6c 706a          .dw PFA_DOVALUE1
                 PFA_SP0:
007a6d 0006          .dw USER_SP0
007a6e 7bb1          .dw XT_UDEFERFETCH
007a6f 7bbd          .dw XT_UDEFERSTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
007a70 ff02          .dw $ff02
007a71 7073          .db "sp"
007a72 7a68          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
007a73 7053          .dw PFA_DOUSER
                 PFA_SP:
007a74 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
007a75 ff03          .dw $ff03
007a76 7072
007a77 0030          .db "rp0",0
007a78 7a70          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
007a79 7001          .dw DO_COLON
                 PFA_RP0:
007a7a 7a7d          .dw XT_DORP0
007a7b 7074          .dw XT_FETCH
007a7c 701b          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
007a7d 7053          .dw PFA_DOUSER
                 PFA_DORP0:
007a7e 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
007a7f ff05          .dw $ff05
007a80 6564
007a81 7470
007a82 0068          .db "depth",0
007a83 7a75          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
007a84 7001          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
007a85 7a6c          .dw XT_SP0
007a86 727c          .dw XT_SP_FETCH
007a87 718e          .dw XT_MINUS
007a88 71ff          .dw XT_2SLASH
007a89 7230          .dw XT_1MINUS
007a8a 701b          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
007a8b ff09          .dw $ff09
007a8c 6e69
007a8d 6574
007a8e 7072
007a8f 6572
007a90 0074          .db "interpret",0
007a91 7a7f          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
007a92 7001          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
007a93 79b0          .dw XT_PARSENAME ; ( -- addr len )
007a94 70ac          .dw XT_DUP   ; ( -- addr len flag)
007a95 7031          .dw XT_DOCONDBRANCH
007a96 7aa2          DEST(PFA_INTERPRET2)
007a97 7aad            .dw XT_DORECOGNIZER
007a98 754b            .dw XT_STATE
007a99 7074            .dw XT_FETCH
007a9a 7031            .dw XT_DOCONDBRANCH
007a9b 7a9d          DEST(PFA_INTERPRET1)
007a9c 7b80            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
007a9d 73bb            .dw XT_FETCHI
007a9e 7025            .dw XT_EXECUTE
007a9f 7b2c            .dw XT_QSTACK
007aa0 702a          .dw XT_DOBRANCH
007aa1 7a93          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
007aa2 756e          .dw XT_2DROP
007aa3 701b          .dw XT_EXIT
                 .include "words/do-recognizer.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DORECOGNIZER:
007aa4 ff0d          .dw $ff0d
007aa5 6f64
007aa6 722d
007aa7 6365
007aa8 676f
007aa9 696e
007aaa 657a
007aab 0072          .db "do-recognizer",0
007aac 7a8b          .dw VE_HEAD
                     .set VE_HEAD = VE_DORECOGNIZER
                 XT_DORECOGNIZER:
007aad 7001          .dw DO_COLON
                 PFA_DORECOGNIZER:
                 .endif
007aae 7038          .dw XT_DOLITERAL
007aaf 7ab9          .dw XT_DORECOGNIZER_A
007ab0 7038          .dw XT_DOLITERAL
007ab1 005e          .dw CFG_RECOGNIZERLISTLEN
007ab2 03ea          .dw XT_MAPSTACK
007ab3 7115          .dw XT_ZEROEQUAL
007ab4 7031          .dw XT_DOCONDBRANCH
007ab5 7ab8          DEST(PFA_DORECOGNIZER1)
007ab6 756e            .dw XT_2DROP
007ab7 7b1f            .dw XT_R_FAIL
                 PFA_DORECOGNIZER1:
007ab8 701b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ; ( addr len XT -- addr len [ r:table -1 | 0 ] )
                 XT_DORECOGNIZER_A:
007ab9 7001         .dw DO_COLON
                 PFA_DORECOGNIZER_A:
                 .endif
007aba 70dc         .dw XT_ROT  ; -- len xt addr
007abb 70dc         .dw XT_ROT  ; -- xt addr len
007abc 7565         .dw XT_2DUP 
007abd 730d         .dw XT_2TO_R
007abe 70dc         .dw XT_ROT  ; -- addr len xt
007abf 7025         .dw XT_EXECUTE ; -- i*x r:foo | r:fail
007ac0 731c         .dw XT_2R_FROM
007ac1 70dc         .dw XT_ROT
007ac2 70ac         .dw XT_DUP
007ac3 7b1f         .dw XT_R_FAIL
007ac4 7d55         .dw XT_EQUAL
007ac5 7031         .dw XT_DOCONDBRANCH
007ac6 7aca         DEST(PFA_DORECOGNIZER_A1)
007ac7 70d4           .dw XT_DROP
007ac8 714f           .dw XT_ZERO
007ac9 701b           .dw XT_EXIT
                 PFA_DORECOGNIZER_A1:
007aca 70eb         .dw XT_NIP 
007acb 70eb         .dw XT_NIP
007acc 7146         .dw XT_TRUE
007acd 701b         .dw XT_EXIT
                 
                 ; : do-recognizer ( addr len -- i*x r:table|r:fail )
                 ;    \ ( addr len -- addr len 0 | i*x r:table -1 )
                 ;    [: rot rot 2dup 2>r rot execute 2r> rot 
                 ;          dup r:fail = ( -- addr len r:table f )
                 ;          if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    EE_RECOGNIZERLISTLEN map-stack ( -- i*x addr len r:table f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop r:fail 
                 ;    then
                 ;
                 .include "words/r-intnumber.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_NUM:
007ace ff05          .dw $ff05
007acf 3a72
007ad0 756e
007ad1 006d          .db "r:num",0
007ad2 7aa4          .dw VE_HEAD
                     .set VE_HEAD = VE_R_NUM
                 XT_R_NUM:
007ad3 704d          .dw PFA_DOCONSTANT
                 PFA_R_NUM:
                 .endif
007ad4 7b54          .dw XT_NOOP    ; interpret
007ad5 01c7          .dw XT_LITERAL ; compile
007ad6 01c7          .dw XT_LITERAL ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_DNUM:
007ad7 ff06          .dw $ff06
007ad8 3a72
007ad9 6e64
007ada 6d75          .db "r:dnum"
007adb 7ace          .dw VE_HEAD
                     .set VE_HEAD = VE_R_DNUM
                 XT_R_DNUM:
007adc 704d          .dw PFA_DOCONSTANT
                 PFA_R_DNUM:
                 .endif
007add 7b54          .dw XT_NOOP     ; interpret
007ade 7d4d          .dw XT_2LITERAL ; compile
007adf 7d4d          .dw XT_2LITERAL ; postpone
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
007ae0 ff07          .dw $ff07
007ae1 6572
007ae2 3a63
007ae3 756e
007ae4 006d          .db "rec:num",0
007ae5 7ad7          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
007ae6 7001          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
007ae7 78ef          .dw XT_NUMBER
007ae8 7031          .dw XT_DOCONDBRANCH
007ae9 7af2          DEST(PFA_REC_NONUMBER)
007aea 7d5c          .dw XT_ONE
007aeb 7d55          .dw XT_EQUAL
007aec 7031          .dw XT_DOCONDBRANCH
007aed 7af0          DEST(PFA_REC_INTNUM2)
007aee 7ad3            .dw XT_R_NUM
007aef 701b            .dw XT_EXIT
                 PFA_REC_INTNUM2:
007af0 7adc            .dw XT_R_DNUM
007af1 701b            .dw XT_EXIT
                 PFA_REC_NONUMBER:
007af2 7b1f          .dw XT_R_FAIL
007af3 701b          .dw XT_EXIT
                 .include "words/r-word.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_WORD:
007af4 ff08          .dw $ff08
007af5 6572
007af6 3a63
007af7 6f77
007af8 6472          .db "rec:word"
007af9 7ae0          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_WORD
                 XT_REC_WORD:
007afa 7001          .dw DO_COLON
                 PFA_REC_WORD:
                 .endif
007afb 79cd          .DW XT_FINDNAME
007afc 70ac          .dw XT_DUP
007afd 7115          .dw XT_ZEROEQUAL
007afe 7031          .dw XT_DOCONDBRANCH
007aff 7b03          DEST(PFA_REC_WORD_FOUND)
007b00 70d4              .dw XT_DROP
007b01 7b1f      	.dw XT_R_FAIL
007b02 701b      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
007b03 7b0a          .dw XT_R_WORD
                 
007b04 701b          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_WORD:
007b05 ff06          .dw $ff06
007b06 3a72
007b07 6f77
007b08 6472          .db "r:word"
007b09 7af4          .dw VE_HEAD
                     .set VE_HEAD = VE_R_WORD
                 XT_R_WORD:
007b0a 704d          .dw PFA_DOCONSTANT
                 PFA_R_WORD:
                 .endif
007b0b 7b0e          .dw XT_R_WORD_INTERPRET
007b0c 7b12          .dw XT_R_WORD_COMPILE
007b0d 7d4d          .dw XT_2LITERAL
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
007b0e 7001          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
007b0f 70d4          .dw XT_DROP ; the flags are in the way
007b10 7025          .dw XT_EXECUTE
007b11 701b          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
007b12 7001          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
007b13 711c          .dw XT_ZEROLESS
007b14 7031          .dw XT_DOCONDBRANCH
007b15 7b18          DEST(PFA_R_WORD_COMPILE1)
007b16 01b1      	.dw XT_COMMA
007b17 701b              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
007b18 7025              .dw XT_EXECUTE
007b19 701b          .dw XT_EXIT
                 .include "words/r-fail.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_FAIL:
007b1a ff06          .dw $ff06
007b1b 3a72
007b1c 6166
007b1d 6c69          .db "r:fail"
007b1e 7b05          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FAIL
                 XT_R_FAIL:
007b1f 704d          .dw PFA_DOCONSTANT
                 PFA_R_FAIL:
                 .endif
007b20 7b23          .dw XT_FAIL  ; interpret
007b21 7b23          .dw XT_FAIL  ; compile
007b22 7b23          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
007b23 7001          .dw DO_COLON
                 PFA_FAIL:
                 .endif
007b24 7038          .dw XT_DOLITERAL
007b25 fff3          .dw -13
007b26 783c          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
007b27 ff06          .dw $ff06
007b28 733f
007b29 6174
007b2a 6b63          .db "?stack"
007b2b 7b1a          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
007b2c 7001          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
007b2d 7a84          .dw XT_DEPTH
007b2e 711c          .dw XT_ZEROLESS
007b2f 7031          .dw XT_DOCONDBRANCH
007b30 7b34          DEST(PFA_QSTACK1)
007b31 7038            .dw XT_DOLITERAL
007b32 fffc            .dw -4
007b33 783c            .dw XT_THROW
                 PFA_QSTACK1:
007b34 701b          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
007b35 ff03          .dw $ff03
007b36 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
007b37 0072          .db "ver"
007b38 7b27          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
007b39 7001          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
007b3a 750d          .dw XT_ENV_FORTHNAME
007b3b 77a3          .dw XT_ITYPE
007b3c 77e5          .dw XT_SPACE
007b3d 7551          .dw XT_BASE
007b3e 7074          .dw XT_FETCH
                 
007b3f 751b          .dw XT_ENV_FORTHVERSION
007b40 75dd          .dw XT_DECIMAL
007b41 7d3d          .dw XT_S2D
007b42 76c1          .dw XT_L_SHARP
007b43 76c9          .dw XT_SHARP
007b44 7038          .dw XT_DOLITERAL
007b45 002e          .dw '.'
007b46 76b2          .dw XT_HOLD
007b47 76df          .dw XT_SHARP_S
007b48 76ea          .dw XT_SHARP_G
007b49 77fe          .dw XT_TYPE
007b4a 7551          .dw XT_BASE
007b4b 707c          .dw XT_STORE
007b4c 77e5          .dw XT_SPACE
007b4d 7523          .dw XT_ENV_CPU
007b4e 77a3          .dw XT_ITYPE
                 
007b4f 701b          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOOP:
007b50 ff04          .dw $ff04
007b51 6f6e
007b52 706f          .db "noop"
007b53 7b35          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
007b54 7001          .dw DO_COLON
                 PFA_NOOP:
                 .endif
007b55 701b         .DW XT_EXIT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
007b56 ff06          .dw $ff06
007b57 6e75
007b58 7375
007b59 6465          .db "unused"
007b5a 7b50          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
007b5b 7001          .dw DO_COLON
                 PFA_UNUSED:
007b5c 727c          .dw XT_SP_FETCH
007b5d 75bf          .dw XT_HERE
007b5e 718e          .dw XT_MINUS
007b5f 701b          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
007b60 0002          .dw $0002
007b61 6f74          .db "to"
007b62 7b56          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
007b63 7001          .dw DO_COLON
                 PFA_TO:
                 .endif
007b64 780d          .dw XT_TICK
007b65 7d46          .dw XT_TO_BODY
007b66 754b          .dw XT_STATE
007b67 7074          .dw XT_FETCH
007b68 7031          .dw XT_DOCONDBRANCH
007b69 7b74          DEST(PFA_TO1)
007b6a 01a6          .dw XT_COMPILE
007b6b 7b6e          .dw XT_DOTO
007b6c 01b1          .dw XT_COMMA
007b6d 701b          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
007b6e 7001          .dw DO_COLON
                 PFA_DOTO:
                 .endif
007b6f 70f1          .dw XT_R_FROM
007b70 70ac          .dw XT_DUP
007b71 7b80          .dw XT_ICELLPLUS
007b72 70fa          .dw XT_TO_R
007b73 73bb          .dw XT_FETCHI
                 PFA_TO1:
007b74 70ac          .dw XT_DUP
007b75 7b80          .dw XT_ICELLPLUS
007b76 7b80          .dw XT_ICELLPLUS
007b77 73bb          .dw XT_FETCHI
007b78 7025          .dw XT_EXECUTE
007b79 701b          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
007b7a ff07          .dw $FF07
007b7b 2d69
007b7c 6563
007b7d 6c6c
007b7e 002b          .db "i-cell+",0
007b7f 7b60          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
007b80 7001          .dw DO_COLON
                 PFA_ICELLPLUS:
007b81 722a          .dw XT_1PLUS
007b82 701b          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
007b83 ff07          .dw $ff07
007b84 6445
007b85 6665
007b86 7265
007b87 0040          .db "Edefer@",0
007b88 7b7a          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
007b89 7001          .dw DO_COLON
                 PFA_EDEFERFETCH:
007b8a 73bb          .dw XT_FETCHI
007b8b 734e          .dw XT_FETCHE
007b8c 701b          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
007b8d ff07          .dw $ff07
007b8e 6445
007b8f 6665
007b90 7265
007b91 0021          .db "Edefer!",0
007b92 7b83          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
007b93 7001          .dw DO_COLON
                 PFA_EDEFERSTORE:
007b94 73bb          .dw XT_FETCHI
007b95 732a          .dw XT_STOREE
007b96 701b          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
007b97 ff07          .dw $ff07
007b98 6452
007b99 6665
007b9a 7265
007b9b 0040          .db "Rdefer@",0
007b9c 7b8d          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
007b9d 7001          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
007b9e 73bb          .dw XT_FETCHI
007b9f 7074          .dw XT_FETCH
007ba0 701b          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
007ba1 ff07          .dw $ff07
007ba2 6452
007ba3 6665
007ba4 7265
007ba5 0021          .db "Rdefer!",0
007ba6 7b97          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
007ba7 7001          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
007ba8 73bb          .dw XT_FETCHI
007ba9 707c          .dw XT_STORE
007baa 701b          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
007bab ff07          .dw $ff07
007bac 6455
007bad 6665
007bae 7265
007baf 0040          .db "Udefer@",0
007bb0 7ba1          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
007bb1 7001          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
007bb2 73bb          .dw XT_FETCHI
007bb3 72f1          .dw XT_UP_FETCH
007bb4 7198          .dw XT_PLUS
007bb5 7074          .dw XT_FETCH
007bb6 701b          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
007bb7 ff07          .dw $ff07
007bb8 6455
007bb9 6665
007bba 7265
007bbb 0021          .db "Udefer!",0
007bbc 7bab          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
007bbd 7001          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
007bbe 73bb          .dw XT_FETCHI
007bbf 72f1          .dw XT_UP_FETCH
007bc0 7198          .dw XT_PLUS
007bc1 707c          .dw XT_STORE
007bc2 701b          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
007bc3 ff06          .dw $ff06
007bc4 6564
007bc5 6566
007bc6 2172          .db "defer!"
007bc7 7bb7          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
007bc8 7001          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
007bc9 7d46          .dw XT_TO_BODY
007bca 70ac          .dw XT_DUP
007bcb 7b80          .dw XT_ICELLPLUS
007bcc 7b80          .dw XT_ICELLPLUS
007bcd 73bb          .dw XT_FETCHI
007bce 7025          .dw XT_EXECUTE
007bcf 701b          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
007bd0 ff06          .dw $ff06
007bd1 6564
007bd2 6566
007bd3 4072          .db "defer@"
007bd4 7bc3          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
007bd5 7001          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
007bd6 7d46          .dw XT_TO_BODY 
007bd7 70ac          .dw XT_DUP
007bd8 7b80          .dw XT_ICELLPLUS
007bd9 73bb          .dw XT_FETCHI
007bda 7025          .dw XT_EXECUTE
007bdb 701b          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
007bdc ff07          .dw $ff07
007bdd 6428
007bde 6665
007bdf 7265
007be0 0029          .db "(defer)", 0
007be1 7bd0          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
007be2 7001          .dw DO_COLON
                 PFA_DODEFER:
007be3 0183          .dw XT_DOCREATE
007be4 02e3          .dw XT_REVEAL
007be5 01a6          .dw XT_COMPILE
007be6 7be8          .dw PFA_DODEFER1
007be7 701b          .dw XT_EXIT
                 PFA_DODEFER1:
007be8 940e 02fc     call_ DO_DODOES
007bea 70ac          .dw XT_DUP
007beb 7b80          .dw XT_ICELLPLUS
007bec 73bb          .dw XT_FETCHI
007bed 7025          .dw XT_EXECUTE 
007bee 7025          .dw XT_EXECUTE
007bef 701b          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
007bf0 ff0f          .dw $ff0f
007bf1 6573
007bf2 7261
007bf3 6863
007bf4 772d
007bf5 726f
007bf6 6c64
007bf7 7369
007bf8 0074          .db "search-wordlist",0
007bf9 7bdc          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
007bfa 7001          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
007bfb 70fa          .dw XT_TO_R
007bfc 714f          .dw XT_ZERO
007bfd 7038          .dw XT_DOLITERAL
007bfe 7c0f          .dw XT_ISWORD
007bff 70f1          .dw XT_R_FROM
007c00 7c2c          .dw XT_TRAVERSEWORDLIST
007c01 70ac          .dw XT_DUP
007c02 7115          .dw XT_ZEROEQUAL
007c03 7031          .dw XT_DOCONDBRANCH
007c04 7c09          DEST(PFA_SEARCH_WORDLIST1)
007c05 756e             .dw XT_2DROP
007c06 70d4             .dw XT_DROP
007c07 714f             .dw XT_ZERO
007c08 701b             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
007c09 70ac            .dw XT_DUP
007c0a 7c53            .dw XT_NFA2CFA
                       ; .. and get the header flag
007c0b 70bf            .dw XT_SWAP
007c0c 0169            .dw XT_NAME2FLAGS
007c0d 0156            .dw XT_IMMEDIATEQ
007c0e 701b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
007c0f 7001          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
007c10 70fa          .dw XT_TO_R
007c11 70d4          .dw XT_DROP
007c12 7565          .dw XT_2DUP
007c13 7103          .dw XT_R_FETCH  ; -- addr len addr len nt
007c14 7c47          .dw XT_NAME2STRING
007c15 7c5d          .dw XT_ICOMPARE      ; (-- addr len f )
007c16 7031          .dw XT_DOCONDBRANCH
007c17 7c1d          DEST(PFA_ISWORD3)
                       ; not now
007c18 70f1            .dw XT_R_FROM
007c19 70d4            .dw XT_DROP
007c1a 714f            .dw XT_ZERO
007c1b 7146            .dw XT_TRUE         ; maybe next word
007c1c 701b            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
007c1d 756e            .dw XT_2DROP
007c1e 70f1            .dw XT_R_FROM
007c1f 714f            .dw XT_ZERO       ; finish traverse-wordlist
007c20 701b            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
007c21 ff11          .dw $ff11
007c22 7274
007c23 7661
007c24 7265
007c25 6573
007c26 772d
007c27 726f
007c28 6c64
007c29 7369
007c2a 0074          .db "traverse-wordlist",0
007c2b 7bf0          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
007c2c 7001          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
007c2d 734e          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
007c2e 70ac          .dw XT_DUP           ; ( -- xt nt nt )
007c2f 7031          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
007c30 7c3d          DEST(PFA_TRAVERSEWORDLIST2)
007c31 7565          .dw XT_2DUP
007c32 730d          .dw XT_2TO_R
007c33 70bf          .dw XT_SWAP
007c34 7025          .dw XT_EXECUTE
007c35 731c          .dw XT_2R_FROM
007c36 70dc          .dw XT_ROT
007c37 7031          .dw XT_DOCONDBRANCH
007c38 7c3d          DEST(PFA_TRAVERSEWORDLIST2)
007c39 0450          .dw XT_NFA2LFA
007c3a 73bb          .dw XT_FETCHI
007c3b 702a          .dw XT_DOBRANCH      ; ( -- addr )
007c3c 7c2e          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
007c3d 756e          .dw XT_2DROP
007c3e 701b          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                 ;        begin @ dup
                 ;        while
                 ;          2dup 2>r
                 ;          swap execute ( i*x nt -- i*x' f )
                 ;          2r> rot
                 ;        while
                 ;          nfa>lfa @i
                 ;        repeat then 2drop ;
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
007c3f ff0b          .dw $ff0b
007c40 616e
007c41 656d
007c42 733e
007c43 7274
007c44 6e69
007c45 0067          .db "name>string",0
007c46 7c21          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
007c47 7001          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
007c48 77cf          .dw XT_ICOUNT   ; ( -- addr n )
007c49 7038          .dw XT_DOLITERAL
007c4a 00ff          .dw 255
007c4b 720e          .dw XT_AND      ; mask immediate bit
007c4c 701b          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
007c4d ff07          .dw $ff07
007c4e 666e
007c4f 3e61
007c50 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
007c51 0061          .db "nfa>cfa"
007c52 7c3f          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
007c53 7001          .dw DO_COLON
                 PFA_NFA2CFA:
007c54 0450          .dw XT_NFA2LFA ; skip to link field
007c55 722a          .dw XT_1PLUS   ; next is the execution token
007c56 701b          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
007c57 ff08          .dw $ff08
007c58 6369
007c59 6d6f
007c5a 6170
007c5b 6572          .db "icompare"
007c5c 7c4d          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
007c5d 7001          .dw DO_COLON
                 PFA_ICOMPARE:
007c5e 70fa          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
007c5f 70ca          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
007c60 70f1          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
007c61 710e          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
007c62 7031          .dw XT_DOCONDBRANCH
007c63 7c68          .dw PFA_ICOMPARE_SAMELEN
007c64 756e            .dw XT_2DROP
007c65 70d4            .dw XT_DROP
007c66 7146            .dw XT_TRUE
007c67 701b            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
007c68 70bf          .dw XT_SWAP ; ( -- r-addr f-addr len )
007c69 714f          .dw XT_ZERO
007c6a 0270          .dw XT_QDOCHECK
007c6b 7031          .dw XT_DOCONDBRANCH
007c6c 7c8b          .dw PFA_ICOMPARE_DONE
007c6d 728a          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
007c6e 70ca          .dw XT_OVER
007c6f 7074          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
007c70 70ca          .dw XT_OVER
007c71 73bb          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
007c72 70ac          .dw XT_DUP
                     ;.dw XT_BYTESWAP
007c73 7038          .dw XT_DOLITERAL
007c74 0100          .dw $100
007c75 7157          .dw XT_ULESS
007c76 7031          .dw XT_DOCONDBRANCH
007c77 7c7c          .dw PFA_ICOMPARE_LASTCELL
007c78 70bf          .dw XT_SWAP
007c79 7038          .dw XT_DOLITERAL
007c7a 00ff          .dw $00FF
007c7b 720e          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
007c7c 710e          .dw XT_NOTEQUAL
007c7d 7031          .dw XT_DOCONDBRANCH
007c7e 7c83          .dw PFA_ICOMPARE_NEXTLOOP
007c7f 756e          .dw XT_2DROP
007c80 7146          .dw XT_TRUE
007c81 72c3          .dw XT_UNLOOP
007c82 701b          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
007c83 722a          .dw XT_1PLUS
007c84 70bf          .dw XT_SWAP
007c85 755e          .dw XT_CELLPLUS
007c86 70bf          .dw XT_SWAP
007c87 7038          .dw XT_DOLITERAL
007c88 0002          .dw 2
007c89 72a9          .dw XT_DOPLUSLOOP
007c8a 7c6e          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
007c8b 756e          .dw XT_2DROP
007c8c 714f          .dw XT_ZERO
007c8d 701b          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
007c8e ff01          .dw $ff01
007c8f 002a          .db "*",0
007c90 7c57          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
007c91 7001          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
007c92 71a1          .dw XT_MSTAR
007c93 70d4          .dw XT_DROP
007c94 701b          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
007c95 ff01          .dw $FF01
007c96 006a          .db "j",0
007c97 7c8e          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
007c98 7001          .dw DO_COLON
                 PFA_J:
007c99 7265          .dw XT_RP_FETCH
007c9a 7038          .dw XT_DOLITERAL
007c9b 0007          .dw 7
007c9c 7198          .dw XT_PLUS
007c9d 7074          .dw XT_FETCH
007c9e 7265          .dw XT_RP_FETCH
007c9f 7038          .dw XT_DOLITERAL
007ca0 0009          .dw 9
007ca1 7198          .dw XT_PLUS
007ca2 7074          .dw XT_FETCH
007ca3 7198          .dw XT_PLUS
007ca4 701b          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
007ca5 ff04          .dw $ff04
007ca6 6164
007ca7 7362          .db "dabs"
007ca8 7c95          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
007ca9 7001          .dw DO_COLON
                 PFA_DABS:
007caa 70ac          .dw XT_DUP
007cab 711c          .dw XT_ZEROLESS
007cac 7031          .dw XT_DOCONDBRANCH
007cad 7caf          .dw PFA_DABS1
007cae 7cb6          .dw XT_DNEGATE
                 PFA_DABS1:
007caf 701b          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
007cb0 ff07          .dw $ff07
007cb1 6e64
007cb2 6765
007cb3 7461
007cb4 0065          .db "dnegate",0
007cb5 7ca5          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
007cb6 7001          .dw DO_COLON
                 PFA_DNEGATE:
007cb7 742b          .dw XT_DINVERT
007cb8 7038          .dw XT_DOLITERAL
007cb9 0001          .dw 1
007cba 714f          .dw XT_ZERO
007cbb 7405          .dw XT_DPLUS
007cbc 701b          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
007cbd ff05          .dw $ff05
007cbe 6d63
007cbf 766f
007cc0 0065          .db "cmove",0
007cc1 7cb0          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
007cc2 7cc3          .dw PFA_CMOVE
                 PFA_CMOVE:
007cc3 93bf          push xh
007cc4 93af          push xl
007cc5 91e9          ld zl, Y+
007cc6 91f9          ld zh, Y+ ; addr-to
007cc7 91a9          ld xl, Y+
007cc8 91b9          ld xh, Y+ ; addr-from
007cc9 2f09          mov temp0, tosh
007cca 2b08          or temp0, tosl
007ccb f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
007ccc 911d          ld temp1, X+
007ccd 9311          st Z+, temp1
007cce 9701          sbiw tosl, 1
007ccf f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
007cd0 91af          pop xl
007cd1 91bf          pop xh
007cd2 9189
007cd3 9199          loadtos
007cd4 940c 7005     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
007cd6 ff05          .dw $ff05
007cd7 7332
007cd8 6177
007cd9 0070          .db "2swap",0
007cda 7cbd          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
007cdb 7001          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
007cdc 70dc          .dw XT_ROT
007cdd 70fa          .dw XT_TO_R
007cde 70dc          .dw XT_ROT
007cdf 70f1          .dw XT_R_FROM
007ce0 701b          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System
                 ; refills the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILLTIB:
007ce1 ff0a          .dw $ff0a
007ce2 6572
007ce3 6966
007ce4 6c6c
007ce5 742d
007ce6 6269          .db "refill-tib"
007ce7 7cd6          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
007ce8 7001          .dw DO_COLON
                 PFA_REFILLTIB:
                 .endif
007ce9 7d04          .dw XT_TIB
007cea 7038          .dw XT_DOLITERAL
007ceb 005a          .dw TIB_SIZE
007cec 788c          .dw XT_ACCEPT
007ced 7d0a          .dw XT_NUMBERTIB
007cee 707c          .dw XT_STORE
007cef 714f          .dw XT_ZERO
007cf0 757e          .dw XT_TO_IN
007cf1 707c          .dw XT_STORE
007cf2 7146          .dw XT_TRUE ; -1
007cf3 701b          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCETIB:
007cf4 ff0a          .dw $FF0A
007cf5 6f73
007cf6 7275
007cf7 6563
007cf8 742d
007cf9 6269          .db "source-tib"
007cfa 7ce1          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
007cfb 7001          .dw DO_COLON
                 PFA_SOURCETIB:
                 .endif
007cfc 7d04          .dw XT_TIB
007cfd 7d0a          .dw XT_NUMBERTIB
007cfe 7074          .dw XT_FETCH
007cff 701b          .dw XT_EXIT
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; terminal input buffer address
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TIB:
007d00 ff03          .dw $ff03
007d01 6974
007d02 0062          .db "tib",0
007d03 7cf4          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
007d04 7043          .dw PFA_DOVARIABLE
                 PFA_TIB:
007d05 014b          .dw ram_tib
                 .dseg
00014b           ram_tib: .byte TIB_SIZE
                 .cseg
                 .endif
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBERTIB:
007d06 ff04          .dw $ff04
007d07 7423
007d08 6269          .db "#tib"
007d09 7d00          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
007d0a 7043          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
007d0b 01a5          .dw ram_sharptib
                 .dseg
0001a5           ram_sharptib: .byte 2
                 .cseg
                 .endif
                 
                 .include "words/init-ram.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
007d0c ff06        .dw $ff06
007d0d 6565
007d0e 723e
007d0f 6d61        .db "ee>ram"
007d10 7d06        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
007d11 7001        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
007d12 714f          .dw XT_ZERO
007d13 728a          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
007d14 70ca          .dw XT_OVER
007d15 734e          .dw XT_FETCHE
007d16 70ca          .dw XT_OVER
007d17 707c          .dw XT_STORE
007d18 755e          .dw XT_CELLPLUS
007d19 70bf          .dw XT_SWAP
007d1a 755e          .dw XT_CELLPLUS
007d1b 70bf          .dw XT_SWAP
007d1c 72b8          .dw XT_DOLOOP
007d1d 7d14          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
007d1e 756e          .dw XT_2DROP
007d1f 701b          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INIT_RAM:
007d20 ff08        .dw $ff08
007d21 6e69
007d22 7469
007d23 722d
007d24 6d61        .db "init-ram"
007d25 7d0c        .dw VE_HEAD
                   .set VE_HEAD = VE_INIT_RAM
                 XT_INIT_RAM:
007d26 7001        .dw DO_COLON
                 PFA_INI_RAM:          ; ( -- )
007d27 7038          .dw XT_DOLITERAL
007d28 006c          .dw EE_INITUSER
007d29 72f1          .dw XT_UP_FETCH
007d2a 7038          .dw XT_DOLITERAL
007d2b 001c          .dw SYSUSERSIZE
007d2c 71ff          .dw XT_2SLASH
007d2d 7d11          .dw XT_EE2RAM
007d2e 701b          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .endif
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
007d2f ff06          .dw $ff06
007d30 6f62
007d31 6e75
007d32 7364          .db "bounds"
007d33 7d20          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
007d34 7001          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
007d35 70ca          .dw XT_OVER
007d36 7198          .dw XT_PLUS
007d37 70bf          .dw XT_SWAP
007d38 701b          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
007d39 ff03          .dw $ff03
007d3a 3e73
007d3b 0064          .db "s>d",0
007d3c 7d2f          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
007d3d 7001          .dw DO_COLON
                 PFA_S2D:
                 .endif
007d3e 70ac          .dw XT_DUP
007d3f 711c          .dw XT_ZEROLESS
007d40 701b          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
007d41 ff05          .dw $ff05
007d42 623e
007d43 646f
007d44 0079          .db ">body",0
007d45 7d39          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
007d46 722b          .dw PFA_1PLUS
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 ; now colon words
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2LITERAL:
007d47 0008          .dw $0008
007d48 6c32
007d49 7469
007d4a 7265
007d4b 6c61          .db "2literal"
007d4c 7d41          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
007d4d 7001          .dw DO_COLON
                 PFA_2LITERAL:
                 .endif
007d4e 70bf          .dw XT_SWAP
007d4f 01c7          .dw XT_LITERAL
007d50 01c7          .dw XT_LITERAL
007d51 701b          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
007d52 ff01          .dw $ff01
007d53 003d          .db "=",0
007d54 7d47          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
007d55 7001          .dw DO_COLON
                 PFA_EQUAL:
007d56 718e          .dw XT_MINUS
007d57 7115          .dw XT_ZEROEQUAL
007d58 701b          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
007d59 ff01          .dw $ff01
007d5a 0031          .db "1",0
007d5b 7d52          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
007d5c 7043          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
007d5d 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
007d5e ff01          .dw $ff01
007d5f 0032          .db "2",0
007d60 7d59          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
007d61 7043          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
007d62 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
007d63 ff02          .dw $ff02
007d64 312d          .db "-1"
007d65 7d5e          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
007d66 7043          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
007d67 ffff              .DW -1
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000038 ff ff     
                 ; some configs
00003a 5f 05     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
00003c a7 01     EE_HERE:     .dw HERESTART       ; Memory Allocation
00003e 8a 00     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
000040 11 04     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
                 ; LEAVE stack is between data stack and return stack.
000042 b0 10     CFG_LP0:     .dw stackstart+1
000044 b2 04     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
000046 32 75     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
000048 4a 00     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
00004a 63 7d     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
00004c 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
00004e 4a 00         .dw CFG_FORTHWORDLIST      ; get/set-order
000050               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
00005e 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
000060 fa 7a         .dw XT_REC_WORD
000062 e6 7a         .dw XT_REC_NUM
000064               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_STOREI:
000068 6d 73         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
00006a 6a 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
00006c 00 00         .dw 0  ; USER_STATE
00006e 00 00         .dw 0  ; USER_FOLLOWER
000070 ff 10         .dw rstackstart  ; USER_RP
000072 af 10         .dw stackstart   ; USER_SP0
000074 af 10         .dw stackstart   ; USER_SP
                     
000076 00 00         .dw 0  ; USER_HANDLER
000078 0a 00         .dw 10 ; USER_BASE
                     
00007a 94 00         .dw XT_TX  ; USER_EMIT
00007c a2 00         .dw XT_TXQ ; USER_EMITQ
00007e 6a 00         .dw XT_RX  ; USER_KEY
000080 84 00         .dw XT_RXQ ; USER_KEYQ
000082 fb 7c         .dw XT_SOURCETIB ; USER_SKEY
000084 00 00         .dw 0            ; USER_G_IN
000086 e8 7c         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000088 19 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega644" register use summary:
r0 :  20 r1 :   5 r2 :   9 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  87 r17:  56 r18:  61 r19:  37 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 210 r25: 145 r26:  39 r27:  21 r28:   7 r29:   4 r30:  88 r31:  47 
x  :   4 y  : 213 z  :  48 
Registers used: 29 out of 35 (82.9%)

"ATmega644" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  21 add   :  16 adiw  :  18 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  21 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   1 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  12 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  10 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  26 inc   :   3 jmp   :  13 
ld    : 142 ldd   :   4 ldi   :  39 lds   :   2 lpm   :  16 lsl   :  14 
lsr   :   1 mov   :  12 movw  :  72 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  23 pop   :  52 
push  :  46 rcall :  41 ret   :   7 reti  :   2 rjmp  : 107 rol   :  23 
ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 sbis  :   0 
sbiw  :  16 sbr   :   0 sbrc  :   5 sbrs  :   7 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  78 std   :   8 sts   :   3 
sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 77 out of 113 (68.1%)

"ATmega644" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00fad0   2098  14326  16424   65536  25.1%
[.dseg] 0x000100 0x0001a7      0    167    167    4096   4.1%
[.eseg] 0x000000 0x00008a      0    138    138    2048   6.7%

Assembly complete, 0 errors, 5 warnings
