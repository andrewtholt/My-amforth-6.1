
AVRASM ver. 2.1.52  p16-8.asm Sat Oct 17 14:26:16 2015

p16-8.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega16\device.asm'
../../avr8/devices/atmega16\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m16def.inc'
p16-8.asm(14): Including file '../../avr8\drivers/usart.asm'
../../avr8\drivers/usart.asm(30): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(5): Including file '../../avr8\drivers/usart-isr-rx.asm'
../../avr8\drivers/usart_common.asm(17): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(22): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(23): Including file '../../avr8\words/usart.asm'
p16-8.asm(19): Including file '../../avr8\drivers/1wire.asm'
p16-8.asm(21): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(13): Including file '../../avr8\dict/appl_2k.inc'
../../avr8\dict/appl_2k.inc(1): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/appl_2k.inc(2): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/appl_2k.inc(3): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/appl_2k.inc(4): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/appl_2k.inc(5): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/appl_2k.inc(6): Including file '../../avr8\words/d-equal.asm'
../../avr8\dict/appl_2k.inc(7): Including file '../../common\words/u-dot.asm'
../../avr8\dict/appl_2k.inc(8): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/appl_2k.inc(10): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/appl_2k.inc(11): Including file '../../common\words/words.asm'
../../avr8\dict/appl_2k.inc(12): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(2): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(3): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(4): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(8): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/appl_2k.inc(14): Including file '../../common\words/pick.asm'
../../avr8\dict/appl_2k.inc(15): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/appl_2k.inc(16): Including file '../../common\words/squote.asm'
../../avr8\dict/appl_2k.inc(18): Including file '../../avr8\words/fill.asm'
../../avr8\dict/appl_2k.inc(19): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/newest.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/do-create.asm'
../../avr8\dict/compiler1.inc(5): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(9): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(10): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(17): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(33): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(38): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../common\words/create.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../common\words/reveal.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(53): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../common\words/recurse.asm'
../../avr8\dict/compiler1.inc(56): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(61): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(67): Including file '../../common\words/get-order.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(70): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\dict/appl_2k.inc(21): Including file '../../avr8\words/environment.asm'
../../avr8\dict/appl_2k.inc(22): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/appl_2k.inc(23): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/appl_2k.inc(24): Including file '../../common\words/env-slashhold.asm'
../../avr8\dict/appl_2k.inc(25): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/appl_2k.inc(26): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/appl_2k.inc(27): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/appl_2k.inc(28): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/appl_2k.inc(29): Including file '../../common\words/env-usersize.asm'
../../avr8\dict/appl_2k.inc(31): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/appl_2k.inc(32): Including file '../../avr8\words/state.asm'
../../avr8\dict/appl_2k.inc(33): Including file '../../common\words/base.asm'
../../avr8\dict/appl_2k.inc(35): Including file '../../avr8\words/cells.asm'
../../avr8\dict/appl_2k.inc(36): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/appl_2k.inc(38): Including file '../../common\words/2dup.asm'
../../avr8\dict/appl_2k.inc(39): Including file '../../common\words/2drop.asm'
../../avr8\dict/appl_2k.inc(41): Including file '../../common\words/tuck.asm'
../../avr8\dict/appl_2k.inc(43): Including file '../../common\words/to-in.asm'
../../avr8\dict/appl_2k.inc(44): Including file '../../common\words/pad.asm'
../../avr8\dict/appl_2k.inc(45): Including file '../../common\words/emit.asm'
../../avr8\dict/appl_2k.inc(46): Including file '../../common\words/emitq.asm'
../../avr8\dict/appl_2k.inc(47): Including file '../../common\words/key.asm'
../../avr8\dict/appl_2k.inc(48): Including file '../../common\words/keyq.asm'
../../avr8\dict/appl_2k.inc(50): Including file '../../avr8\words/dp.asm'
../../avr8\dict/appl_2k.inc(51): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/appl_2k.inc(52): Including file '../../avr8\words/here.asm'
../../avr8\dict/appl_2k.inc(53): Including file '../../avr8\words/allot.asm'
../../avr8\dict/appl_2k.inc(55): Including file '../../common\words/bin.asm'
../../avr8\dict/appl_2k.inc(56): Including file '../../common\words/decimal.asm'
../../avr8\dict/appl_2k.inc(57): Including file '../../common\words/hex.asm'
../../avr8\dict/appl_2k.inc(58): Including file '../../common\words/bl.asm'
../../avr8\dict/appl_2k.inc(60): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/appl_2k.inc(62): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/appl_2k.inc(63): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/appl_2k.inc(64): Including file '../../avr8\words/negate.asm'
../../avr8\dict/appl_2k.inc(65): Including file '../../common\words/slash.asm'
../../avr8\dict/appl_2k.inc(66): Including file '../../common\words/mod.asm'
../../avr8\dict/appl_2k.inc(67): Including file '../../avr8\words/abs.asm'
../../avr8\dict/appl_2k.inc(68): Including file '../../common\words/min.asm'
../../avr8\dict/appl_2k.inc(69): Including file '../../common\words/max.asm'
../../avr8\dict/appl_2k.inc(70): Including file '../../common\words/within.asm'
../../avr8\dict/appl_2k.inc(72): Including file '../../common\words/to-upper.asm'
../../avr8\dict/appl_2k.inc(73): Including file '../../common\words/to-lower.asm'
../../avr8\dict/appl_2k.inc(75): Including file '../../avr8\words/hld.asm'
../../avr8\dict/appl_2k.inc(76): Including file '../../common\words/hold.asm'
../../avr8\dict/appl_2k.inc(77): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/appl_2k.inc(78): Including file '../../common\words/sharp.asm'
../../avr8\dict/appl_2k.inc(79): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/appl_2k.inc(80): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/appl_2k.inc(81): Including file '../../common\words/sign.asm'
../../avr8\dict/appl_2k.inc(82): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/appl_2k.inc(83): Including file '../../common\words/dot-r.asm'
../../avr8\dict/appl_2k.inc(84): Including file '../../common\words/d-dot.asm'
../../avr8\dict/appl_2k.inc(85): Including file '../../common\words/dot.asm'
../../avr8\dict/appl_2k.inc(86): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/appl_2k.inc(87): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/appl_2k.inc(88): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/appl_2k.inc(89): Including file '../../common\words/digit-q.asm'
../../avr8\dict/appl_2k.inc(91): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/appl_2k.inc(92): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/appl_2k.inc(93): Including file '../../avr8\words/itype.asm'
../../avr8\dict/appl_2k.inc(94): Including file '../../avr8\words/icount.asm'
../../avr8\dict/appl_2k.inc(95): Including file '../../common\words/cr.asm'
../../avr8\dict/appl_2k.inc(96): Including file '../../common\words/space.asm'
../../avr8\dict/appl_2k.inc(97): Including file '../../common\words/spaces.asm'
../../avr8\dict/appl_2k.inc(98): Including file '../../common\words/type.asm'
../../avr8\dict/appl_2k.inc(99): Including file '../../common\words/tick.asm'
../../avr8\dict/appl_2k.inc(101): Including file '../../common\words/handler.asm'
../../avr8\dict/appl_2k.inc(102): Including file '../../common\words/catch.asm'
../../avr8\dict/appl_2k.inc(103): Including file '../../common\words/throw.asm'
../../avr8\dict/appl_2k.inc(105): Including file '../../common\words/cskip.asm'
../../avr8\dict/appl_2k.inc(106): Including file '../../common\words/cscan.asm'
../../avr8\dict/appl_2k.inc(107): Including file '../../common\words/accept.asm'
../../avr8\dict/appl_2k.inc(108): Including file '../../common\words/refill.asm'
../../avr8\dict/appl_2k.inc(109): Including file '../../common\words/char.asm'
../../avr8\dict/appl_2k.inc(110): Including file '../../common\words/number.asm'
../../avr8\dict/appl_2k.inc(111): Including file '../../common\words/q-sign.asm'
../../avr8\dict/appl_2k.inc(112): Including file '../../common\words/set-base.asm'
../../avr8\dict/appl_2k.inc(113): Including file '../../common\words/to-number.asm'
../../avr8\dict/appl_2k.inc(114): Including file '../../common\words/parse.asm'
../../avr8\dict/appl_2k.inc(115): Including file '../../common\words/source.asm'
../../avr8\dict/appl_2k.inc(116): Including file '../../common\words/slash-string.asm'
../../avr8\dict/appl_2k.inc(117): Including file '../../common\words/parse-name.asm'
../../avr8\dict/appl_2k.inc(118): Including file '../../common\words/find-name.asm'
../../avr8\dict/appl_2k.inc(120): Including file '../../common\words/quit.asm'
../../avr8\dict/appl_2k.inc(121): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/appl_2k.inc(122): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/appl_2k.inc(123): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/appl_2k.inc(124): Including file '../../avr8\words/pause.asm'
../../avr8\dict/appl_2k.inc(125): Including file '../../avr8\words/cold.asm'
../../avr8\dict/appl_2k.inc(126): Including file '../../common\words/warm.asm'
../../avr8\dict/appl_2k.inc(128): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/appl_2k.inc(129): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/appl_2k.inc(130): Including file '../../common\words/depth.asm'
../../avr8\dict/appl_2k.inc(131): Including file '../../common\words/do-recognizer.asm'
../../avr8\dict/appl_2k.inc(132): Including file '../../common\words/interpret.asm'
../../avr8\dict/appl_2k.inc(133): Including file '../../common\words/r-intnumber.asm'
../../avr8\dict/appl_2k.inc(134): Including file '../../common\words/r-word.asm'
../../avr8\dict/appl_2k.inc(135): Including file '../../common\words/r-fail.asm'
../../avr8\dict/appl_2k.inc(137): Including file '../../common\words/q-stack.asm'
../../avr8\dict/appl_2k.inc(138): Including file '../../common\words/ver.asm'
../../avr8\dict/appl_2k.inc(140): Including file '../../common\words/noop.asm'
../../avr8\dict/appl_2k.inc(141): Including file '../../avr8\words/unused.asm'
../../avr8\dict/appl_2k.inc(143): Including file '../../common\words/to.asm'
../../avr8\dict/appl_2k.inc(144): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/appl_2k.inc(146): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/appl_2k.inc(147): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/appl_2k.inc(148): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/appl_2k.inc(149): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/appl_2k.inc(150): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/appl_2k.inc(151): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/appl_2k.inc(152): Including file '../../common\words/defer-store.asm'
../../avr8\dict/appl_2k.inc(153): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/appl_2k.inc(154): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/appl_2k.inc(156): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/appl_2k.inc(157): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/appl_2k.inc(158): Including file '../../common\words/name2string.asm'
../../avr8\dict/appl_2k.inc(159): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/appl_2k.inc(160): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/appl_2k.inc(162): Including file '../../common\words/star.asm'
../../avr8\dict/appl_2k.inc(163): Including file '../../avr8\words/j.asm'
../../avr8\dict/appl_2k.inc(165): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/appl_2k.inc(166): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/appl_2k.inc(167): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/appl_2k.inc(168): Including file '../../common\words/2swap.asm'
../../avr8\dict/appl_2k.inc(170): Including file '../../common\words/tib.asm'
../../avr8\dict/appl_2k.inc(172): Including file '../../avr8\words/init-ram.asm'
../../avr8\dict/appl_2k.inc(173): Including file '../../common\words/bounds.asm'
../../avr8\dict/appl_2k.inc(174): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/appl_2k.inc(175): Including file '../../avr8\words/to-body.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../common\words/dot-s.asm'
dict_appl.inc(4): Including file '../../avr8\words/spirw.asm'
dict_appl.inc(5): Including file '../../avr8\words/n-spi.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
dict_appl.inc(7): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../common\words/set-order.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../common\words/set-recognizer.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../common\words/get-recognizer.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(16): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(17): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(18): Including file '../../common\words/postpone.asm'
dict_appl.inc(8): Including file '../../avr8\words/2r_fetch.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(36): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(41): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(45): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(46): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(48): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(55): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(62): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(88): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(92): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(96): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(98): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(105): Including file '../../avr8\dict/core_2k.inc'
../../avr8\dict/nrww.inc(111): Including file '../../common\words/2literal.asm'
../../avr8\dict/nrww.inc(112): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(113): Including file '../../common\words/num-constants.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot      = r10
                   .def erase_counter = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  96
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_EEPROM = 0
                 .set WANT_CPU = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_SPI = 0
                 .set WANT_USART = 0
                 .set WANT_TWI = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_JTAG = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_WATCHDOG = 0
                 .equ intvecsize = 2 ; please verify; flash size: 16384 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d109      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d107      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d105      	 rcall isr ; Timer/Counter2 Compare Match
                 .org 8
000008 d103      	 rcall isr ; Timer/Counter2 Overflow
                 .org 10
00000a d101      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 12
00000c d0ff      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 14
00000e d0fd      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 16
000010 d0fb      	 rcall isr ; Timer/Counter1 Overflow
                 .org 18
000012 d0f9      	 rcall isr ; Timer/Counter0 Overflow
                 .org 20
000014 d0f7      	 rcall isr ; Serial Transfer Complete
                 .org 22
000016 d0f5      	 rcall isr ; USART, Rx Complete
                 .org 24
000018 d0f3      	 rcall isr ; USART Data Register Empty
                 .org 26
00001a d0f1      	 rcall isr ; USART, Tx Complete
                 .org 28
00001c d0ef      	 rcall isr ; ADC Conversion Complete
                 .org 30
00001e d0ed      	 rcall isr ; EEPROM Ready
                 .org 32
000020 d0eb      	 rcall isr ; Analog Comparator
                 .org 34
000022 d0e9      	 rcall isr ; 2-wire Serial Interface
                 .org 36
000024 d0e7      	 rcall isr ; External Interrupt Request 2
                 .org 38
000026 d0e5      	 rcall isr ; Timer/Counter0 Compare Match
                 .org 40
000028 d0e3      	 rcall isr ; Store Program Memory Ready
                 .equ INTVECTORS = 21
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 .equ EEPE = EEWE
                 .equ EEMPE = EEMWE
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000029 0400      	.dw 1024
                 mcu_eepromsize:
00002a 0200      	.dw 512
                 mcu_maxdp:
00002b 3800      	.dw 14336 
                 mcu_numints:
00002c 0015      	.dw 21
                 mcu_name:
00002d 0008      	.dw  8
00002e 5441
00002f 656d
000030 6167
000031 3631      	.db "ATmega16"
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; receiving is asynchron, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR+1
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 8000000
                 .set BAUD_MAXERROR = 30
                 .equ TIMER_INT = OVF2addr
                 
                 .include "drivers/usart.asm"
                 
                 .equ BAUDRATE_LOW = UBRRL+$20
                 .equ BAUDRATE_HIGH = UBRRH+$20
                 .equ USART_C = UCSRC+$20
                 .equ USART_B = UCSRB+$20
                 .equ USART_A = UCSRA+$20
                 .equ USART_DATA = UDR+$20
                 .equ bm_USARTC_en   = 1 << 7
                 
                 ; some generic constants
                 .equ bm_USART_RXRD = 1 << RXC
                 .equ bm_USART_TXRD = 1 << UDRE
                 .equ bm_ENABLE_TX  = 1 << TXEN
                 .equ bm_ENABLE_RX  = 1 << RXEN
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE
                 .equ bm_ENABLE_INT_TX = 1<<UDRE
                 
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000060           usart_rx_data: .byte usart_rx_size+2
000072           usart_rx_in: .byte 2
000074           usart_rx_out: .byte 2
                 
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
000032 93af        push xl
000033 b7af        in xl, SREG
000034 93af        push xl
000035 93bf        push xh
000036 93ef        push zl
000037 93ff        push zh
                 
000038 91b0 002c   lds xh, USART_DATA
                 usart_rx_store:
00003a 91a0 0072   lds xl, usart_rx_in
00003c e6e0        ldi zl, low(usart_rx_data)
00003d e0f0        ldi zh, high(usart_rx_data)
00003e 0fea        add zl, xl
00003f 1df3        adc zh, zeroh
000040 83b0        st Z, xh
                 
000041 95a3        inc xl
000042 70af        andi xl,usart_rx_mask
                 
000043 93a0 0072   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
000045 91ff        pop zh
000046 91ef        pop zl
000047 91bf        pop xh
000048 91af        pop xl
000049 bfaf        out SREG, xl
00004a 91af        pop xl
00004b 9518        reti
                 
                 .set usartpc = pc
                 .org URXCaddr
000016 c01b        jmp_ usart_rx_isr
                 .org usartpc
                 
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
00004c 1c01        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
00004d 1d4f        .dw XT_ZERO
00004e 1c38        .dw XT_DOLITERAL
00004f 0072        .dw usart_rx_in
000050 1c88        .dw XT_CSTORE
000051 1d4f        .dw XT_ZERO
000052 1c38        .dw XT_DOLITERAL
000053 0074        .dw usart_rx_out
000054 1c88        .dw XT_CSTORE
                 
000055 1c1b        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
000056 ff06          .dw $ff06
000057 7872
000058 692d
000059 7273          .db "rx-isr"
00005a 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
00005b 1c01          .dw DO_COLON
                 PFA_RX_ISR:
00005c 0075        .dw XT_RXQ_ISR
00005d 1c31        .dw XT_DOCONDBRANCH
00005e 005c        .dw PFA_RX_ISR
00005f 1c38        .dw XT_DOLITERAL
000060 0074        .dw usart_rx_out
000061 1c93        .dw XT_CFETCH
000062 1cac        .dw XT_DUP
000063 1e2a        .dw XT_1PLUS
000064 1c38        .dw XT_DOLITERAL
000065 000f        .dw usart_rx_mask
000066 1e0e        .dw XT_AND
000067 1c38        .dw XT_DOLITERAL
000068 0074        .dw usart_rx_out
000069 1c88        .dw XT_CSTORE
00006a 1c38        .dw XT_DOLITERAL
00006b 0060        .dw usart_rx_data
00006c 1d98        .dw XT_PLUS
00006d 1c93        .dw XT_CFETCH
00006e 1c1b        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
00006f ff07          .dw $ff07
000070 7872
000071 2d3f
000072 7369
000073 0072          .db "rx?-isr",0
000074 0056          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
000075 1c01          .dw DO_COLON
                 PFA_RXQ_ISR:
000076 0aa2        .dw XT_PAUSE
000077 1c38        .dw XT_DOLITERAL
000078 0074        .dw usart_rx_out
000079 1c93        .dw XT_CFETCH
00007a 1c38        .dw XT_DOLITERAL
00007b 0072        .dw usart_rx_in
00007c 1c93        .dw XT_CFETCH
00007d 1d0e        .dw XT_NOTEQUAL
00007e 1c1b        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
00007f ff07          .dw $ff07
000080 7874
000081 702d
000082 6c6f
000083 006c          .db "tx-poll",0
000084 006f          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
000085 1c01          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
000086 0093        .dw XT_TXQ_POLL
000087 1c31        .dw XT_DOCONDBRANCH
000088 0086        .dw PFA_TX_POLL
                   ; send to usart
000089 1c38        .dw XT_DOLITERAL
00008a 002c        .dw USART_DATA
00008b 1c88        .dw XT_CSTORE
00008c 1c1b        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
00008d ff08          .dw $ff08
00008e 7874
00008f 2d3f
000090 6f70
000091 6c6c          .db "tx?-poll"
000092 007f          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
000093 1c01          .dw DO_COLON
                 PFA_TXQ_POLL:
000094 0aa2        .dw XT_PAUSE
000095 1c38        .dw XT_DOLITERAL
000096 002b        .dw USART_A
000097 1c93        .dw XT_CFETCH
000098 1c38        .dw XT_DOLITERAL
000099 0020        .dw bm_USART_TXRD
00009a 1e0e        .dw XT_AND
00009b 1c1b        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
00009c ff04        .dw $ff04
00009d 6275
00009e 7272        .db "ubrr"
00009f 008d        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000a0 1c6a        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000a1 007a        .dw EE_UBRRVAL
0000a2 0bf6        .dw XT_EDEFERFETCH
0000a3 0c00        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000a4 ff06        .dw $ff06
0000a5 752b
0000a6 6173
0000a7 7472        .db "+usart"
0000a8 009c        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000a9 1c01        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000aa 1c38        .dw XT_DOLITERAL
0000ab 0098        .dw USART_B_VALUE
0000ac 1c38        .dw XT_DOLITERAL
0000ad 002a        .dw USART_B
0000ae 1c88        .dw XT_CSTORE
                 
0000af 1c38        .dw XT_DOLITERAL
0000b0 0006        .dw USART_C_VALUE
0000b1 1c38        .dw XT_DOLITERAL
0000b2 00c0        .dw USART_C | bm_USARTC_en
0000b3 1c88        .dw XT_CSTORE
                 
0000b4 00a0        .dw XT_UBRR
0000b5 1cac        .dw XT_DUP
0000b6 1ee8        .dw XT_BYTESWAP
0000b7 1c38        .dw XT_DOLITERAL
0000b8 0040        .dw BAUDRATE_HIGH
0000b9 1c88        .dw XT_CSTORE
0000ba 1c38        .dw XT_DOLITERAL
0000bb 0029        .dw BAUDRATE_LOW
0000bc 1c88        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000bd 004c        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000be 1c1b        .dw XT_EXIT
                 
                 ; settings for 1wire interface
                 .equ OW_PORT=PORTB
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
0000bf ff08          .dw $ff08
0000c0 7731
0000c1 722e
0000c2 7365
0000c3 7465          .db "1w.reset"
0000c4 00a4          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
0000c5 00c6          .dw PFA_OW_RESET
                 PFA_OW_RESET:
0000c6 939a
0000c7 938a          savetos
0000c8 2799          clr tosh
                     ; setup to output
0000c9 9abc          sbi OW_DDR, OW_BIT
                     ; Pull output low
0000ca 98c4          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
0000cb ece0
0000cc e0f3
0000cd 9731
0000ce f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
0000cf b71f          in temp1, SREG
0000d0 94f8          cli
                     ; Pull output high
0000d1 9ac4          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
0000d2 98bc          cbi OW_DDR, OW_BIT 
0000d3 e8e0
0000d4 e0f0
0000d5 9731
0000d6 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
0000d7 b386          in tosl, OW_PIN
0000d8 ff84          sbrs tosl, OW_BIT
0000d9 ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
0000da bf1f          out SREG, temp1
                     ; release bus
0000db 98bc          cbi OW_DDR, OW_BIT
0000dc 98c4          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
0000dd e4e0
0000de e0f3
0000df 9731
0000e0 f7f1          DELAY   416
                     ; we now have the result flag in TOS        
0000e1 2f89          mov tosl, tosh
0000e2 940c 1c05     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
0000e4 ff07          .dw $ff07
0000e5 7731
0000e6 732e
0000e7 6f6c
0000e8 0074          .db "1w.slot",0
0000e9 00bf          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
0000ea 00eb          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
0000eb 9abc          sbi OW_DDR, OW_BIT
0000ec 98c4          cbi OW_PORT, OW_BIT
                     ; disable interrupts
0000ed b71f          in temp1, SREG
0000ee 94f8          cli
0000ef e0ec
0000f0 e0f0
0000f1 9731
0000f2 f7f1          DELAY   6 ; DELAY A
                     ; check bit
0000f3 9488          clc
0000f4 9587          ror tosl
0000f5 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
0000f6 98bc            cbi OW_DDR, OW_BIT
0000f7 9ac4            sbi OW_PORT, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
0000f8 e1e2
0000f9 e0f0
0000fa 9731
0000fb f7f1          DELAY 9   ; wait DELAY E to sample
0000fc b306          in temp0, OW_PIN
0000fd fd04          sbrc temp0, OW_BIT
0000fe 6880          ori tosl, $80
                 
0000ff e6e6
000100 e0f0
000101 9731
000102 f7f1          DELAY   51 ; DELAY B
000103 98bc          cbi OW_DDR, OW_BIT
000104 9ac4          sbi OW_PORT, OW_BIT ; release bus
000105 e0e4
000106 e0f0
000107 9731
000108 f7f1          delay 2
                     ; re-enable interrupts
000109 bf1f          out SREG, temp1
00010a 940c 1c05     jmp_ DO_NEXT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c 0aab   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000076           intcur: .byte 1
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
00010c 920a          st -Y, r0
00010d b60f          in r0, SREG
00010e 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
00010f 900f          pop r0
000110 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
000111 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
000112 9200 0076     sts intcur, r0
000114 9009          ld r0, Y+
000115 be0f          out SREG, r0
000116 9009          ld r0, Y+
000117 9468          set ; set the interrupt flag for the inner interpreter
000118 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000119 ff02          .dw $ff02
00011a 2b6d          .db "m+"
00011b 00e4          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
00011c 1c01          .dw DO_COLON
                 PFA_MPLUS:
00011d 0daa          .dw XT_S2D
00011e 0181          .dw XT_DPLUS
00011f 1c1b          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
000120 ff03          .dw $ff03
000121 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
000122 002a          .db "ud*"
000123 0119          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
000124 1c01          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000125 1cac
000126 1cfa
000127 1ddb
000128 1cd4              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000129 1cbf
00012a 1cf1
00012b 1ddb
00012c 1cdc
00012d 1d98
00012e 1c1b              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00012f ff04          .dw $ff04
000130 6d75
000131 7861          .db "umax"
000132 0120          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
000133 1c01          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
000134 05d0
000135 1d57              .DW XT_2DUP,XT_ULESS
000136 1c31      	.dw XT_DOCONDBRANCH
000137 0139      	 DEST(UMAX1)
000138 1cbf              .DW XT_SWAP
000139 1cd4      UMAX1:  .DW XT_DROP
00013a 1c1b      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
00013b ff04          .dw $ff04
00013c 6d75
00013d 6e69          .db "umin"
00013e 012f          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00013f 1c01          .dw DO_COLON
                 PFA_UMIN:
                 .endif
000140 05d0
000141 1d62              .DW XT_2DUP,XT_UGREATER
000142 1c31      	.dw XT_DOCONDBRANCH
000143 0145      	DEST(UMIN1)
000144 1cbf              .DW XT_SWAP
000145 1cd4      UMIN1:  .DW XT_DROP
000146 1c1b      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000147 1c01          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000148 1c38          .dw XT_DOLITERAL
000149 8000          .dw $8000
00014a 1e0e          .dw XT_AND
00014b 1d15          .dw XT_ZEROEQUAL
00014c 1c31          .dw XT_DOCONDBRANCH
00014d 0151          DEST(IMMEDIATEQ1)
00014e 1c38           .dw XT_DOLITERAL
00014f 0001           .dw 1
000150 1c1b           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
000151 1d46          .dw XT_TRUE
000152 1c1b          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
000153 ff0a          .dw $ff0a
000154 616e
000155 656d
000156 663e
000157 616c
000158 7367          .db "name>flags"
000159 013b          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
00015a 1c01          .dw DO_COLON
                 PFA_NAME2FLAGS:
00015b 1fbb          .dw XT_FETCHI ; skip to link field
00015c 1c38          .dw XT_DOLITERAL
00015d ff00          .dw $ff00
00015e 1e0e          .dw XT_AND
00015f 1c1b          .dw XT_EXIT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .include "dict/appl_2k.inc"
                 
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
000160 ff03          .dw $ff03
000161 3264
000162 002a          .db "d2*",0
000163 0153          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
000164 0165          .dw PFA_D2STAR
                 PFA_D2STAR:
000165 9109          ld temp0, Y+
000166 9119          ld temp1, Y+
000167 0f00          lsl temp0
000168 1f11          rol temp1
000169 1f88          rol tosl
00016a 1f99          rol tosh
00016b 931a          st -Y, temp1
00016c 930a          st -Y, temp0
00016d 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
00016f ff03          .dw $ff03
000170 3264
000171 002f          .db "d2/",0
000172 0160          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
000173 0174          .dw PFA_D2SLASH
                 PFA_D2SLASH:
000174 9109          ld temp0, Y+
000175 9119          ld temp1, Y+
000176 9595          asr tosh
000177 9587          ror tosl
000178 9517          ror temp1
000179 9507          ror temp0
00017a 931a          st -Y, temp1
00017b 930a          st -Y, temp0
00017c 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
00017e ff02          .dw $ff02
00017f 2b64          .db "d+"
000180 016f          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
000181 0182          .dw PFA_DPLUS
                 PFA_DPLUS:
000182 9129          ld temp2, Y+
000183 9139          ld temp3, Y+
                 
000184 90e9          ld temp4, Y+
000185 90f9          ld temp5, Y+
000186 9149          ld temp6, Y+
000187 9159          ld temp7, Y+
                 
000188 0f24          add temp2, temp6
000189 1f35          adc temp3, temp7
00018a 1d8e          adc tosl, temp4
00018b 1d9f          adc tosh, temp5
                     
00018c 933a          st -Y, temp3
00018d 932a          st -Y, temp2
00018e 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
000190 ff02          .dw $ff02
000191 2d64          .db "d-"
000192 017e          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
000193 0194          .dw PFA_DMINUS
                 PFA_DMINUS:
000194 9129          ld temp2, Y+
000195 9139          ld temp3, Y+
                 
000196 90e9          ld temp4, Y+
000197 90f9          ld temp5, Y+
000198 9149          ld temp6, Y+
000199 9159          ld temp7, Y+
                 
00019a 1b42          sub temp6, temp2
00019b 0b53          sbc temp7, temp3
00019c 0ae8          sbc temp4, tosl
00019d 0af9          sbc temp5, tosh
                 
00019e 935a          st -Y, temp7
00019f 934a          st -Y, temp6
0001a0 01c7          movw tosl, temp4
0001a1 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
0001a3 ff07          .dw $ff07
0001a4 6964
0001a5 766e
0001a6 7265
0001a7 0074          .db "dinvert",0
0001a8 0190          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
0001a9 01aa          .dw PFA_DINVERT
                 PFA_DINVERT:
0001aa 9109          ld temp0, Y+
0001ab 9119          ld temp1, Y+
0001ac 9580          com tosl
0001ad 9590          com tosh
0001ae 9500          com temp0
0001af 9510          com temp1
0001b0 931a          st -Y, temp1
0001b1 930a          st -Y, temp0
0001b2 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
0001b4 ff02          .dw $ff02
0001b5 3d64          .db "d="
0001b6 01a3          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
0001b7 1c01          .dw DO_COLON
                 PFA_DEQUAL:
0001b8 0193          .dw XT_DMINUS
0001b9 1e17          .dw XT_OR
0001ba 1d15          .dw XT_ZEROEQUAL
0001bb 1c1b          .dw XT_EXIT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
0001bc ff02          .dw $ff02
0001bd 2e75          .db "u."
0001be 01b4          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
0001bf 1c01          .dw DO_COLON
                 PFA_UDOT:
                 .endif
0001c0 1d4f          .dw XT_ZERO
0001c1 079a          .dw XT_UDDOT
0001c2 1c1b          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
0001c3 ff03          .dw $ff03
0001c4 2e75
0001c5 0072          .db "u.r",0
0001c6 01bc          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
0001c7 1c01          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
0001c8 1d4f          .dw XT_ZERO
0001c9 1cbf          .dw XT_SWAP
0001ca 07a3          .dw XT_UDDOTR
0001cb 1c1b          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
0001cc ff0d          .dw $ff0d
0001cd 6873
0001ce 776f
0001cf 772d
0001d0 726f
0001d1 6c64
0001d2 7369
0001d3 0074          .db "show-wordlist",0
0001d4 01c3          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
0001d5 1c01          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
0001d6 1c38          .dw XT_DOLITERAL
0001d7 01db          .dw XT_SHOWWORD
0001d8 1cbf          .dw XT_SWAP
0001d9 0c99          .dw XT_TRAVERSEWORDLIST
0001da 1c1b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
0001db 1c01          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
0001dc 0cb4          .dw XT_NAME2STRING
0001dd 0810          .dw XT_ITYPE
0001de 0852          .dw XT_SPACE         ; ( -- addr n)
0001df 1d46          .dw XT_TRUE
0001e0 1c1b          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_WORDS:
0001e1 ff05          .dw $ff05
0001e2 6f77
0001e3 6472
0001e4 0073          .db "words",0
0001e5 01cc          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
0001e6 1c01          .dw DO_COLON
                 PFA_WORDS:
                 .endif
0001e7 1c38          .dw XT_DOLITERAL
0001e8 0040          .dw CFG_ORDERLISTLEN+2
0001e9 1f4e          .dw XT_FETCHE
0001ea 01d5          .dw XT_SHOWWORDLIST
0001eb 1c1b          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
0001ec ff04          .dw $ff04
0001ed 692b
0001ee 746e          .db "+int"
0001ef 01e1          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
0001f0 01f1          .dw PFA_INTON
                 PFA_INTON:
0001f1 9478          sei
0001f2 940c 1c05     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
0001f4 ff04          .dw $ff04
0001f5 692d
0001f6 746e          .db "-int"
0001f7 01ec          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
0001f8 01f9          .dw PFA_INTOFF
                 PFA_INTOFF:
0001f9 94f8          cli
0001fa 940c 1c05     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
0001fc ff04          .dw $ff04
0001fd 6e69
0001fe 2174          .db "int!"
0001ff 01f4          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000200 1c01          .dw DO_COLON
                 PFA_INTSTORE:
000201 1c38          .dw XT_DOLITERAL
000202 0000          .dw intvec
000203 1d98          .dw XT_PLUS
000204 1f2a          .dw XT_STOREE
000205 1c1b          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000206 ff04          .dw $ff04
000207 6e69
000208 4074          .db "int@"
000209 01fc          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
00020a 1c01          .dw DO_COLON
                 PFA_INTFETCH:
00020b 1c38          .dw XT_DOLITERAL
00020c 0000          .dw intvec
00020d 1d98          .dw XT_PLUS
00020e 1f4e          .dw XT_FETCHE
00020f 1c1b          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000210 ff08          .dw $ff08
000211 6e69
000212 2d74
000213 7274
000214 7061          .db "int-trap"
000215 0206          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000216 0217          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000217 9380 0076     sts intcur, tosl
000219 9189
00021a 9199          loadtos
00021b 9468          set ; set the interrupt flag for the inner interpreter
00021c 940c 1c05     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
00021e 1c01          .dw DO_COLON
                 PFA_ISREXEC:
00021f 1c38          .dw XT_DOLITERAL
000220 0076          .dw intcur
000221 1c93          .dw XT_CFETCH
000222 1c38          .dw XT_DOLITERAL
000223 0000          .dw intvec
000224 1d98          .dw XT_PLUS
000225 1f4e          .dw XT_FETCHE
000226 1c25          .dw XT_EXECUTE
000227 0229          .dw XT_ISREND
000228 1c1b          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000229 022a          .dw PFA_ISREND
                 PFA_ISREND:
00022a d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
00022b 940c 1c05     jmp_ DO_NEXT
                 PFA_ISREND1:
00022d 9518          reti
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
00022e ff04          .dw $ff04
00022f 6970
000230 6b63          .db "pick"
000231 0210          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
000232 1c01          .dw DO_COLON
                 PFA_PICK:
                 .endif
000233 1e2a          .dw XT_1PLUS
000234 05c2          .dw XT_CELLS
000235 1e7c          .dw XT_SP_FETCH
000236 1d98          .dw XT_PLUS
000237 1c74          .dw XT_FETCH
000238 1c1b          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
000239 0002          .dw $0002
00023a 222e          .db ".",$22
00023b 022e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
00023c 1c01          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
00023d 0244          .dw XT_SQUOTE
00023e 0298          .dw XT_COMPILE
00023f 0810          .dw XT_ITYPE
000240 1c1b          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
000241 0002        .dw $0002
000242 2273        .db "s",$22
000243 0239        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
000244 1c01          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
000245 1c38          .dw XT_DOLITERAL
000246 0022          .dw 34   ; 0x22 
000247 09f0          .dw XT_PARSE       ; ( -- addr n)
000248 05b5          .dw XT_STATE
000249 1c74          .dw XT_FETCH
00024a 1c31          .dw XT_DOCONDBRANCH
00024b 024d          DEST(PFA_SQUOTE1)
00024c 02c4            .dw XT_SLITERAL
                 PFA_SQUOTE1:
00024d 1c1b          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
00024e ff04          .dw $ff04
00024f 6966
000250 6c6c          .db "fill"
000251 0241          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
000252 1c01          .dw DO_COLON
                 PFA_FILL:
000253 1cdc          .dw XT_ROT
000254 1cdc          .dw XT_ROT
000255 1cb4
000256 1c31          .dw XT_QDUP,XT_DOCONDBRANCH
000257 025f          DEST(PFA_FILL2)
000258 0da1          .dw XT_BOUNDS
000259 1e8a          .dw XT_DODO
                 PFA_FILL1:
00025a 1cac          .dw XT_DUP
00025b 1e9b          .dw XT_I
00025c 1c88          .dw XT_CSTORE  ; ( -- c c-addr)
00025d 1eb8          .dw XT_DOLOOP
00025e 025a          .dw PFA_FILL1
                 PFA_FILL2:
00025f 1cd4          .dw XT_DROP
000260 1c1b          .dw XT_EXIT
                 .include "dict/compiler1.inc"
                 
                 .include "words/newest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_NEWEST:
000261 ff06          .dw $ff06
000262 656e
000263 6577
000264 7473          .db "newest"
000265 024e          .dw VE_HEAD
                     .set VE_HEAD = VE_NEWEST
                 XT_NEWEST:
000266 1c43          .dw PFA_DOVARIABLE
                 PFA_NEWEST:
000267 0077          .dw ram_newest
                 
                 .dseg
000077           ram_newest: .byte 4
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_LATEST:
000268 ff06          .dw $ff06
000269 616c
00026a 6574
00026b 7473          .db "latest"
00026c 0261          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
00026d 1c43          .dw PFA_DOVARIABLE
                 PFA_LATEST:
00026e 007b          .dw ram_latest
                 
                 .dseg
00007b           ram_latest: .byte 2
                 .include "words/do-create.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE:
00026f ff08          .dw $ff08
000270 6328
000271 6572
000272 7461
000273 2965          .db "(create)"
000274 0268          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000275 1c01          .dw DO_COLON
                 PFA_DOCREATE:
                 .endif
000276 0a1d
000277 03cc          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
000278 1cac
000279 0266
00027a 05c8
00027b 1c7c          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
00027c 03b1
00027d 0266
00027e 1c7c          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
00027f 1c1b          .DW XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
000280 0001          .dw $0001
000281 005c          .db $5c,0
000282 026f          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
000283 1c01          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
000284 0a04          .dw XT_SOURCE
000285 1ceb          .dw XT_NIP
000286 05e9          .dw XT_TO_IN
000287 1c7c          .dw XT_STORE
000288 1c1b          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
000289 0001          .dw $0001
00028a 0028          .db "(" ,0
00028b 0280          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
00028c 1c01          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
00028d 1c38          .dw XT_DOLITERAL
00028e 0029          .dw ')'
00028f 09f0          .dw XT_PARSE
000290 05d9          .dw XT_2DROP
000291 1c1b          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
000292 ff07          .dw $ff07
000293 6f63
000294 706d
000295 6c69
000296 0065          .db "compile",0
000297 0289          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
000298 1c01          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
000299 1cf1          .dw XT_R_FROM
00029a 1cac          .dw XT_DUP
00029b 0bed          .dw XT_ICELLPLUS
00029c 1cfa          .dw XT_TO_R
00029d 1fbb          .dw XT_FETCHI
00029e 02a3          .dw XT_COMMA
00029f 1c1b          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0002a0 ff01          .dw $ff01
0002a1 002c          .db ',',0 ; ,
0002a2 0292          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0002a3 1c01          .dw DO_COLON
                 PFA_COMMA:
0002a4 0619          .dw XT_DP
0002a5 1f62          .dw XT_STOREI
0002a6 0619          .dw XT_DP
0002a7 1e2a          .dw XT_1PLUS
0002a8 0bdb          .dw XT_DOTO
0002a9 061a          .dw PFA_DP
0002aa 1c1b          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
0002ab 0003          .dw $0003
0002ac 275b
0002ad 005d          .db "[']",0
0002ae 02a0          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0002af 1c01          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
0002b0 087a          .dw XT_TICK
0002b1 02b9          .dw XT_LITERAL
0002b2 1c1b          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
0002b3 0007          .dw $0007
0002b4 696c
0002b5 6574
0002b6 6172
0002b7 006c          .db "literal",0
0002b8 02ab          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
0002b9 1c01          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
0002ba 0298              .DW XT_COMPILE
0002bb 1c38              .DW XT_DOLITERAL
0002bc 02a3              .DW XT_COMMA
0002bd 1c1b              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
0002be 0008        .dw $0008
0002bf 6c73
0002c0 7469
0002c1 7265
0002c2 6c61        .db "sliteral"
0002c3 02b3        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
0002c4 1c01          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
0002c5 0298          .dw XT_COMPILE
0002c6 07dd          .dw XT_DOSLITERAL    ; ( -- addr n)
0002c7 07eb          .dw XT_SCOMMA
0002c8 1c1b          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
0002c9 1c01          .dw DO_COLON
                 PFA_GMARK:
0002ca 0619          .dw XT_DP
0002cb 0298          .dw XT_COMPILE
0002cc ffff          .dw -1           ; ffff does not erase flash
0002cd 1c1b          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
0002ce 1c01          .dw DO_COLON
                 PFA_GRESOLVE:
0002cf 0b99          .dw XT_QSTACK
0002d0 0619          .dw XT_DP
0002d1 1cbf          .dw XT_SWAP
0002d2 1f62          .dw XT_STOREI
0002d3 1c1b          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
0002d4 1c01          .dw DO_COLON
                 PFA_LMARK:
0002d5 0619          .dw XT_DP
0002d6 1c1b          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
0002d7 1c01          .dw DO_COLON
                 PFA_LRESOLVE:
0002d8 0b99          .dw XT_QSTACK
0002d9 02a3          .dw XT_COMMA
0002da 1c1b          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
0002db 0005          .dw $0005
0002dc 6861
0002dd 6165
0002de 0064          .db "ahead",0
0002df 02be          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
0002e0 1c01          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
0002e1 0298          .dw XT_COMPILE
0002e2 1c2a          .dw XT_DOBRANCH
0002e3 02c9          .dw XT_GMARK
0002e4 1c1b          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
0002e5 0002          .dw $0002
0002e6 6669          .db "if"
0002e7 02db          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
0002e8 1c01          .dw DO_COLON
                 PFA_IF:
                 .endif
0002e9 0298          .dw XT_COMPILE
0002ea 1c31          .dw XT_DOCONDBRANCH
0002eb 02c9          .dw XT_GMARK
0002ec 1c1b          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
0002ed 0004          .dw $0004
0002ee 6c65
0002ef 6573          .db "else"
0002f0 02e5          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
0002f1 1c01          .dw DO_COLON
                 PFA_ELSE:
                 .endif
0002f2 0298          .dw XT_COMPILE
0002f3 1c2a          .dw XT_DOBRANCH
0002f4 02c9          .dw XT_GMARK
0002f5 1cbf          .dw XT_SWAP
0002f6 02ce          .dw XT_GRESOLVE
0002f7 1c1b          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
0002f8 0004          .dw $0004
0002f9 6874
0002fa 6e65          .db "then"
0002fb 02ed          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
0002fc 1c01          .dw DO_COLON
                 PFA_THEN:
                 .endif
0002fd 02ce          .dw XT_GRESOLVE
0002fe 1c1b          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
0002ff 0005          .dw $0005
000300 6562
000301 6967
000302 006e          .db "begin",0
000303 02f8          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000304 1c01          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
000305 02d4          .dw XT_LMARK
000306 1c1b          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
000307 0005          .dw $0005
000308 6877
000309 6c69
00030a 0065          .db "while",0
00030b 02ff          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
00030c 1c01          .dw DO_COLON
                 PFA_WHILE:
                 .endif
00030d 02e8          .dw XT_IF
00030e 1cbf          .dw XT_SWAP
00030f 1c1b          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
000310 0006          .dw $0006
000311 6572
000312 6570
000313 7461          .db "repeat"
000314 0307          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000315 1c01          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
000316 0329          .dw XT_AGAIN
000317 02fc          .dw XT_THEN
000318 1c1b          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
000319 0005          .dw $0005
00031a 6e75
00031b 6974
00031c 006c          .db "until",0
00031d 0310          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
00031e 1c01          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
00031f 1c38          .dw XT_DOLITERAL
000320 1c31          .dw XT_DOCONDBRANCH
000321 02a3          .dw XT_COMMA
                 
000322 02d7          .dw XT_LRESOLVE
000323 1c1b          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
000324 0005          .dw $0005
000325 6761
000326 6961
000327 006e          .db "again",0
000328 0319          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000329 1c01          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
00032a 0298          .dw XT_COMPILE
00032b 1c2a          .dw XT_DOBRANCH
00032c 02d7          .dw XT_LRESOLVE
00032d 1c1b          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
00032e 0002          .dw $0002
00032f 6f64          .db "do"
000330 0324          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000331 1c01          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000332 0298          .dw XT_COMPILE
000333 1e8a          .dw XT_DODO
000334 02d4          .dw XT_LMARK
000335 1d4f          .dw XT_ZERO
000336 038c          .dw XT_TO_L
000337 1c1b          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
000338 0004          .dw $0004
000339 6f6c
00033a 706f          .db "loop"
00033b 032e          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
00033c 1c01          .dw DO_COLON
                 PFA_LOOP:
                 .endif
00033d 0298          .dw XT_COMPILE
00033e 1eb8          .dw XT_DOLOOP
00033f 0373          .dw XT_ENDLOOP
000340 1c1b          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000341 0005          .dw $0005
000342 6c2b
000343 6f6f
000344 0070          .db "+loop",0
000345 0338          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000346 1c01          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
000347 0298          .dw XT_COMPILE
000348 1ea9          .dw XT_DOPLUSLOOP
000349 0373          .dw XT_ENDLOOP
00034a 1c1b          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
00034b 0005         .dw $0005
00034c 656c
00034d 7661
00034e 0065         .db "leave",0
00034f 0341         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000350 1c01          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
000351 0298
000352 1ec3          .DW XT_COMPILE,XT_UNLOOP
000353 02e0
000354 038c
000355 1c1b          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
000356 0003          .dw $0003
000357 643f
000358 006f          .db "?do",0
000359 034b          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
00035a 1c01          .dw DO_COLON
                 PFA_QDO:
                 .endif
00035b 0298          .dw XT_COMPILE
00035c 0362          .dw XT_QDOCHECK
00035d 02e8          .dw XT_IF
00035e 0331          .dw XT_DO
00035f 1cbf          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
000360 038c          .dw XT_TO_L    ; then follows at the end.
000361 1c1b          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
000362 1c01          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
000363 05d0          .dw XT_2DUP
000364 1fd0          .dw XT_EQUAL
000365 1cac          .dw XT_DUP
000366 1cfa          .dw XT_TO_R
000367 1c31          .dw XT_DOCONDBRANCH
000368 036a          DEST(PFA_QDOCHECK1)
000369 05d9          .dw XT_2DROP
                 PFA_QDOCHECK1:
00036a 1cf1          .dw XT_R_FROM
00036b 1df8          .dw XT_INVERT
00036c 1c1b          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
00036d ff07          .dw $ff07
00036e 6e65
00036f 6c64
000370 6f6f
000371 0070          .db "endloop",0
000372 0356          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
000373 1c01          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
000374 02d7              .DW XT_LRESOLVE
000375 0380
000376 1cb4
000377 1c31      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
000378 037c               DEST(LOOP2)
000379 02fc              .DW XT_THEN
00037a 1c2a      	.dw XT_DOBRANCH
00037b 0375               DEST(LOOP1)
00037c 1c1b      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
00037d ff02          .dw $ff02
00037e 3e6c          .db "l>"
00037f 036d          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
000380 1c01          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
000381 039f          .dw XT_LP
000382 1c74          .dw XT_FETCH
000383 1c74          .dw XT_FETCH
000384 1c38          .dw XT_DOLITERAL
000385 fffe          .dw -2
000386 039f          .dw XT_LP
000387 1e54          .dw XT_PLUSSTORE
000388 1c1b          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
000389 ff02          .dw $ff02
00038a 6c3e          .db ">l"
00038b 037d          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
00038c 1c01          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
00038d 1fdc              .dw XT_TWO
00038e 039f      	.dw XT_LP
00038f 1e54      	.dw XT_PLUSSTORE
000390 039f      	.dw XT_LP
000391 1c74      	.dw XT_FETCH
000392 1c7c      	.dw XT_STORE
000393 1c1b      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
000394 ff03          .dw $ff03
000395 706c
000396 0030          .db "lp0",0
000397 0389          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
000398 1c6a          .dw PFA_DOVALUE1
                 PFA_LP0:
000399 0034          .dw CFG_LP0
00039a 0bf6          .dw XT_EDEFERFETCH
00039b 0c00          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
00039c ff02          .dw $ff02
00039d 706c          .db "lp"
00039e 0394          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
00039f 1c43          .dw PFA_DOVARIABLE
                 PFA_LP:
0003a0 007d          .dw ram_lp
                 
                 .dseg
00007d           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CREATE:
0003a1 ff06          .dw $ff06
0003a2 7263
0003a3 6165
0003a4 6574          .db "create"
0003a5 039c          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0003a6 1c01          .dw DO_COLON
                 PFA_CREATE:
                 .endif
0003a7 0275          .dw XT_DOCREATE
0003a8 03d5          .dw XT_REVEAL
0003a9 0298          .dw XT_COMPILE
0003aa 1c4d          .dw PFA_DOCONSTANT
0003ab 1c1b          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0003ac ff06          .dw $ff06
0003ad 6568
0003ae 6461
0003af 7265          .db "header"
0003b0 03a1          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0003b1 1c01          .dw DO_COLON
                 PFA_HEADER:
0003b2 0619          .dw XT_DP           ; the new Name Field
0003b3 1cfa          .dw XT_TO_R
0003b4 1cfa          .dw XT_TO_R		; ( R: NFA WID )
0003b5 1cac          .dw XT_DUP    
0003b6 1d23          .dw XT_GREATERZERO 
0003b7 1c31          .dw XT_DOCONDBRANCH
0003b8 03c3          .dw PFA_HEADER1
0003b9 1cac          .dw XT_DUP
0003ba 1c38          .dw XT_DOLITERAL
0003bb ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0003bc 1e17          .dw XT_OR
0003bd 07ef          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0003be 1cf1          .dw XT_R_FROM
0003bf 1f4e          .dw XT_FETCHE
0003c0 02a3          .dw XT_COMMA
0003c1 1cf1          .dw XT_R_FROM
0003c2 1c1b          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0003c3 1c38          .dw XT_DOLITERAL
0003c4 fff0          .dw -16
0003c5 08a9          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0003c6 ff07          .dw $ff07
0003c7 6c77
0003c8 6373
0003c9 706f
0003ca 0065          .db "wlscope",0
0003cb 03ac          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0003cc 0c55          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
0003cd 0032          .dw CFG_WLSCOPE
0003ce 0bf6          .dw XT_EDEFERFETCH
0003cf 0c00          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REVEAL:
0003d0 ff06          .dw $ff06
0003d1 6572
0003d2 6576
0003d3 6c61          .db "reveal"
0003d4 03c6          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
0003d5 1c01          .dw DO_COLON
                 PFA_REVEAL:
                 .endif
0003d6 0266
0003d7 05c8
0003d8 1c74          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
0003d9 1cb4
0003da 1c31          .DW XT_QDUP,XT_DOCONDBRANCH
0003db 03e0          DEST(REVEAL1)
0003dc 0266
0003dd 1c74
0003de 1cbf
0003df 1f2a          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                 REVEAL1:
0003e0 1c1b          .DW XT_EXIT
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
0003e1 0005          .dw $0005
0003e2 6f64
0003e3 7365
0003e4 003e          .db "does>",0
0003e5 03d0          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
0003e6 1c01          .dw DO_COLON
                 PFA_DOES:
0003e7 0298          .dw XT_COMPILE
0003e8 03f9          .dw XT_DODOES
0003e9 0298          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
0003ea 940e          .dw $940e       ; the address of this compiled
0003eb 0298          .dw XT_COMPILE  ; code will replace the XT of the 
0003ec 03ee          .dw DO_DODOES   ; word that CREATE created
0003ed 1c1b          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
0003ee 939a
0003ef 938a          savetos
0003f0 01cb          movw tosl, wl
0003f1 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
0003f2 917f          pop wh
0003f3 916f          pop wl
                 
0003f4 93bf          push XH
0003f5 93af          push XL
0003f6 01db          movw XL, wl
0003f7 940c 1c05     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
0003f9 1c01          .dw DO_COLON
                 PFA_DODOES:
0003fa 1cf1          .dw XT_R_FROM
0003fb 0266          .dw XT_NEWEST
0003fc 05c8          .dw XT_CELLPLUS
0003fd 1c74          .dw XT_FETCH
0003fe 1f4e          .dw XT_FETCHE
0003ff 0cc0          .dw XT_NFA2CFA
000400 1f62          .dw XT_STOREI
000401 1c1b          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
000402 ff01          .dw $ff01
000403 003a          .db ":",0
000404 03e1          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000405 1c01          .dw DO_COLON
                 PFA_COLON:
                 .endif
000406 0275          .dw XT_DOCREATE
000407 0410          .dw XT_COLONNONAME
000408 1cd4          .dw XT_DROP
000409 1c1b          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
00040a ff07          .dw $ff07
00040b 6e3a
00040c 6e6f
00040d 6d61
00040e 0065          .db ":noname",0
00040f 0402          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000410 1c01          .dw DO_COLON
                 PFA_COLONNONAME:
000411 0619          .dw XT_DP
000412 1cac          .dw XT_DUP
000413 026d          .dw XT_LATEST
000414 1c7c          .dw XT_STORE
                 
000415 0298          .dw XT_COMPILE
000416 1c01          .dw DO_COLON
                 
000417 0425          .dw XT_RBRACKET
000418 1c1b          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
000419 0001          .dw $0001
00041a 003b          .db $3b,0
00041b 040a          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
00041c 1c01          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
00041d 0298          .dw XT_COMPILE
00041e 1c1b          .dw XT_EXIT
00041f 042d          .dw XT_LBRACKET
000420 03d5          .dw XT_REVEAL
000421 1c1b          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
000422 ff01          .dw $ff01
000423 005d          .db "]",0
000424 0419          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000425 1c01          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
000426 1fd7          .dw XT_ONE
000427 05b5          .dw XT_STATE
000428 1c7c          .dw XT_STORE
000429 1c1b          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
00042a 0001          .dw $0001
00042b 005b          .db "[",0
00042c 0422          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
00042d 1c01          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
00042e 1d4f          .dw XT_ZERO
00042f 05b5          .dw XT_STATE
000430 1c7c          .dw XT_STORE
000431 1c1b          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
000432 ff08          .dw $ff08
000433 6176
000434 6972
000435 6261
000436 656c          .db "variable"
000437 042a          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000438 1c01          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
000439 062a          .dw XT_HERE
00043a 0444          .dw XT_CONSTANT
00043b 1fdc          .dw XT_TWO
00043c 0633          .dw XT_ALLOT
00043d 1c1b          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
00043e ff08          .dw $ff08
00043f 6f63
000440 736e
000441 6174
000442 746e          .db "constant"
000443 0432          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000444 1c01          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000445 0275          .dw XT_DOCREATE
000446 03d5          .dw XT_REVEAL
000447 0298          .dw XT_COMPILE
000448 1c43          .dw PFA_DOVARIABLE
000449 02a3          .dw XT_COMMA
00044a 1c1b          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
00044b ff04          .dw $ff04
00044c 7375
00044d 7265          .db "user"
00044e 043e          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
00044f 1c01          .dw DO_COLON
                 PFA_USER:
000450 0275          .dw XT_DOCREATE
000451 03d5          .dw XT_REVEAL
                 
000452 0298          .dw XT_COMPILE
000453 1c53          .dw PFA_DOUSER
000454 02a3          .dw XT_COMMA
000455 1c1b          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECURSE:
000456 0007          .dw $0007
000457 6572
000458 7563
000459 7372
00045a 0065          .db "recurse",0
00045b 044b          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
00045c 1c01          .dw DO_COLON
                 PFA_RECURSE:
                 .endif
00045d 026d          .dw XT_LATEST
00045e 1c74          .dw XT_FETCH
00045f 02a3          .dw XT_COMMA
000460 1c1b          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000461 ff09          .dw $ff09
000462 6d69
000463 656d
000464 6964
000465 7461
000466 0065          .db "immediate",0
000467 0456          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000468 1c01          .dw DO_COLON
                 PFA_IMMEDIATE:
000469 0503          .dw XT_GET_CURRENT
00046a 1f4e          .dw XT_FETCHE
00046b 1cac          .dw XT_DUP
00046c 1fbb          .dw XT_FETCHI
00046d 1c38          .dw XT_DOLITERAL
00046e 7fff          .dw $7fff
00046f 1e0e          .dw XT_AND
000470 1cbf          .dw XT_SWAP
000471 1f62          .dw XT_STOREI
000472 1c1b          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
000473 0006          .dw $0006
000474 635b
000475 6168
000476 5d72          .db "[char]"
000477 0461          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000478 1c01          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
000479 0298          .dw XT_COMPILE
00047a 1c38          .dw XT_DOLITERAL
00047b 0952          .dw XT_CHAR
00047c 02a3          .dw XT_COMMA
00047d 1c1b          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
00047e 0006          .dw $0006
00047f 6261
000480 726f
000481 2274          .db "abort",'"'
000482 0473          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
000483 1c01          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
000484 0244          .dw XT_SQUOTE
000485 0298          .dw XT_COMPILE
000486 0495          .dw XT_QABORT
000487 1c1b          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
000488 ff05          .dw $ff05
000489 6261
00048a 726f
00048b 0074          .db "abort",0
00048c 047e          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
00048d 1c01          .dw DO_COLON
                 PFA_ABORT:
                 .endif
00048e 1d46          .dw XT_TRUE
00048f 08a9          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
000490 ff06          .dw $ff06
000491 613f
000492 6f62
000493 7472          .db "?abort"
000494 0488          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
000495 1c01          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
000496 1cdc
000497 1c31              .DW XT_ROT,XT_DOCONDBRANCH
000498 049b              DEST(QABO1)
000499 0810
00049a 048d              .DW XT_ITYPE,XT_ABORT
00049b 05d9
00049c 1c1b      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
00049d ff09          .dw $ff09
00049e 6567
00049f 2d74
0004a0 7473
0004a1 6361
0004a2 006b          .db "get-stack",0
0004a3 0490          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
0004a4 1c01          .dw DO_COLON
                 .endif
0004a5 1cac          .dw XT_DUP
0004a6 05c8          .dw XT_CELLPLUS
0004a7 1cbf          .dw XT_SWAP
0004a8 1f4e          .dw XT_FETCHE
0004a9 1cac          .dw XT_DUP
0004aa 1cfa          .dw XT_TO_R
0004ab 1d4f          .dw XT_ZERO
0004ac 1cbf          .dw XT_SWAP    ; go from bigger to smaller addresses
0004ad 0362          .dw XT_QDOCHECK
0004ae 1c31          .dw XT_DOCONDBRANCH
0004af 04bb          DEST(PFA_N_FETCH_E2)
0004b0 1e8a          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
0004b1 1e9b          .dw XT_I
0004b2 1e30          .dw XT_1MINUS
0004b3 05c2          .dw XT_CELLS ; ( -- ee-addr i*2 )
0004b4 1cca          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
0004b5 1d98          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
0004b6 1f4e          .dw XT_FETCHE ;( -- ee-addr item_i )
0004b7 1cbf          .dw XT_SWAP   ;( -- item_i ee-addr )
0004b8 1d46          .dw XT_TRUE  ; shortcut for -1
0004b9 1ea9          .dw XT_DOPLUSLOOP
0004ba 04b1          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
0004bb 05d9          .dw XT_2DROP
0004bc 1cf1          .dw XT_R_FROM
0004bd 1c1b          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
0004be ff09          .dw $ff09
0004bf 6573
0004c0 2d74
0004c1 7473
0004c2 6361
0004c3 006b          .db "set-stack",0
0004c4 049d          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
0004c5 1c01          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
0004c6 05d0          .dw XT_2DUP
0004c7 1f2a          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
0004c8 1cbf          .dw XT_SWAP    
0004c9 1d4f          .dw XT_ZERO
0004ca 0362          .dw XT_QDOCHECK
0004cb 1c31          .dw XT_DOCONDBRANCH
0004cc 04d3          DEST(PFA_SET_STACK2)
0004cd 1e8a          .dw XT_DODO
                 PFA_SET_STACK1:
0004ce 05c8          .dw XT_CELLPLUS ; ( -- i_x e-addr )
0004cf 05e1          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
0004d0 1f2a          .dw XT_STOREE
0004d1 1eb8          .dw XT_DOLOOP
0004d2 04ce          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
0004d3 1cd4          .dw XT_DROP
0004d4 1c1b          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
0004d5 ff09          .dw $ff09
0004d6 616d
0004d7 2d70
0004d8 7473
0004d9 6361
0004da 006b          .db "map-stack",0
0004db 04be          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
0004dc 1c01          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
0004dd 1cac          .dw XT_DUP
0004de 05c8          .dw XT_CELLPLUS
0004df 1cbf          .dw XT_SWAP
0004e0 1f4e          .dw XT_FETCHE
0004e1 05c2          .dw XT_CELLS
0004e2 0da1          .dw XT_BOUNDS
0004e3 0362          .dw XT_QDOCHECK
0004e4 1c31          .dw XT_DOCONDBRANCH
0004e5 04f8          DEST(PFA_MAPSTACK3)
0004e6 1e8a          .dw XT_DODO
                 PFA_MAPSTACK1:
0004e7 1e9b            .dw XT_I
0004e8 1f4e            .dw XT_FETCHE   ; -- i*x XT id
0004e9 1cbf            .dw XT_SWAP
0004ea 1cfa            .dw XT_TO_R
0004eb 1d03            .dw XT_R_FETCH
0004ec 1c25            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
0004ed 1cb4            .dw XT_QDUP
0004ee 1c31            .dw XT_DOCONDBRANCH
0004ef 04f4            DEST(PFA_MAPSTACK2)
0004f0 1cf1               .dw XT_R_FROM
0004f1 1cd4               .dw XT_DROP
0004f2 1ec3               .dw XT_UNLOOP
0004f3 1c1b               .dw XT_EXIT
                 PFA_MAPSTACK2:
0004f4 1cf1            .dw XT_R_FROM
0004f5 1fdc            .dw XT_TWO
0004f6 1ea9            .dw XT_DOPLUSLOOP
0004f7 04e7            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
0004f8 1cd4          .dw XT_DROP
0004f9 1d4f          .dw XT_ZERO
0004fa 1c1b          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
0004fb ff0b          .dw $ff0b
0004fc 6567
0004fd 2d74
0004fe 7563
0004ff 7272
000500 6e65
000501 0074          .db "get-current",0
000502 04d5          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000503 1c01          .dw DO_COLON
                 PFA_GET_CURRENT:
000504 1c38          .dw XT_DOLITERAL
000505 003a          .dw CFG_CURRENT
000506 1f4e          .dw XT_FETCHE
000507 1c1b          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_ORDER:
000508 ff09          .dw $ff09
000509 6567
00050a 2d74
00050b 726f
00050c 6564
00050d 0072          .db "get-order",0
00050e 04fb          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
00050f 1c01          .dw DO_COLON
                 PFA_GET_ORDER:
                 .endif
000510 1c38          .dw XT_DOLITERAL
000511 003e          .dw CFG_ORDERLISTLEN
000512 04a4          .dw XT_GET_STACK
000513 1c1b          .dw XT_EXIT
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000514 ff07          .dw $ff07
000515 6f63
000516 706d
000517 7261
000518 0065          .db "compare",0
000519 0508          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
00051a 051b          .dw PFA_COMPARE
                 PFA_COMPARE:
00051b 93bf          push xh
00051c 93af          push xl
00051d 018c          movw temp0, tosl
00051e 9189
00051f 9199          loadtos
000520 01dc          movw xl, tosl
000521 9189
000522 9199          loadtos
000523 019c          movw temp2, tosl
000524 9189
000525 9199          loadtos
000526 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000527 90ed          ld temp4, X+
000528 90f1          ld temp5, Z+
000529 14ef          cp temp4, temp5
00052a f451          brne PFA_COMPARE_NOTEQUAL
00052b 950a          dec temp0
00052c f019          breq PFA_COMPARE_ENDREACHED2
00052d 952a          dec temp2
00052e f7c1          brne PFA_COMPARE_LOOP
00052f c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000530 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000531 2b02          or temp0, temp2
000532 f411          brne PFA_COMPARE_CHECKLASTCHAR
000533 2788          clr tosl
000534 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000535 ef8f          ser tosl
000536 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000537 2f98          mov tosh, tosl
000538 91af          pop xl
000539 91bf          pop xh
00053a 940c 1c05     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
00053c ff07         .dw $ff07
00053d 666e
00053e 3e61
00053f 666c
000540 0061         .db "nfa>lfa",0
000541 0514         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000542 1c01          .dw DO_COLON
                 PFA_NFA2LFA:
000543 0cb4          .dw XT_NAME2STRING
000544 1e2a          .dw XT_1PLUS
000545 1dff          .dw XT_2SLASH
000546 1d98          .dw XT_PLUS
000547 1c1b          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000548 ff0b          .dw $ff0b
000549 6e65
00054a 6976
00054b 6f72
00054c 6d6e
00054d 6e65
00054e 0074          .db "environment",0
00054f 053c          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
000550 1c43          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000551 0038          .dw CFG_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000552 ff09          .dw $ff09
000553 6f77
000554 6472
000555 696c
000556 7473
000557 0073          .db "wordlists",0
000558 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000559 1c01          .dw DO_COLON
                 PFA_ENVWORDLISTS:
00055a 1c38          .dw XT_DOLITERAL
00055b 0008          .dw NUMWORDLISTS
00055c 1c1b          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
00055d ff04          .dw $ff04
00055e 702f
00055f 6461          .db "/pad"
000560 0552          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
000561 1c01          .dw DO_COLON
                 PFA_ENVSLASHPAD:
000562 1e7c          .dw XT_SP_FETCH
000563 05ef          .dw XT_PAD
000564 1d8e          .dw XT_MINUS
000565 1c1b          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENVSLASHHOLD:
000566 ff05          .dw $ff05
000567 682f
000568 6c6f
000569 0064          .db "/hold",0
00056a 055d          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
00056b 1c01          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
                 .endif
00056c 05ef          .dw XT_PAD
00056d 062a          .dw XT_HERE
00056e 1d8e          .dw XT_MINUS
00056f 1c1b          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
000570 ff0a          .dw $ff0a
000571 6f66
000572 7472
000573 2d68
000574 616e
000575 656d          .db "forth-name"
000576 0566          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
000577 1c01          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000578 07dd          .dw XT_DOSLITERAL
000579 0007          .dw 7
                 .endif
00057a 6d61
00057b 6f66
00057c 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
00057d 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
00057e 1c1b          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
00057f ff07          .dw $ff07
000580 6576
000581 7372
000582 6f69
000583 006e          .db "version",0
000584 0570          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
000585 1c01          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
000586 1c38          .dw XT_DOLITERAL
000587 003d          .dw 61
000588 1c1b          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
000589 ff03          .dw $ff03
00058a 7063
00058b 0075          .db "cpu",0
00058c 057f          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
00058d 1c01          .dw DO_COLON
                 PFA_EN_CPU:
                 .endif
00058e 1c38          .dw XT_DOLITERAL
00058f 002d          .dw mcu_name
000590 083c          .dw XT_ICOUNT
000591 1c1b          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
000592 ff08          .dw $ff08
000593 636d
000594 2d75
000595 6e69
000596 6f66          .db "mcu-info"
000597 0589          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000598 1c01          .dw DO_COLON
                 PFA_EN_MCUINFO:
000599 1c38          .dw XT_DOLITERAL
00059a 0029          .dw mcu_info
00059b 1c1b          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_ENVUSERSIZE:
00059c ff05          .dw $ff05
00059d 752f
00059e 6573
00059f 0072          .db "/user",0
0005a0 0592          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
0005a1 1c01          .dw DO_COLON
                 PFA_ENVUSERSIZE:
                 .endif
0005a2 1c38          .dw XT_DOLITERAL
0005a3 0026          .dw SYSUSERSIZE + APPUSERSIZE
0005a4 1c1b          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
0005a5 ff05          .dw $ff05
0005a6 5f66
0005a7 7063
0005a8 0075          .db "f_cpu",0
0005a9 0548          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
0005aa 1c01          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
0005ab 1c38          .dw XT_DOLITERAL
0005ac 1200          .dw (F_CPU % 65536)
0005ad 1c38          .dw XT_DOLITERAL
0005ae 007a          .dw (F_CPU / 65536)
0005af 1c1b          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
0005b0 ff05          .dw $ff05
0005b1 7473
0005b2 7461
0005b3 0065          .db "state",0
0005b4 05a5          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
0005b5 1c43          .dw PFA_DOVARIABLE
                 PFA_STATE:
0005b6 007f          .dw ram_state
                 
                 .dseg
00007f           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
0005b7 ff04          .dw $ff04
0005b8 6162
0005b9 6573          .db "base"
0005ba 05b0          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
0005bb 1c53          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
0005bc 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
0005bd ff05          .dw $ff05
0005be 6563
0005bf 6c6c
0005c0 0073          .db "cells",0
0005c1 05b7          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
0005c2 1e07          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
0005c3 ff05          .dw $ff05
0005c4 6563
0005c5 6c6c
0005c6 002b          .db "cell+",0
0005c7 05bd          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
0005c8 05c9          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
0005c9 9602          adiw tosl, CELLSIZE
0005ca 940c 1c05     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
0005cc ff04          .dw $ff04
0005cd 6432
0005ce 7075          .db "2dup"
0005cf 05c3          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
0005d0 1c01          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
0005d1 1cca          .dw XT_OVER
0005d2 1cca          .dw XT_OVER
0005d3 1c1b          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
0005d4 ff05          .dw $ff05
0005d5 6432
0005d6 6f72
0005d7 0070          .db "2drop",0
0005d8 05cc          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
0005d9 1c01          .dw DO_COLON
                 PFA_2DROP:
                 .endif
0005da 1cd4          .dw XT_DROP
0005db 1cd4          .dw XT_DROP
0005dc 1c1b          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
0005dd ff04          .dw $ff04
0005de 7574
0005df 6b63          .db "tuck"
0005e0 05d4          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
0005e1 1c01          .dw DO_COLON
                 PFA_TUCK:
                 .endif
0005e2 1cbf          .dw XT_SWAP
0005e3 1cca          .dw XT_OVER
0005e4 1c1b          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
0005e5 ff03          .dw $ff03
0005e6 693e
0005e7 006e          .db ">in",0
0005e8 05dd          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
0005e9 1c53          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
0005ea 0018          .dw USER_TO_IN
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PAD:
0005eb ff03          .dw $ff03
0005ec 6170
0005ed 0064          .db "pad",0
0005ee 05e5          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
0005ef 1c01          .dw DO_COLON
                 PFA_PAD:
                 .endif
0005f0 062a          .dw XT_HERE
0005f1 1c38          .dw XT_DOLITERAL
0005f2 0028          .dw 40
0005f3 1d98          .dw XT_PLUS
0005f4 1c1b          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMIT:
0005f5 ff04          .dw $ff04
0005f6 6d65
0005f7 7469          .db "emit"
0005f8 05eb          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
0005f9 0c55          .dw PFA_DODEFER1
                 PFA_EMIT:
                 .endif
0005fa 000e          .dw USER_EMIT
0005fb 0c1e          .dw XT_UDEFERFETCH
0005fc 0c2a          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMITQ:
0005fd ff05          .dw $ff05
0005fe 6d65
0005ff 7469
000600 003f          .db "emit?",0
000601 05f5          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
000602 0c55          .dw PFA_DODEFER1
                 PFA_EMITQ:
                 .endif
000603 0010          .dw USER_EMITQ
000604 0c1e          .dw XT_UDEFERFETCH
000605 0c2a          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEY:
000606 ff03          .dw $ff03
000607 656b
000608 0079          .db "key",0
000609 05fd          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
00060a 0c55          .dw PFA_DODEFER1
                 PFA_KEY:
                 .endif
00060b 0012          .dw USER_KEY
00060c 0c1e          .dw XT_UDEFERFETCH
00060d 0c2a          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEYQ:
00060e ff04          .dw $ff04
00060f 656b
000610 3f79          .db "key?"
000611 0606          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
000612 0c55          .dw PFA_DODEFER1
                 PFA_KEYQ:
                 .endif
000613 0014          .dw USER_KEYQ
000614 0c1e          .dw XT_UDEFERFETCH
000615 0c2a          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
000616 ff02          .dw $ff02
000617 7064          .db "dp"
000618 060e          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
000619 1c6a          .dw PFA_DOVALUE1
                 PFA_DP:
00061a 002c          .dw CFG_DP
00061b 0bf6          .dw XT_EDEFERFETCH
00061c 0c00          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
00061d ff05          .dw $ff05
00061e 6865
00061f 7265
000620 0065          .db "ehere",0
000621 0616          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
000622 1c6a          .dw PFA_DOVALUE1
                 PFA_EHERE:
000623 0030          .dw EE_EHERE
000624 0bf6          .dw XT_EDEFERFETCH
000625 0c00          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
000626 ff04          .dw $ff04
000627 6568
000628 6572          .db "here"
000629 061d          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
00062a 1c6a          .dw PFA_DOVALUE1
                 PFA_HERE:
00062b 002e          .dw EE_HERE
00062c 0bf6          .dw XT_EDEFERFETCH
00062d 0c00          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
00062e ff05          .dw $ff05
00062f 6c61
000630 6f6c
000631 0074          .db "allot",0
000632 0626          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
000633 1c01          .dw DO_COLON
                 PFA_ALLOT:
000634 062a          .dw XT_HERE
000635 1d98          .dw XT_PLUS
000636 0bdb          .dw XT_DOTO
000637 062b          .dw PFA_HERE
000638 1c1b          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
000639 ff03          .dw $ff03
00063a 6962
00063b 006e          .db "bin",0
00063c 062e          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
00063d 1c01          .dw DO_COLON
                 PFA_BIN:
                 .endif
00063e 1fdc          .dw XT_TWO
00063f 05bb          .dw XT_BASE
000640 1c7c          .dw XT_STORE
000641 1c1b          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
000642 ff07          .dw $ff07
000643 6564
000644 6963
000645 616d
000646 006c          .db "decimal",0
000647 0639          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
000648 1c01          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
000649 1c38          .dw XT_DOLITERAL
00064a 000a          .dw 10
00064b 05bb          .dw XT_BASE
00064c 1c7c          .dw XT_STORE
00064d 1c1b          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
00064e ff03          .dw $ff03
00064f 6568
000650 0078          .db "hex",0
000651 0642          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
000652 1c01          .dw DO_COLON
                 PFA_HEX:
                 .endif
000653 1c38          .dw XT_DOLITERAL
000654 0010          .dw 16
000655 05bb          .dw XT_BASE
000656 1c7c          .dw XT_STORE
000657 1c1b          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
000658 ff02          .dw $ff02
000659 6c62          .db "bl"
00065a 064e          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
00065b 1c43          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
00065c 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
00065d ff07          .dw $ff07
00065e 7574
00065f 6e72
000660 656b
000661 0079          .db "turnkey",0
000662 0658          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
000663 0c55          .dw PFA_DODEFER1
                 PFA_TURNKEY:
000664 0036          .dw CFG_TURNKEY
000665 0bf6          .dw XT_EDEFERFETCH
000666 0c00          .dw XT_EDEFERSTORE
                 
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
000667 ff04          .dw $ff04
000668 6d2f
000669 646f          .db "/mod"
00066a 065d          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
00066b 066c          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
00066c 019c          movw temp2, tosl
                     
00066d 9109          ld temp0, Y+
00066e 9119          ld temp1, Y+
                 
00066f 2f41          mov	temp6,temp1	;move dividend High to sign register
000670 2743          eor	temp6,temp3	;xor divisor High with sign register
000671 ff17          sbrs	temp1,7	;if MSB in dividend set
000672 c004          rjmp	PFA_SLASHMOD_1
000673 9510          com	temp1		;    change sign of dividend
000674 9500          com	temp0		
000675 5f0f          subi	temp0,low(-1)
000676 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
000677 ff37          sbrs	temp3,7	;if MSB in divisor set
000678 c004          rjmp	PFA_SLASHMOD_2
000679 9530          com	temp3		;    change sign of divisor
00067a 9520          com	temp2		
00067b 5f2f          subi	temp2,low(-1)
00067c 4f3f          sbci	temp3,high(-1)
00067d 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
00067e 18ff          sub	temp5,temp5;clear remainder High byte and carry
00067f e151          ldi	temp7,17	;init loop counter
                 
000680 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
000681 1f11          rol	temp1
000682 955a          dec	temp7		;decrement counter
000683 f439          brne	PFA_SLASHMOD_5		;if done
000684 ff47          sbrs	temp6,7		;    if MSB in sign register set
000685 c004          rjmp	PFA_SLASHMOD_4
000686 9510          com	temp1	;        change sign of result
000687 9500          com	temp0
000688 5f0f          subi	temp0,low(-1)
000689 4f1f          sbci	temp1,high(-1)
00068a c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
00068b 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
00068c 1cff          rol	temp5
00068d 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
00068e 0af3          sbc	temp5,temp3	;
00068f f420          brcc	PFA_SLASHMOD_6		;if result negative
000690 0ee2          add	temp4,temp2	;    restore remainder
000691 1ef3          adc	temp5,temp3
000692 9488          clc			;    clear carry to be shifted into result
000693 cfec          rjmp	PFA_SLASHMOD_3		;else
000694 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
000695 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
000696 92fa          st -Y,temp5
000697 92ea          st -Y,temp4
                 
                     ; put quotient on stack
000698 01c8          movw tosl, temp0
000699 940c 1c05     jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
00069b ff05          .dw $ff05
00069c 2f75
00069d 6f6d
00069e 0064          .db "u/mod",0
00069f 0667          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
0006a0 1c01          .dw DO_COLON
                 PFA_USLASHMOD:
0006a1 1cfa          .dw XT_TO_R
0006a2 1d4f          .dw XT_ZERO
0006a3 1cf1          .dw XT_R_FROM
0006a4 1dbd          .dw XT_UMSLASHMOD
0006a5 1c1b          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
0006a6 ff06          .dw $ff06
0006a7 656e
0006a8 6167
0006a9 6574          .db "negate"
0006aa 069b          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
0006ab 1c01          .dw DO_COLON
                 PFA_NEGATE:
0006ac 1df8          .dw XT_INVERT
0006ad 1e2a          .dw XT_1PLUS
0006ae 1c1b          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
0006af ff01          .dw $ff01
0006b0 002f          .db "/",0
0006b1 06a6          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
0006b2 1c01          .dw DO_COLON
                 PFA_SLASH:
                 .endif
0006b3 066b          .dw XT_SLASHMOD
0006b4 1ceb          .dw XT_NIP
0006b5 1c1b          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
0006b6 ff03          .dw $ff03
0006b7 6f6d
0006b8 0064          .db "mod",0
0006b9 06af          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
0006ba 1c01          .dw DO_COLON
                 PFA_MOD:
                 .endif
0006bb 066b          .dw XT_SLASHMOD
0006bc 1cd4          .dw XT_DROP
0006bd 1c1b          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
0006be ff03          .dw $ff03
0006bf 6261
0006c0 0073          .db "abs",0
0006c1 06b6          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
0006c2 06c3          .dw PFA_ABS
                 PFA_ABS:
0006c3 2399          tst tosh
0006c4 f41a          brpl PFA_ABS1
0006c5 9580          com tosl
0006c6 9590          com tosh
0006c7 9601          adiw tosl, 1
                 PFA_ABS1:
0006c8 940c 1c05     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
0006ca ff03          .dw $ff03
0006cb 696d
0006cc 006e          .db "min",0
0006cd 06be          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
0006ce 1c01          .dw DO_COLON
                 PFA_MIN:
                 .endif
0006cf 05d0          .dw XT_2DUP
0006d0 1d73          .dw XT_GREATER
0006d1 1c31          .dw XT_DOCONDBRANCH
0006d2 06d4          DEST(PFA_MIN1)
0006d3 1cbf          .dw XT_SWAP
                 PFA_MIN1:
0006d4 1cd4          .dw XT_DROP
0006d5 1c1b          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
0006d6 ff03          .dw $ff03
0006d7 616d
0006d8 0078          .db "max",0
0006d9 06ca          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
0006da 1c01          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
0006db 05d0          .dw XT_2DUP
0006dc 1d69          .dw XT_LESS
0006dd 1c31          .dw XT_DOCONDBRANCH
0006de 06e0          DEST(PFA_MAX1)
0006df 1cbf          .dw XT_SWAP
                 PFA_MAX1:
0006e0 1cd4          .dw XT_DROP
0006e1 1c1b          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
0006e2 ff06          .dw $ff06
0006e3 6977
0006e4 6874
0006e5 6e69          .db "within"
0006e6 06d6          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
0006e7 1c01          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
0006e8 1cca          .dw XT_OVER
0006e9 1d8e          .dw XT_MINUS
0006ea 1cfa          .dw XT_TO_R
0006eb 1d8e          .dw XT_MINUS
0006ec 1cf1          .dw XT_R_FROM
0006ed 1d57          .dw XT_ULESS
0006ee 1c1b          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
0006ef ff07          .dw $ff07 
0006f0 6f74
0006f1 7075
0006f2 6570
0006f3 0072          .db "toupper",0
0006f4 06e2          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
0006f5 1c01          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
0006f6 1cac          .dw XT_DUP 
0006f7 1c38          .dw XT_DOLITERAL 
0006f8 0061          .dw 'a' 
0006f9 1c38          .dw XT_DOLITERAL 
0006fa 007b          .dw 'z'+1
0006fb 06e7          .dw XT_WITHIN 
0006fc 1c31          .dw XT_DOCONDBRANCH
0006fd 0701          DEST(PFA_TOUPPER0)
0006fe 1c38          .dw XT_DOLITERAL
0006ff 00df          .dw 223 ; inverse of 0x20: 0xdf
000700 1e0e          .dw XT_AND 
                 PFA_TOUPPER0:
000701 1c1b          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
000702 ff07          .dw $ff07
000703 6f74
000704 6f6c
000705 6577
000706 0072          .db "tolower",0
000707 06ef          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
000708 1c01          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
000709 1cac          .dw XT_DUP
00070a 1c38          .dw XT_DOLITERAL
00070b 0041          .dw 'A'
00070c 1c38          .dw XT_DOLITERAL
00070d 005b          .dw 'Z'+1
00070e 06e7          .dw XT_WITHIN
00070f 1c31          .dw XT_DOCONDBRANCH
000710 0714          DEST(PFA_TOLOWER0)
000711 1c38          .dw XT_DOLITERAL
000712 0020          .dw 32
000713 1e17          .dw XT_OR 
                 PFA_TOLOWER0:
000714 1c1b          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
000715 ff03          .dw $ff03
000716 6c68
000717 0064          .db "hld",0
000718 0702          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
000719 1c43          .dw PFA_DOVARIABLE
                 PFA_HLD:
00071a 0081          .dw ram_hld
                 
                 .dseg
000081           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
00071b ff04          .dw $ff04
00071c 6f68
00071d 646c          .db "hold"
00071e 0715          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
00071f 1c01          .dw DO_COLON
                 PFA_HOLD:
                 .endif
000720 0719          .dw XT_HLD
000721 1cac          .dw XT_DUP
000722 1c74          .dw XT_FETCH
000723 1e30          .dw XT_1MINUS
000724 1cac          .dw XT_DUP
000725 1cfa          .dw XT_TO_R
000726 1cbf          .dw XT_SWAP
000727 1c7c          .dw XT_STORE
000728 1cf1          .dw XT_R_FROM
000729 1c88          .dw XT_CSTORE
00072a 1c1b          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
00072b ff02          .dw $ff02
00072c 233c          .db "<#"
00072d 071b          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
00072e 1c01          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
00072f 05ef          .dw XT_PAD
000730 0719          .dw XT_HLD
000731 1c7c          .dw XT_STORE
000732 1c1b          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
000733 ff01          .dw $ff01
000734 0023          .db "#",0
000735 072b          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
000736 1c01          .dw DO_COLON
                 PFA_SHARP:
                 .endif
000737 05bb          .dw XT_BASE
000738 1c74          .dw XT_FETCH
000739 07b3          .dw XT_UDSLASHMOD
00073a 1cdc          .dw XT_ROT
00073b 1c38          .dw XT_DOLITERAL
00073c 0009          .dw 9
00073d 1cca          .dw XT_OVER
00073e 1d69          .dw XT_LESS
00073f 1c31          .dw XT_DOCONDBRANCH
000740 0744          DEST(PFA_SHARP1)
000741 1c38          .dw XT_DOLITERAL
000742 0007          .dw 7
000743 1d98          .dw XT_PLUS
                 PFA_SHARP1:
000744 1c38          .dw XT_DOLITERAL
000745 0030          .dw 48 ; ASCII 0
000746 1d98          .dw XT_PLUS
000747 071f          .dw XT_HOLD
000748 1c1b          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
000749 ff02          .dw $ff02
00074a 7323          .db "#s"
00074b 0733          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
00074c 1c01          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
00074d 0736          .dw XT_SHARP
00074e 05d0          .dw XT_2DUP
00074f 1e17          .dw XT_OR
000750 1d15          .dw XT_ZEROEQUAL
000751 1c31          .dw XT_DOCONDBRANCH
000752 074d          DEST(NUMS1) ; PFA_SHARP_S
000753 1c1b          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
000754 ff02          .dw $ff02
000755 3e23          .db "#>"
000756 0749          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
000757 1c01          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
000758 05d9          .dw XT_2DROP
000759 0719          .dw XT_HLD
00075a 1c74          .dw XT_FETCH
00075b 05ef          .dw XT_PAD
00075c 1cca          .dw XT_OVER
00075d 1d8e          .dw XT_MINUS
00075e 1c1b          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
00075f ff04          .dw $ff04
000760 6973
000761 6e67          .db "sign"
000762 0754          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
000763 1c01          .dw DO_COLON
                 PFA_SIGN:
                 .endif
000764 1d1c          .dw XT_ZEROLESS
000765 1c31          .dw XT_DOCONDBRANCH
000766 076a          DEST(PFA_SIGN1)
000767 1c38          .dw XT_DOLITERAL
000768 002d          .dw 45 ; ascii -
000769 071f          .dw XT_HOLD
                 PFA_SIGN1:
00076a 1c1b          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
00076b ff03          .dw $ff03
00076c 2e64
00076d 0072          .db "d.r",0
00076e 075f          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
00076f 1c01          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
000770 1cfa          .dw XT_TO_R
000771 05e1          .dw XT_TUCK
000772 0d16          .dw XT_DABS
000773 072e          .dw XT_L_SHARP
000774 074c          .dw XT_SHARP_S
000775 1cdc          .dw XT_ROT
000776 0763          .dw XT_SIGN
000777 0757          .dw XT_SHARP_G
000778 1cf1          .dw XT_R_FROM
000779 1cca          .dw XT_OVER
00077a 1d8e          .dw XT_MINUS
00077b 085b          .dw XT_SPACES
00077c 086b          .dw XT_TYPE
00077d 1c1b          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
00077e ff02          .dw $ff02
00077f 722e          .db ".r"
000780 076b          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
000781 1c01          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
000782 1cfa          .dw XT_TO_R
000783 0daa          .dw XT_S2D
000784 1cf1          .dw XT_R_FROM
000785 076f          .dw XT_DDOTR
000786 1c1b          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
000787 ff02          .dw $ff02
000788 2e64          .db "d."
000789 077e          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
00078a 1c01          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
00078b 1d4f          .dw XT_ZERO
00078c 076f          .dw XT_DDOTR
00078d 0852          .dw XT_SPACE
00078e 1c1b          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
00078f ff01          .dw $ff01
000790 002e          .db ".",0
000791 0787          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000792 1c01          .dw DO_COLON
                 PFA_DOT:
                 .endif
000793 0daa          .dw XT_S2D
000794 078a          .dw XT_DDOT
000795 1c1b          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
000796 ff03          .dw $ff03
000797 6475
000798 002e          .db "ud.",0
000799 078f          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
00079a 1c01          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
00079b 1d4f          .dw XT_ZERO
00079c 07a3          .dw XT_UDDOTR
00079d 0852          .dw XT_SPACE
00079e 1c1b          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
00079f ff04          .dw $ff04
0007a0 6475
0007a1 722e          .db "ud.r"
0007a2 0796          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
0007a3 1c01          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
0007a4 1cfa          .dw XT_TO_R
0007a5 072e          .dw XT_L_SHARP
0007a6 074c          .dw XT_SHARP_S
0007a7 0757          .dw XT_SHARP_G
0007a8 1cf1          .dw XT_R_FROM
0007a9 1cca          .dw XT_OVER
0007aa 1d8e          .dw XT_MINUS
0007ab 085b          .dw XT_SPACES
0007ac 086b          .dw XT_TYPE
0007ad 1c1b          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
0007ae ff06          .dw $ff06
0007af 6475
0007b0 6d2f
0007b1 646f          .db "ud/mod"
0007b2 079f          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
0007b3 1c01          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
0007b4 1cfa          .dw XT_TO_R
0007b5 1d4f          .dw XT_ZERO
0007b6 1d03          .dw XT_R_FETCH
0007b7 1dbd          .dw XT_UMSLASHMOD
0007b8 1cf1          .dw XT_R_FROM
0007b9 1cbf          .dw XT_SWAP
0007ba 1cfa          .dw XT_TO_R
0007bb 1dbd          .dw XT_UMSLASHMOD
0007bc 1cf1          .dw XT_R_FROM
0007bd 1c1b          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
0007be ff06          .dw $ff06 
0007bf 6964
0007c0 6967
0007c1 3f74          .db "digit?"
0007c2 07ae          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
0007c3 1c01          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
0007c4 06f5          .dw XT_TOUPPER
0007c5 1cac
0007c6 1c38
0007c7 0039
0007c8 1d73
0007c9 1c38
0007ca 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
0007cb 1e0e
0007cc 1d98
0007cd 1cac
0007ce 1c38
0007cf 0140
0007d0 1d73          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
0007d1 1c38
0007d2 0107
0007d3 1e0e
0007d4 1d8e
0007d5 1c38
0007d6 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
0007d7 1d8e
0007d8 1cac
0007d9 05bb
0007da 1c74
0007db 1d57          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
0007dc 1c1b          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
0007dd 1c01        .dw DO_COLON
                 PFA_DOSLITERAL:
0007de 1d03        .dw XT_R_FETCH   ; ( -- addr )
0007df 083c        .dw XT_ICOUNT
0007e0 1cf1        .dw XT_R_FROM
0007e1 1cca        .dw XT_OVER     ; ( -- addr' n addr n)
0007e2 1e2a        .dw XT_1PLUS
0007e3 1dff        .dw XT_2SLASH   ; ( -- addr' n addr k )
0007e4 1d98        .dw XT_PLUS     ; ( -- addr' n addr'' )
0007e5 1e2a        .dw XT_1PLUS
0007e6 1cfa        .dw XT_TO_R     ; ( -- )
0007e7 1c1b        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
0007e8 ff02        .dw $ff02
0007e9 2c73        .db "s",$2c
0007ea 07be        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
0007eb 1c01          .dw DO_COLON
                 PFA_SCOMMA:
0007ec 1cac          .dw XT_DUP
0007ed 07ef          .dw XT_DOSCOMMA
0007ee 1c1b          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0007ef 1c01          .dw DO_COLON
                 PFA_DOSCOMMA:
0007f0 02a3          .dw XT_COMMA
0007f1 1cac          .dw XT_DUP   ; ( --addr len len)
0007f2 1dff          .dw XT_2SLASH ; ( -- addr len len/2
0007f3 05e1          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0007f4 1e06          .dw XT_2STAR  ; ( -- addr len/2 len len'
0007f5 1d8e          .dw XT_MINUS  ; ( -- addr len/2 rem
0007f6 1cfa          .dw XT_TO_R
0007f7 1d4f          .dw XT_ZERO
0007f8 0362          .dw XT_QDOCHECK
0007f9 1c31          .dw XT_DOCONDBRANCH
0007fa 0802          .dw PFA_SCOMMA2
0007fb 1e8a          .dw XT_DODO
                 PFA_SCOMMA1:
0007fc 1cac          .dw XT_DUP         ; ( -- addr addr )
0007fd 1c74          .dw XT_FETCH       ; ( -- addr c1c2 )
0007fe 02a3          .dw XT_COMMA       ; ( -- addr )
0007ff 05c8          .dw XT_CELLPLUS    ; ( -- addr+cell )
000800 1eb8          .dw XT_DOLOOP
000801 07fc          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
000802 1cf1          .dw XT_R_FROM
000803 1d23          .dw XT_GREATERZERO
000804 1c31          .dw XT_DOCONDBRANCH
000805 0809          .dw PFA_SCOMMA3
000806 1cac            .dw XT_DUP     ; well, tricky
000807 1c93            .dw XT_CFETCH
000808 02a3            .dw XT_COMMA
                 PFA_SCOMMA3:
000809 1cd4          .dw XT_DROP        ; ( -- )
00080a 1c1b          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
00080b ff05          .dw $ff05
00080c 7469
00080d 7079
00080e 0065          .db "itype",0
00080f 07e8          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
000810 1c01          .dw DO_COLON
                 PFA_ITYPE:
000811 1cac          .dw XT_DUP    ; ( --addr len len)
000812 1dff          .dw XT_2SLASH ; ( -- addr len len/2
000813 05e1          .dw XT_TUCK   ; ( -- addr len/2 len len/2
000814 1e06          .dw XT_2STAR  ; ( -- addr len/2 len len'
000815 1d8e          .dw XT_MINUS  ; ( -- addr len/2 rem
000816 1cfa          .dw XT_TO_R
000817 1d4f          .dw XT_ZERO
000818 0362          .dw XT_QDOCHECK
000819 1c31          .dw XT_DOCONDBRANCH
00081a 0824          .dw PFA_ITYPE2
00081b 1e8a          .dw XT_DODO
                 PFA_ITYPE1:
00081c 1cac          .dw XT_DUP         ; ( -- addr addr )
00081d 1fbb          .dw XT_FETCHI      ; ( -- addr c1c2 )
00081e 1cac          .dw XT_DUP
00081f 0831          .dw XT_LOWEMIT
000820 082d          .dw XT_HIEMIT
000821 1e2a          .dw XT_1PLUS    ; ( -- addr+cell )
000822 1eb8          .dw XT_DOLOOP
000823 081c          .dw PFA_ITYPE1
                 PFA_ITYPE2:
000824 1cf1          .dw XT_R_FROM
000825 1d23          .dw XT_GREATERZERO
000826 1c31          .dw XT_DOCONDBRANCH
000827 082b          .dw PFA_ITYPE3
000828 1cac            .dw XT_DUP     ; make sure the drop below has always something to do
000829 1fbb            .dw XT_FETCHI
00082a 0831            .dw XT_LOWEMIT
                 PFA_ITYPE3:
00082b 1cd4          .dw XT_DROP
00082c 1c1b          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
00082d 1c01          .dw DO_COLON
                 PFA_HIEMIT:
00082e 1ee8          .dw XT_BYTESWAP
00082f 0831          .dw XT_LOWEMIT
000830 1c1b          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
000831 1c01          .dw DO_COLON
                 PFA_LOWEMIT:
000832 1c38          .dw XT_DOLITERAL
000833 00ff          .dw $00ff
000834 1e0e          .dw XT_AND
000835 05f9          .dw XT_EMIT
000836 1c1b          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
000837 ff06          .dw $ff06
000838 6369
000839 756f
00083a 746e          .db "icount"
00083b 080b          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
00083c 1c01          .dw DO_COLON
                 PFA_ICOUNT:
00083d 1cac          .dw XT_DUP
00083e 1e2a          .dw XT_1PLUS
00083f 1cbf          .dw XT_SWAP
000840 1fbb          .dw XT_FETCHI
000841 1c1b          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
000842 ff02          .dw 0xff02
000843 7263          .db "cr"
000844 0837          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
000845 1c01          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
000846 1c38          .dw XT_DOLITERAL
000847 000d          .dw 13
000848 05f9          .dw XT_EMIT
000849 1c38          .dw XT_DOLITERAL
00084a 000a          .dw 10
00084b 05f9          .dw XT_EMIT
00084c 1c1b          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
00084d ff05          .dw $ff05
00084e 7073
00084f 6361
000850 0065          .db "space",0
000851 0842          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
000852 1c01          .dw DO_COLON
                 PFA_SPACE:
                 .endif
000853 065b          .dw XT_BL
000854 05f9          .dw XT_EMIT
000855 1c1b          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
000856 ff06          .dw $ff06
000857 7073
000858 6361
000859 7365          .db "spaces"
00085a 084d          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
00085b 1c01          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
00085c 1d4f
00085d 06da      	.DW XT_ZERO, XT_MAX
00085e 1cac
00085f 1c31      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
000860 0865              DEST(SPCS2)
000861 0852
000862 1e30
000863 1c2a              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
000864 085e              DEST(SPCS1)
000865 1cd4
000866 1c1b      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
000867 ff04          .dw $ff04
000868 7974
000869 6570          .db "type"
00086a 0856          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
00086b 1c01          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
00086c 0da1          .dw XT_BOUNDS
00086d 0362          .dw XT_QDOCHECK
00086e 1c31          .dw XT_DOCONDBRANCH
00086f 0876          DEST(PFA_TYPE2)
000870 1e8a          .dw XT_DODO
                 PFA_TYPE1:
000871 1e9b          .dw XT_I
000872 1c93          .dw XT_CFETCH
000873 05f9          .dw XT_EMIT
000874 1eb8          .dw XT_DOLOOP
000875 0871          DEST(PFA_TYPE1)
                 PFA_TYPE2:
000876 1c1b          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
000877 ff01          .dw $ff01
000878 0027          .db "'",0
000879 0867          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
00087a 1c01          .dw DO_COLON
                 PFA_TICK:
                 .endif
00087b 0a1d          .dw XT_PARSENAME
00087c 0b01          .dw XT_DORECOGNIZER
00087d 0b77          .dw XT_R_WORD
00087e 1fd0          .dw XT_EQUAL
00087f 1c31          .dw XT_DOCONDBRANCH
000880 0883          DEST(PFA_TICK1)
000881 1cd4          .dw XT_DROP
000882 1c1b          .dw XT_EXIT
                 PFA_TICK1:
000883 1c38          .dw XT_DOLITERAL
000884 fff3          .dw -13
000885 08a9          .dw XT_THROW
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
000886 ff07          .dw $ff07
000887 6168
000888 646e
000889 656c
00088a 0072          .db "handler",0
00088b 0877          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
00088c 1c53          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
00088d 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
00088e ff05          .dw $ff05
00088f 6163
000890 6374
000891 0068          .db "catch",0
000892 0886          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
000893 1c01          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
000894 1e7c          .dw XT_SP_FETCH
000895 1cfa          .dw XT_TO_R
                     ; handler @ >r
000896 088c          .dw XT_HANDLER
000897 1c74          .dw XT_FETCH
000898 1cfa          .dw XT_TO_R
                     ; rp@ handler !
000899 1e65          .dw XT_RP_FETCH
00089a 088c          .dw XT_HANDLER
00089b 1c7c          .dw XT_STORE
00089c 1c25          .dw XT_EXECUTE
                     ; r> handler !
00089d 1cf1          .dw XT_R_FROM
00089e 088c          .dw XT_HANDLER
00089f 1c7c          .dw XT_STORE
0008a0 1cf1          .dw XT_R_FROM
0008a1 1cd4          .dw XT_DROP
0008a2 1d4f          .dw XT_ZERO
0008a3 1c1b          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
0008a4 ff05          .dw $ff05
0008a5 6874
0008a6 6f72
0008a7 0077          .db "throw",0
0008a8 088e          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
0008a9 1c01          .dw DO_COLON
                 PFA_THROW:
                 .endif
0008aa 1cac          .dw XT_DUP
0008ab 1d15          .dw XT_ZEROEQUAL
0008ac 1c31          .dw XT_DOCONDBRANCH
0008ad 08b0          DEST(PFA_THROW1)
0008ae 1cd4      	.dw XT_DROP
0008af 1c1b      	.dw XT_EXIT
                 PFA_THROW1:
0008b0 088c          .dw XT_HANDLER
0008b1 1c74          .dw XT_FETCH
0008b2 1e6f          .dw XT_RP_STORE
0008b3 1cf1          .dw XT_R_FROM
0008b4 088c          .dw XT_HANDLER
0008b5 1c7c          .dw XT_STORE
0008b6 1cf1          .dw XT_R_FROM
0008b7 1cbf          .dw XT_SWAP
0008b8 1cfa          .dw XT_TO_R
0008b9 1e85          .dw XT_SP_STORE
0008ba 1cd4          .dw XT_DROP
0008bb 1cf1          .dw XT_R_FROM    
0008bc 1c1b          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
0008bd ff05          .dw $ff05
0008be 7363
0008bf 696b
0008c0 0070          .db "cskip",0
0008c1 08a4          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
0008c2 1c01          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
0008c3 1cfa          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
0008c4 1cac          .dw XT_DUP            ; ( -- addr' n' n' )
0008c5 1c31          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0008c6 08d1          DEST(PFA_CSKIP2)
0008c7 1cca          .dw XT_OVER           ; ( -- addr' n' addr' )
0008c8 1c93          .dw XT_CFETCH         ; ( -- addr' n' c' )
0008c9 1d03          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
0008ca 1fd0          .dw XT_EQUAL          ; ( -- addr' n' f )
0008cb 1c31          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
0008cc 08d1          DEST(PFA_CSKIP2)
0008cd 1fd7          .dw XT_ONE
0008ce 0a0e          .dw XT_SLASHSTRING
0008cf 1c2a          .dw XT_DOBRANCH
0008d0 08c4          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
0008d1 1cf1          .dw XT_R_FROM
0008d2 1cd4          .dw XT_DROP           ; ( -- addr2 n2)
0008d3 1c1b          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
0008d4 ff05          .dw $ff05
0008d5 7363
0008d6 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
0008d7 006e          .db "cscan"
0008d8 08bd          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
0008d9 1c01          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
0008da 1cfa          .dw XT_TO_R
0008db 1cca          .dw XT_OVER
                 PFA_CSCAN1:
0008dc 1cac          .dw XT_DUP
0008dd 1c93          .dw XT_CFETCH
0008de 1d03          .dw XT_R_FETCH
0008df 1fd0          .dw XT_EQUAL
0008e0 1d15          .dw XT_ZEROEQUAL
0008e1 1c31          .dw XT_DOCONDBRANCH
0008e2 08ee          DEST(PFA_CSCAN2)
0008e3 1cbf            .dw XT_SWAP
0008e4 1e30            .dw XT_1MINUS
0008e5 1cbf            .dw XT_SWAP
0008e6 1cca            .dw XT_OVER
0008e7 1d1c            .dw XT_ZEROLESS ; not negative
0008e8 1d15            .dw XT_ZEROEQUAL
0008e9 1c31            .dw XT_DOCONDBRANCH
0008ea 08ee            DEST(PFA_CSCAN2)
0008eb 1e2a              .dw XT_1PLUS
0008ec 1c2a              .dw XT_DOBRANCH
0008ed 08dc              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
0008ee 1ceb          .dw XT_NIP
0008ef 1cca          .dw XT_OVER
0008f0 1d8e          .dw XT_MINUS
0008f1 1cf1          .dw XT_R_FROM
0008f2 1cd4          .dw XT_DROP
0008f3 1c1b          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
0008f4 ff06          .dw $ff06
0008f5 6361
0008f6 6563
0008f7 7470          .db "accept"
0008f8 08d4          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
0008f9 1c01          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
0008fa 1cca
0008fb 1d98
0008fc 1e30
0008fd 1cca              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
0008fe 060a
0008ff 1cac
000900 093a
000901 1d15
000902 1c31      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
000903 092c              DEST(ACC5)
000904 1cac
000905 1c38
000906 0008
000907 1fd0
000908 1c31              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
000909 091c              DEST(ACC3)
00090a 1cd4
00090b 1cdc
00090c 05d0
00090d 1d73
00090e 1cfa
00090f 1cdc
000910 1cdc
000911 1cf1
000912 1c31              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
000913 091a      	DEST(ACC6)
000914 0932
000915 1e30
000916 1cfa
000917 1cca
000918 1cf1
000919 0133      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
00091a 1c2a      ACC6:   .DW XT_DOBRANCH
00091b 092a              DEST(ACC4)
                     
                 
                 ACC3:    ; check for remaining control characters, replace them with blank
00091c 1cac      	.dw XT_DUP            ; ( -- addr k k )
00091d 065b              .dw XT_BL
00091e 1d69              .dw XT_LESS
00091f 1c31              .dw XT_DOCONDBRANCH
000920 0923              DEST(PFA_ACCEPT6)
000921 1cd4              .dw XT_DROP
000922 065b              .dw XT_BL
                 PFA_ACCEPT6:
000923 1cac
000924 05f9
000925 1cca
000926 1c88
000927 1e2a
000928 1cca
000929 013f      	.DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
00092a 1c2a      ACC4:   .DW XT_DOBRANCH
00092b 08fe              DEST(ACC1)
00092c 1cd4
00092d 1ceb
00092e 1cbf
00092f 1d8e
000930 0845
000931 1c1b      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
000932 1c01          .dw DO_COLON
                 .endif
000933 1c38          .dw XT_DOLITERAL
000934 0008          .dw 8
000935 1cac          .dw XT_DUP
000936 05f9          .dw XT_EMIT
000937 0852          .dw XT_SPACE
000938 05f9          .dw XT_EMIT
000939 1c1b          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
00093a 1c01          .dw DO_COLON
                 .endif
00093b 1cac          .dw XT_DUP
00093c 1c38          .dw XT_DOLITERAL
00093d 000d          .dw 13
00093e 1fd0          .dw XT_EQUAL
00093f 1cbf          .dw XT_SWAP
000940 1c38          .dw XT_DOLITERAL
000941 000a          .dw 10
000942 1fd0          .dw XT_EQUAL
000943 1e17          .dw XT_OR
000944 1c1b          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILL:
000945 ff06          .dw $ff06
000946 6572
000947 6966
000948 6c6c          .db "refill"
000949 08f4          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
00094a 0c55          .dw PFA_DODEFER1
                 PFA_REFILL:
                 .endif
00094b 001a          .dw USER_REFILL
00094c 0c1e          .dw XT_UDEFERFETCH
00094d 0c2a          .dw XT_UDEFERSTORE
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
00094e ff04          .dw $ff04
00094f 6863
000950 7261          .db "char"
000951 0945          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
000952 1c01          .dw DO_COLON
                 PFA_CHAR:
                 .endif
000953 0a1d          .dw XT_PARSENAME
000954 1cd4          .dw XT_DROP
000955 1c93          .dw XT_CFETCH
000956 1c1b          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
000957 ff06          .dw $ff06
000958 756e
000959 626d
00095a 7265          .db "number"
00095b 094e          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
00095c 1c01          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
00095d 05bb          .dw XT_BASE
00095e 1c74          .dw XT_FETCH
00095f 1cfa          .dw XT_TO_R
000960 09a0          .dw XT_QSIGN
000961 1cfa          .dw XT_TO_R
000962 09b3          .dw XT_SET_BASE
000963 09a0          .dw XT_QSIGN
000964 1cf1          .dw XT_R_FROM
000965 1e17          .dw XT_OR
000966 1cfa          .dw XT_TO_R
                     ; check whether something is left
000967 1cac          .dw XT_DUP
000968 1d15          .dw XT_ZEROEQUAL
000969 1c31          .dw XT_DOCONDBRANCH
00096a 0973          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
00096b 05d9            .dw XT_2DROP
00096c 1cf1            .dw XT_R_FROM
00096d 1cd4            .dw XT_DROP
00096e 1cf1            .dw XT_R_FROM
00096f 05bb            .dw XT_BASE
000970 1c7c            .dw XT_STORE
000971 1d4f            .dw XT_ZERO
000972 1c1b            .dw XT_EXIT
                 PFA_NUMBER0:
000973 1f0d          .dw XT_2TO_R
000974 1d4f          .dw XT_ZERO       ; starting value
000975 1d4f          .dw XT_ZERO
000976 1f1c          .dw XT_2R_FROM
000977 09d1          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
000978 1cb4          .dw XT_QDUP
000979 1c31          .dw XT_DOCONDBRANCH
00097a 0995          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
00097b 1fd7          .dw XT_ONE
00097c 1fd0          .dw XT_EQUAL
00097d 1c31          .dw XT_DOCONDBRANCH
00097e 098c          DEST(PFA_NUMBER2)
                 	; excatly one character is left
00097f 1c93      	.dw XT_CFETCH
000980 1c38      	.dw XT_DOLITERAL
000981 002e      	.dw 46 ; .
000982 1fd0      	.dw XT_EQUAL
000983 1c31      	.dw XT_DOCONDBRANCH
000984 098d      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
000985 1cf1      	.dw XT_R_FROM
000986 1c31              .dw XT_DOCONDBRANCH
000987 0989      	DEST(PFA_NUMBER3)
000988 0d23              .dw XT_DNEGATE
                 PFA_NUMBER3:
000989 1fdc      	.dw XT_TWO
00098a 1c2a      	.dw XT_DOBRANCH
00098b 099b      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
00098c 1cd4      	.dw XT_DROP
                 PFA_NUMBER6:
00098d 05d9      	.dw XT_2DROP
00098e 1cf1      	.dw XT_R_FROM
00098f 1cd4      	.dw XT_DROP
000990 1cf1              .dw XT_R_FROM
000991 05bb              .dw XT_BASE
000992 1c7c              .dw XT_STORE
000993 1d4f      	.dw XT_ZERO
000994 1c1b      	.dw XT_EXIT
                 PFA_NUMBER1:
000995 05d9          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
000996 1cf1          .dw XT_R_FROM
000997 1c31          .dw XT_DOCONDBRANCH
000998 099a          DEST(PFA_NUMBER4)
000999 06ab          .dw XT_NEGATE
                 PFA_NUMBER4:
00099a 1fd7          .dw XT_ONE
                 PFA_NUMBER5:
00099b 1cf1          .dw XT_R_FROM
00099c 05bb          .dw XT_BASE
00099d 1c7c          .dw XT_STORE
00099e 1d46          .dw XT_TRUE
00099f 1c1b          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
0009a0 1c01          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
0009a1 1cca          .dw XT_OVER    ; ( -- addr len addr )
0009a2 1c93          .dw XT_CFETCH
0009a3 1c38          .dw XT_DOLITERAL
0009a4 002d          .dw '-'
0009a5 1fd0          .dw XT_EQUAL  ; ( -- addr len flag )
0009a6 1cac          .dw XT_DUP
0009a7 1cfa          .dw XT_TO_R
0009a8 1c31          .dw XT_DOCONDBRANCH
0009a9 09ac          DEST(PFA_NUMBERSIGN_DONE)
0009aa 1fd7          .dw XT_ONE    ; skip sign character
0009ab 0a0e          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
0009ac 1cf1          .dw XT_R_FROM
0009ad 1c1b          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
0009ae 1c4d          .dw PFA_DOCONSTANT
                 .endif
0009af 000a
0009b0 0010
0009b1 0002
0009b2 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
0009b3 1c01          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
0009b4 1cca          .dw XT_OVER
0009b5 1c93          .dw XT_CFETCH
0009b6 1c38          .dw XT_DOLITERAL
0009b7 0023          .dw 35
0009b8 1d8e          .dw XT_MINUS
0009b9 1cac          .dw XT_DUP
0009ba 1d4f          .dw XT_ZERO
0009bb 1c38          .dw XT_DOLITERAL
0009bc 0004          .dw 4
0009bd 06e7          .dw XT_WITHIN
0009be 1c31          .dw XT_DOCONDBRANCH
0009bf 09c9          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
0009c0 09ae      	.dw XT_BASES
0009c1 1d98      	.dw XT_PLUS
0009c2 1fbb      	.dw XT_FETCHI
0009c3 05bb      	.dw XT_BASE
0009c4 1c7c      	.dw XT_STORE
0009c5 1fd7      	.dw XT_ONE
0009c6 0a0e      	.dw XT_SLASHSTRING
0009c7 1c2a      	.dw XT_DOBRANCH
0009c8 09ca      	DEST(SET_BASE2)
                 SET_BASE1:
0009c9 1cd4      	.dw XT_DROP
                 SET_BASE2:
0009ca 1c1b          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
0009cb ff07          .dw $ff07
0009cc 6e3e
0009cd 6d75
0009ce 6562
0009cf 0072          .db ">number",0
0009d0 0957          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
0009d1 1c01          .dw DO_COLON
                 
                 .endif
                 
0009d2 1cac
0009d3 1c31      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
0009d4 09ea              DEST(TONUM3)
0009d5 1cca
0009d6 1c93
0009d7 07c3              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
0009d8 1d15
0009d9 1c31              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
0009da 09dd              DEST(TONUM2)
0009db 1cd4
0009dc 1c1b              .DW XT_DROP,XT_EXIT
0009dd 1cfa
0009de 0d48
0009df 05bb
0009e0 1c74
0009e1 0124      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
0009e2 1cf1
0009e3 011c
0009e4 0d48              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
0009e5 1c38
0009e6 0001
0009e7 0a0e
0009e8 1c2a              .DW XT_DOLITERAL,1,XT_SLASHSTRING,XT_DOBRANCH
0009e9 09d2              DEST(TONUM1)
0009ea 1c1b      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
0009eb ff05          .dw $ff05
0009ec 6170
0009ed 7372
0009ee 0065          .db "parse",0
0009ef 09cb          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
0009f0 1c01          .dw DO_COLON
                 PFA_PARSE:
                 .endif
0009f1 1cfa          .dw XT_TO_R     ; ( -- )
0009f2 0a04          .dw XT_SOURCE   ; ( -- addr len)
0009f3 05e9          .dw XT_TO_IN     ; ( -- addr len >in)
0009f4 1c74          .dw XT_FETCH
0009f5 0a0e          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
0009f6 1cf1          .dw XT_R_FROM      ; ( -- addr' len' c)
0009f7 08d9          .dw XT_CSCAN       ; ( -- addr' len'')
0009f8 1cac          .dw XT_DUP         ; ( -- addr' len'' len'')
0009f9 1e2a          .dw XT_1PLUS
0009fa 05e9          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
0009fb 1e54          .dw XT_PLUSSTORE   ; ( -- addr' len')
0009fc 1fd7          .dw XT_ONE
0009fd 0a0e          .dw XT_SLASHSTRING
0009fe 1c1b          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCE:
0009ff ff06          .dw $FF06
000a00 6f73
000a01 7275
000a02 6563          .db "source"
000a03 09eb          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
000a04 0c55          .dw PFA_DODEFER1
                 PFA_SOURCE:
                 .endif
000a05 0016          .dw USER_SOURCE
000a06 0c1e          .dw XT_UDEFERFETCH
000a07 0c2a          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
000a08 ff07          .dw $ff07
000a09 732f
000a0a 7274
000a0b 6e69
000a0c 0067          .db "/string",0
000a0d 09ff          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
000a0e 1c01          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
000a0f 1cdc          .dw XT_ROT
000a10 1cca          .dw XT_OVER
000a11 1d98          .dw XT_PLUS
000a12 1cdc          .dw XT_ROT
000a13 1cdc          .dw XT_ROT
000a14 1d8e          .dw XT_MINUS
000a15 1c1b          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
000a16 ff0a          .dw $FF0A 
000a17 6170
000a18 7372
000a19 2d65
000a1a 616e
000a1b 656d          .db "parse-name"
000a1c 0a08          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
000a1d 1c01          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
000a1e 065b          .dw XT_BL
000a1f 0a21          .dw XT_SKIPSCANCHAR
000a20 1c1b          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
000a21 1c01          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
000a22 1cfa          .dw XT_TO_R
000a23 0a04          .dw XT_SOURCE 
000a24 05e9          .dw XT_TO_IN 
000a25 1c74          .dw XT_FETCH 
000a26 0a0e          .dw XT_SLASHSTRING 
                 
000a27 1d03          .dw XT_R_FETCH
000a28 08c2          .dw XT_CSKIP
000a29 1cf1          .dw XT_R_FROM
000a2a 08d9          .dw XT_CSCAN
                 
                     ; adjust >IN
000a2b 05d0          .dw XT_2DUP
000a2c 1d98          .dw XT_PLUS
000a2d 0a04          .dw XT_SOURCE 
000a2e 1cd4          .dw XT_DROP
000a2f 1d8e          .dw XT_MINUS
000a30 05e9          .dw XT_TO_IN
000a31 1c7c          .dw XT_STORE
000a32 1c1b          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the name from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDNAME:
000a33 ff09          .dw $ff09
000a34 6966
000a35 646e
000a36 6e2d
000a37 6d61
000a38 0065          .db "find-name",0
000a39 0a16          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
000a3a 1c01          .dw DO_COLON
                 PFA_FINDNAME:
                 .endif
000a3b 1c38          .dw XT_DOLITERAL
000a3c 0a46          .dw XT_FINDNAMEA
000a3d 1c38          .dw XT_DOLITERAL
000a3e 003e          .dw CFG_ORDERLISTLEN
000a3f 04dc          .dw XT_MAPSTACK
000a40 1d15          .dw XT_ZEROEQUAL
000a41 1c31          .dw XT_DOCONDBRANCH
000a42 0a45          DEST(PFA_FINDNAME1)
000a43 05d9            .dw XT_2DROP
000a44 1d4f            .dw XT_ZERO
                 PFA_FINDNAME1:
000a45 1c1b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDNAMEA:
000a46 1c01          .dw DO_COLON
                 PFA_FINDNAMEA:
                 .endif
000a47 1cfa          .dw XT_TO_R
000a48 05d0          .dw XT_2DUP
000a49 1cf1          .dw XT_R_FROM
000a4a 0c67          .dw XT_SEARCH_WORDLIST
000a4b 1cac          .dw XT_DUP
000a4c 1c31          .dw XT_DOCONDBRANCH
000a4d 0a53          DEST(PFA_FINDNAMEA1)
000a4e 1cfa            .dw XT_TO_R
000a4f 1ceb            .dw XT_NIP
000a50 1ceb            .dw XT_NIP
000a51 1cf1            .dw XT_R_FROM
000a52 1d46            .dw XT_TRUE
                 PFA_FINDNAMEA1:
000a53 1c1b          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
000a54 ff04          .dw $ff04
000a55 7571
000a56 7469          .db "quit"
000a57 0a33          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
000a58 1c01          .dw DO_COLON
                 PFA_QUIT:
                 .endif
                 PFA_QUIT1:
000a59 0398
000a5a 039f
000a5b 1c7c          .dw XT_LP0,XT_LP,XT_STORE
000a5c 0ad9          .dw XT_SP0
000a5d 1e85          .dw XT_SP_STORE
000a5e 0ae6          .dw XT_RP0
000a5f 1e6f          .dw XT_RP_STORE
000a60 042d          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000a61 05b5          .dw XT_STATE
000a62 1c74          .dw XT_FETCH
000a63 1d15          .dw XT_ZEROEQUAL
000a64 1c31          .dw XT_DOCONDBRANCH
000a65 0a67          DEST(PFA_QUIT4)
000a66 0a84          .dw XT_PROMPTREADY
                 PFA_QUIT4:
000a67 094a          .dw XT_REFILL
000a68 1c31          .dw XT_DOCONDBRANCH
000a69 0a61          DEST(PFA_QUIT2)
000a6a 1c38          .dw XT_DOLITERAL
000a6b 0b29          .dw XT_INTERPRET
000a6c 0893          .dw XT_CATCH
000a6d 1cb4          .dw XT_QDUP
000a6e 1c31          .dw XT_DOCONDBRANCH
000a6f 0a79          DEST(PFA_QUIT3)
000a70 1cac      	.dw XT_DUP
000a71 1c38      	.dw XT_DOLITERAL
000a72 fffe      	.dw -2
000a73 1d69      	.dw XT_LESS
000a74 1c31      	.dw XT_DOCONDBRANCH
000a75 0a77      	DEST(PFA_QUIT5)
000a76 0a8b      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000a77 1c2a      	.dw XT_DOBRANCH
000a78 0a59      	DEST(PFA_QUIT1)
                 PFA_QUIT3:
000a79 0a7d          .dw XT_PROMPTOK
000a7a 1c2a          .dw XT_DOBRANCH
000a7b 0a61          DEST(PFA_QUIT2)
000a7c 1c1b          .dw XT_EXIT ; never reached
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000a7d 1c01          .dw DO_COLON
                 PFA_PROMPTOK:
000a7e 07dd          .dw XT_DOSLITERAL
000a7f 0003          .dw 3
000a80 6f20
000a81 006b          .db " ok",0
                 .endif
000a82 0810          .dw XT_ITYPE
000a83 1c1b          .dw XT_EXIT
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTREADY:
000a84 1c01          .dw DO_COLON
                 PFA_PROMPTREADY:
000a85 07dd          .dw XT_DOSLITERAL
000a86 0002          .dw 2
000a87 203e          .db "> "
                 .endif
000a88 0845          .dw XT_CR
000a89 0810          .dw XT_ITYPE
000a8a 1c1b          .dw XT_EXIT
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
000a8b 1c01          .dw DO_COLON
                 PFA_PROMPTERROR:
000a8c 07dd      	.dw XT_DOSLITERAL
000a8d 0004          .dw 4
000a8e 3f20
000a8f 203f          .db " ?? "
                 .endif
000a90 0810          .dw XT_ITYPE
000a91 05bb          .dw XT_BASE
000a92 1c74          .dw XT_FETCH
000a93 1cfa          .dw XT_TO_R
000a94 0648          .dw XT_DECIMAL
000a95 0792          .dw XT_DOT
000a96 05e9          .dw XT_TO_IN
000a97 1c74          .dw XT_FETCH
000a98 0792          .dw XT_DOT
000a99 1cf1          .dw XT_R_FROM
000a9a 05bb          .dw XT_BASE
000a9b 1c7c          .dw XT_STORE
000a9c 1c1b          .dw XT_EXIT
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000a9d ff05          .dw $ff05
000a9e 6170
000a9f 7375
000aa0 0065          .db "pause",0
000aa1 0a54          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000aa2 0c55          .dw PFA_DODEFER1
                 PFA_PAUSE:
000aa3 0083          .dw ram_pause
000aa4 0c0a          .dw XT_RDEFERFETCH
000aa5 0c14          .dw XT_RDEFERSTORE
                 
                 .dseg
000083           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000aa6 ff04          .dw $ff04
000aa7 6f63
000aa8 646c          .db "cold"
000aa9 0a9d          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000aaa 0aab          .dw PFA_COLD
                 PFA_COLD:
000aab b6a4          in_ mcu_boot, MCUSR
000aac 2422          clr zerol
000aad 2433          clr zeroh
000aae be24          out_ MCUSR, zerol
                     ; clear RAM
000aaf e6e0          ldi zl, low(ramstart)
000ab0 e0f0          ldi zh, high(ramstart)
                 clearloop:
000ab1 9221          st Z+, zerol
000ab2 36e0          cpi zl, low(sram_size+ramstart)
000ab3 f7e9          brne clearloop
000ab4 30f4          cpi zh, high(sram_size+ramstart)
000ab5 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000085           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000ab6 e8e5          ldi zl, low(ram_user1)
000ab7 e0f0          ldi zh, high(ram_user1)
000ab8 012f          movw upl, zl
                     ; init return stack pointer
000ab9 e50f          ldi temp0,low(rstackstart)
000aba bf0d          out_ SPL,temp0
000abb 8304          std Z+4, temp0
000abc e014          ldi temp1,high(rstackstart)
000abd bf1e          out_ SPH,temp1
000abe 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000abf e0cf          ldi yl,low(stackstart)
000ac0 83c6          std Z+6, yl
000ac1 e0d4          ldi yh,high(stackstart)
000ac2 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000ac3 ecac          ldi XL, low(PFA_WARM)
000ac4 e0ba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000ac5 940c 1c05     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WARM:
000ac7 ff04          .dw $ff04
000ac8 6177
000ac9 6d72          .db "warm"
000aca 0aa6          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000acb 1c01          .dw DO_COLON
                 PFA_WARM:
                 .endif
000acc 0d93          .dw XT_INIT_RAM
000acd 1c38          .dw XT_DOLITERAL
000ace 0bc1          .dw XT_NOOP
000acf 1c38          .dw XT_DOLITERAL
000ad0 0aa2          .dw XT_PAUSE
000ad1 0c35          .dw XT_DEFERSTORE
000ad2 042d          .dw XT_LBRACKET
000ad3 0663          .dw XT_TURNKEY
000ad4 0a58          .dw XT_QUIT     ; never returns
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000ad5 ff03          .dw $ff03
000ad6 7073
000ad7 0030          .db "sp0",0
000ad8 0ac7          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
000ad9 1c6a          .dw PFA_DOVALUE1
                 PFA_SP0:
000ada 0006          .dw USER_SP0
000adb 0c1e          .dw XT_UDEFERFETCH
000adc 0c2a          .dw XT_UDEFERSTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
000add ff02          .dw $ff02
000ade 7073          .db "sp"
000adf 0ad5          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
000ae0 1c53          .dw PFA_DOUSER
                 PFA_SP:
000ae1 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000ae2 ff03          .dw $ff03
000ae3 7072
000ae4 0030          .db "rp0",0
000ae5 0add          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
000ae6 1c01          .dw DO_COLON
                 PFA_RP0:
000ae7 0aea          .dw XT_DORP0
000ae8 1c74          .dw XT_FETCH
000ae9 1c1b          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
000aea 1c53          .dw PFA_DOUSER
                 PFA_DORP0:
000aeb 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
000aec ff05          .dw $ff05
000aed 6564
000aee 7470
000aef 0068          .db "depth",0
000af0 0ae2          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
000af1 1c01          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
000af2 0ad9          .dw XT_SP0
000af3 1e7c          .dw XT_SP_FETCH
000af4 1d8e          .dw XT_MINUS
000af5 1dff          .dw XT_2SLASH
000af6 1e30          .dw XT_1MINUS
000af7 1c1b          .dw XT_EXIT
                 .include "words/do-recognizer.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DORECOGNIZER:
000af8 ff0d          .dw $ff0d
000af9 6f64
000afa 722d
000afb 6365
000afc 676f
000afd 696e
000afe 657a
000aff 0072          .db "do-recognizer",0
000b00 0aec          .dw VE_HEAD
                     .set VE_HEAD = VE_DORECOGNIZER
                 XT_DORECOGNIZER:
000b01 1c01          .dw DO_COLON
                 PFA_DORECOGNIZER:
                 .endif
000b02 1c38          .dw XT_DOLITERAL
000b03 0b0d          .dw XT_DORECOGNIZER_A
000b04 1c38          .dw XT_DOLITERAL
000b05 0050          .dw CFG_RECOGNIZERLISTLEN
000b06 04dc          .dw XT_MAPSTACK
000b07 1d15          .dw XT_ZEROEQUAL
000b08 1c31          .dw XT_DOCONDBRANCH
000b09 0b0c          DEST(PFA_DORECOGNIZER1)
000b0a 05d9            .dw XT_2DROP
000b0b 0b8c            .dw XT_R_FAIL
                 PFA_DORECOGNIZER1:
000b0c 1c1b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ; ( addr len XT -- addr len [ r:table -1 | 0 ] )
                 XT_DORECOGNIZER_A:
000b0d 1c01         .dw DO_COLON
                 PFA_DORECOGNIZER_A:
                 .endif
000b0e 1cdc         .dw XT_ROT  ; -- len xt addr
000b0f 1cdc         .dw XT_ROT  ; -- xt addr len
000b10 05d0         .dw XT_2DUP 
000b11 1f0d         .dw XT_2TO_R
000b12 1cdc         .dw XT_ROT  ; -- addr len xt
000b13 1c25         .dw XT_EXECUTE ; -- i*x r:foo | r:fail
000b14 1f1c         .dw XT_2R_FROM
000b15 1cdc         .dw XT_ROT
000b16 1cac         .dw XT_DUP
000b17 0b8c         .dw XT_R_FAIL
000b18 1fd0         .dw XT_EQUAL
000b19 1c31         .dw XT_DOCONDBRANCH
000b1a 0b1e         DEST(PFA_DORECOGNIZER_A1)
000b1b 1cd4           .dw XT_DROP
000b1c 1d4f           .dw XT_ZERO
000b1d 1c1b           .dw XT_EXIT
                 PFA_DORECOGNIZER_A1:
000b1e 1ceb         .dw XT_NIP 
000b1f 1ceb         .dw XT_NIP
000b20 1d46         .dw XT_TRUE
000b21 1c1b         .dw XT_EXIT
                 
                 ; : do-recognizer ( addr len -- i*x r:table|r:fail )
                 ;    \ ( addr len -- addr len 0 | i*x r:table -1 )
                 ;    [: rot rot 2dup 2>r rot execute 2r> rot 
                 ;          dup r:fail = ( -- addr len r:table f )
                 ;          if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    EE_RECOGNIZERLISTLEN map-stack ( -- i*x addr len r:table f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop r:fail 
                 ;    then
                 ;
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
000b22 ff09          .dw $ff09
000b23 6e69
000b24 6574
000b25 7072
000b26 6572
000b27 0074          .db "interpret",0
000b28 0af8          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000b29 1c01          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
000b2a 0a1d          .dw XT_PARSENAME ; ( -- addr len )
000b2b 1cac          .dw XT_DUP   ; ( -- addr len flag)
000b2c 1c31          .dw XT_DOCONDBRANCH
000b2d 0b39          DEST(PFA_INTERPRET2)
000b2e 0b01            .dw XT_DORECOGNIZER
000b2f 05b5            .dw XT_STATE
000b30 1c74            .dw XT_FETCH
000b31 1c31            .dw XT_DOCONDBRANCH
000b32 0b34          DEST(PFA_INTERPRET1)
000b33 0bed            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
000b34 1fbb            .dw XT_FETCHI
000b35 1c25            .dw XT_EXECUTE
000b36 0b99            .dw XT_QSTACK
000b37 1c2a          .dw XT_DOBRANCH
000b38 0b2a          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
000b39 05d9          .dw XT_2DROP
000b3a 1c1b          .dw XT_EXIT
                 .include "words/r-intnumber.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_NUM:
000b3b ff05          .dw $ff05
000b3c 3a72
000b3d 756e
000b3e 006d          .db "r:num",0
000b3f 0b22          .dw VE_HEAD
                     .set VE_HEAD = VE_R_NUM
                 XT_R_NUM:
000b40 1c4d          .dw PFA_DOCONSTANT
                 PFA_R_NUM:
                 .endif
000b41 0bc1          .dw XT_NOOP    ; interpret
000b42 02b9          .dw XT_LITERAL ; compile
000b43 02b9          .dw XT_LITERAL ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_DNUM:
000b44 ff06          .dw $ff06
000b45 3a72
000b46 6e64
000b47 6d75          .db "r:dnum"
000b48 0b3b          .dw VE_HEAD
                     .set VE_HEAD = VE_R_DNUM
                 XT_R_DNUM:
000b49 1c4d          .dw PFA_DOCONSTANT
                 PFA_R_DNUM:
                 .endif
000b4a 0bc1          .dw XT_NOOP     ; interpret
000b4b 1fc8          .dw XT_2LITERAL ; compile
000b4c 1fc8          .dw XT_2LITERAL ; postpone
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
000b4d ff07          .dw $ff07
000b4e 6572
000b4f 3a63
000b50 756e
000b51 006d          .db "rec:num",0
000b52 0b44          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
000b53 1c01          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
000b54 095c          .dw XT_NUMBER
000b55 1c31          .dw XT_DOCONDBRANCH
000b56 0b5f          DEST(PFA_REC_NONUMBER)
000b57 1fd7          .dw XT_ONE
000b58 1fd0          .dw XT_EQUAL
000b59 1c31          .dw XT_DOCONDBRANCH
000b5a 0b5d          DEST(PFA_REC_INTNUM2)
000b5b 0b40            .dw XT_R_NUM
000b5c 1c1b            .dw XT_EXIT
                 PFA_REC_INTNUM2:
000b5d 0b49            .dw XT_R_DNUM
000b5e 1c1b            .dw XT_EXIT
                 PFA_REC_NONUMBER:
000b5f 0b8c          .dw XT_R_FAIL
000b60 1c1b          .dw XT_EXIT
                 .include "words/r-word.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_WORD:
000b61 ff08          .dw $ff08
000b62 6572
000b63 3a63
000b64 6f77
000b65 6472          .db "rec:word"
000b66 0b4d          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_WORD
                 XT_REC_WORD:
000b67 1c01          .dw DO_COLON
                 PFA_REC_WORD:
                 .endif
000b68 0a3a          .DW XT_FINDNAME
000b69 1cac          .dw XT_DUP
000b6a 1d15          .dw XT_ZEROEQUAL
000b6b 1c31          .dw XT_DOCONDBRANCH
000b6c 0b70          DEST(PFA_REC_WORD_FOUND)
000b6d 1cd4              .dw XT_DROP
000b6e 0b8c      	.dw XT_R_FAIL
000b6f 1c1b      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
000b70 0b77          .dw XT_R_WORD
                 
000b71 1c1b          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_WORD:
000b72 ff06          .dw $ff06
000b73 3a72
000b74 6f77
000b75 6472          .db "r:word"
000b76 0b61          .dw VE_HEAD
                     .set VE_HEAD = VE_R_WORD
                 XT_R_WORD:
000b77 1c4d          .dw PFA_DOCONSTANT
                 PFA_R_WORD:
                 .endif
000b78 0b7b          .dw XT_R_WORD_INTERPRET
000b79 0b7f          .dw XT_R_WORD_COMPILE
000b7a 1fc8          .dw XT_2LITERAL
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
000b7b 1c01          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
000b7c 1cd4          .dw XT_DROP ; the flags are in the way
000b7d 1c25          .dw XT_EXECUTE
000b7e 1c1b          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
000b7f 1c01          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
000b80 1d1c          .dw XT_ZEROLESS
000b81 1c31          .dw XT_DOCONDBRANCH
000b82 0b85          DEST(PFA_R_WORD_COMPILE1)
000b83 02a3      	.dw XT_COMMA
000b84 1c1b              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
000b85 1c25              .dw XT_EXECUTE
000b86 1c1b          .dw XT_EXIT
                 .include "words/r-fail.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_FAIL:
000b87 ff06          .dw $ff06
000b88 3a72
000b89 6166
000b8a 6c69          .db "r:fail"
000b8b 0b72          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FAIL
                 XT_R_FAIL:
000b8c 1c4d          .dw PFA_DOCONSTANT
                 PFA_R_FAIL:
                 .endif
000b8d 0b90          .dw XT_FAIL  ; interpret
000b8e 0b90          .dw XT_FAIL  ; compile
000b8f 0b90          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
000b90 1c01          .dw DO_COLON
                 PFA_FAIL:
                 .endif
000b91 1c38          .dw XT_DOLITERAL
000b92 fff3          .dw -13
000b93 08a9          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
000b94 ff06          .dw $ff06
000b95 733f
000b96 6174
000b97 6b63          .db "?stack"
000b98 0b87          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000b99 1c01          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
000b9a 0af1          .dw XT_DEPTH
000b9b 1d1c          .dw XT_ZEROLESS
000b9c 1c31          .dw XT_DOCONDBRANCH
000b9d 0ba1          DEST(PFA_QSTACK1)
000b9e 1c38            .dw XT_DOLITERAL
000b9f fffc            .dw -4
000ba0 08a9            .dw XT_THROW
                 PFA_QSTACK1:
000ba1 1c1b          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
000ba2 ff03          .dw $ff03
000ba3 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
000ba4 0072          .db "ver"
000ba5 0b94          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
000ba6 1c01          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
000ba7 0577          .dw XT_ENV_FORTHNAME
000ba8 0810          .dw XT_ITYPE
000ba9 0852          .dw XT_SPACE
000baa 05bb          .dw XT_BASE
000bab 1c74          .dw XT_FETCH
                 
000bac 0585          .dw XT_ENV_FORTHVERSION
000bad 0648          .dw XT_DECIMAL
000bae 0daa          .dw XT_S2D
000baf 072e          .dw XT_L_SHARP
000bb0 0736          .dw XT_SHARP
000bb1 1c38          .dw XT_DOLITERAL
000bb2 002e          .dw '.'
000bb3 071f          .dw XT_HOLD
000bb4 074c          .dw XT_SHARP_S
000bb5 0757          .dw XT_SHARP_G
000bb6 086b          .dw XT_TYPE
000bb7 05bb          .dw XT_BASE
000bb8 1c7c          .dw XT_STORE
000bb9 0852          .dw XT_SPACE
000bba 058d          .dw XT_ENV_CPU
000bbb 0810          .dw XT_ITYPE
                 
000bbc 1c1b          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOOP:
000bbd ff04          .dw $ff04
000bbe 6f6e
000bbf 706f          .db "noop"
000bc0 0ba2          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000bc1 1c01          .dw DO_COLON
                 PFA_NOOP:
                 .endif
000bc2 1c1b         .DW XT_EXIT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000bc3 ff06          .dw $ff06
000bc4 6e75
000bc5 7375
000bc6 6465          .db "unused"
000bc7 0bbd          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000bc8 1c01          .dw DO_COLON
                 PFA_UNUSED:
000bc9 1e7c          .dw XT_SP_FETCH
000bca 062a          .dw XT_HERE
000bcb 1d8e          .dw XT_MINUS
000bcc 1c1b          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
000bcd 0002          .dw $0002
000bce 6f74          .db "to"
000bcf 0bc3          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000bd0 1c01          .dw DO_COLON
                 PFA_TO:
                 .endif
000bd1 087a          .dw XT_TICK
000bd2 0db3          .dw XT_TO_BODY
000bd3 05b5          .dw XT_STATE
000bd4 1c74          .dw XT_FETCH
000bd5 1c31          .dw XT_DOCONDBRANCH
000bd6 0be1          DEST(PFA_TO1)
000bd7 0298          .dw XT_COMPILE
000bd8 0bdb          .dw XT_DOTO
000bd9 02a3          .dw XT_COMMA
000bda 1c1b          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
000bdb 1c01          .dw DO_COLON
                 PFA_DOTO:
                 .endif
000bdc 1cf1          .dw XT_R_FROM
000bdd 1cac          .dw XT_DUP
000bde 0bed          .dw XT_ICELLPLUS
000bdf 1cfa          .dw XT_TO_R
000be0 1fbb          .dw XT_FETCHI
                 PFA_TO1:
000be1 1cac          .dw XT_DUP
000be2 0bed          .dw XT_ICELLPLUS
000be3 0bed          .dw XT_ICELLPLUS
000be4 1fbb          .dw XT_FETCHI
000be5 1c25          .dw XT_EXECUTE
000be6 1c1b          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
000be7 ff07          .dw $FF07
000be8 2d69
000be9 6563
000bea 6c6c
000beb 002b          .db "i-cell+",0
000bec 0bcd          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
000bed 1c01          .dw DO_COLON
                 PFA_ICELLPLUS:
000bee 1e2a          .dw XT_1PLUS
000bef 1c1b          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
000bf0 ff07          .dw $ff07
000bf1 6445
000bf2 6665
000bf3 7265
000bf4 0040          .db "Edefer@",0
000bf5 0be7          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
000bf6 1c01          .dw DO_COLON
                 PFA_EDEFERFETCH:
000bf7 1fbb          .dw XT_FETCHI
000bf8 1f4e          .dw XT_FETCHE
000bf9 1c1b          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
000bfa ff07          .dw $ff07
000bfb 6445
000bfc 6665
000bfd 7265
000bfe 0021          .db "Edefer!",0
000bff 0bf0          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
000c00 1c01          .dw DO_COLON
                 PFA_EDEFERSTORE:
000c01 1fbb          .dw XT_FETCHI
000c02 1f2a          .dw XT_STOREE
000c03 1c1b          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
000c04 ff07          .dw $ff07
000c05 6452
000c06 6665
000c07 7265
000c08 0040          .db "Rdefer@",0
000c09 0bfa          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
000c0a 1c01          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
000c0b 1fbb          .dw XT_FETCHI
000c0c 1c74          .dw XT_FETCH
000c0d 1c1b          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
000c0e ff07          .dw $ff07
000c0f 6452
000c10 6665
000c11 7265
000c12 0021          .db "Rdefer!",0
000c13 0c04          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
000c14 1c01          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
000c15 1fbb          .dw XT_FETCHI
000c16 1c7c          .dw XT_STORE
000c17 1c1b          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
000c18 ff07          .dw $ff07
000c19 6455
000c1a 6665
000c1b 7265
000c1c 0040          .db "Udefer@",0
000c1d 0c0e          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
000c1e 1c01          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
000c1f 1fbb          .dw XT_FETCHI
000c20 1ef1          .dw XT_UP_FETCH
000c21 1d98          .dw XT_PLUS
000c22 1c74          .dw XT_FETCH
000c23 1c1b          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
000c24 ff07          .dw $ff07
000c25 6455
000c26 6665
000c27 7265
000c28 0021          .db "Udefer!",0
000c29 0c18          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
000c2a 1c01          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
000c2b 1fbb          .dw XT_FETCHI
000c2c 1ef1          .dw XT_UP_FETCH
000c2d 1d98          .dw XT_PLUS
000c2e 1c7c          .dw XT_STORE
000c2f 1c1b          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
000c30 ff06          .dw $ff06
000c31 6564
000c32 6566
000c33 2172          .db "defer!"
000c34 0c24          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
000c35 1c01          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
000c36 0db3          .dw XT_TO_BODY
000c37 1cac          .dw XT_DUP
000c38 0bed          .dw XT_ICELLPLUS
000c39 0bed          .dw XT_ICELLPLUS
000c3a 1fbb          .dw XT_FETCHI
000c3b 1c25          .dw XT_EXECUTE
000c3c 1c1b          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
000c3d ff06          .dw $ff06
000c3e 6564
000c3f 6566
000c40 4072          .db "defer@"
000c41 0c30          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
000c42 1c01          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
000c43 0db3          .dw XT_TO_BODY 
000c44 1cac          .dw XT_DUP
000c45 0bed          .dw XT_ICELLPLUS
000c46 1fbb          .dw XT_FETCHI
000c47 1c25          .dw XT_EXECUTE
000c48 1c1b          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
000c49 ff07          .dw $ff07
000c4a 6428
000c4b 6665
000c4c 7265
000c4d 0029          .db "(defer)", 0
000c4e 0c3d          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
000c4f 1c01          .dw DO_COLON
                 PFA_DODEFER:
000c50 0275          .dw XT_DOCREATE
000c51 03d5          .dw XT_REVEAL
000c52 0298          .dw XT_COMPILE
000c53 0c55          .dw PFA_DODEFER1
000c54 1c1b          .dw XT_EXIT
                 PFA_DODEFER1:
000c55 940e 03ee     call_ DO_DODOES
000c57 1cac          .dw XT_DUP
000c58 0bed          .dw XT_ICELLPLUS
000c59 1fbb          .dw XT_FETCHI
000c5a 1c25          .dw XT_EXECUTE 
000c5b 1c25          .dw XT_EXECUTE
000c5c 1c1b          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
000c5d ff0f          .dw $ff0f
000c5e 6573
000c5f 7261
000c60 6863
000c61 772d
000c62 726f
000c63 6c64
000c64 7369
000c65 0074          .db "search-wordlist",0
000c66 0c49          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
000c67 1c01          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
000c68 1cfa          .dw XT_TO_R
000c69 1d4f          .dw XT_ZERO
000c6a 1c38          .dw XT_DOLITERAL
000c6b 0c7c          .dw XT_ISWORD
000c6c 1cf1          .dw XT_R_FROM
000c6d 0c99          .dw XT_TRAVERSEWORDLIST
000c6e 1cac          .dw XT_DUP
000c6f 1d15          .dw XT_ZEROEQUAL
000c70 1c31          .dw XT_DOCONDBRANCH
000c71 0c76          DEST(PFA_SEARCH_WORDLIST1)
000c72 05d9             .dw XT_2DROP
000c73 1cd4             .dw XT_DROP
000c74 1d4f             .dw XT_ZERO
000c75 1c1b             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
000c76 1cac            .dw XT_DUP
000c77 0cc0            .dw XT_NFA2CFA
                       ; .. and get the header flag
000c78 1cbf            .dw XT_SWAP
000c79 015a            .dw XT_NAME2FLAGS
000c7a 0147            .dw XT_IMMEDIATEQ
000c7b 1c1b          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
000c7c 1c01          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
000c7d 1cfa          .dw XT_TO_R
000c7e 1cd4          .dw XT_DROP
000c7f 05d0          .dw XT_2DUP
000c80 1d03          .dw XT_R_FETCH  ; -- addr len addr len nt
000c81 0cb4          .dw XT_NAME2STRING
000c82 0cca          .dw XT_ICOMPARE      ; (-- addr len f )
000c83 1c31          .dw XT_DOCONDBRANCH
000c84 0c8a          DEST(PFA_ISWORD3)
                       ; not now
000c85 1cf1            .dw XT_R_FROM
000c86 1cd4            .dw XT_DROP
000c87 1d4f            .dw XT_ZERO
000c88 1d46            .dw XT_TRUE         ; maybe next word
000c89 1c1b            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
000c8a 05d9            .dw XT_2DROP
000c8b 1cf1            .dw XT_R_FROM
000c8c 1d4f            .dw XT_ZERO       ; finish traverse-wordlist
000c8d 1c1b            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
000c8e ff11          .dw $ff11
000c8f 7274
000c90 7661
000c91 7265
000c92 6573
000c93 772d
000c94 726f
000c95 6c64
000c96 7369
000c97 0074          .db "traverse-wordlist",0
000c98 0c5d          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
000c99 1c01          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
000c9a 1f4e          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
000c9b 1cac          .dw XT_DUP           ; ( -- xt nt nt )
000c9c 1c31          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
000c9d 0caa          DEST(PFA_TRAVERSEWORDLIST2)
000c9e 05d0          .dw XT_2DUP
000c9f 1f0d          .dw XT_2TO_R
000ca0 1cbf          .dw XT_SWAP
000ca1 1c25          .dw XT_EXECUTE
000ca2 1f1c          .dw XT_2R_FROM
000ca3 1cdc          .dw XT_ROT
000ca4 1c31          .dw XT_DOCONDBRANCH
000ca5 0caa          DEST(PFA_TRAVERSEWORDLIST2)
000ca6 0542          .dw XT_NFA2LFA
000ca7 1fbb          .dw XT_FETCHI
000ca8 1c2a          .dw XT_DOBRANCH      ; ( -- addr )
000ca9 0c9b          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
000caa 05d9          .dw XT_2DROP
000cab 1c1b          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                 ;        begin @ dup
                 ;        while
                 ;          2dup 2>r
                 ;          swap execute ( i*x nt -- i*x' f )
                 ;          2r> rot
                 ;        while
                 ;          nfa>lfa @i
                 ;        repeat then 2drop ;
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
000cac ff0b          .dw $ff0b
000cad 616e
000cae 656d
000caf 733e
000cb0 7274
000cb1 6e69
000cb2 0067          .db "name>string",0
000cb3 0c8e          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
000cb4 1c01          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
000cb5 083c          .dw XT_ICOUNT   ; ( -- addr n )
000cb6 1c38          .dw XT_DOLITERAL
000cb7 00ff          .dw 255
000cb8 1e0e          .dw XT_AND      ; mask immediate bit
000cb9 1c1b          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
000cba ff07          .dw $ff07
000cbb 666e
000cbc 3e61
000cbd 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
000cbe 0061          .db "nfa>cfa"
000cbf 0cac          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
000cc0 1c01          .dw DO_COLON
                 PFA_NFA2CFA:
000cc1 0542          .dw XT_NFA2LFA ; skip to link field
000cc2 1e2a          .dw XT_1PLUS   ; next is the execution token
000cc3 1c1b          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
000cc4 ff08          .dw $ff08
000cc5 6369
000cc6 6d6f
000cc7 6170
000cc8 6572          .db "icompare"
000cc9 0cba          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
000cca 1c01          .dw DO_COLON
                 PFA_ICOMPARE:
000ccb 1cfa          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
000ccc 1cca          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
000ccd 1cf1          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
000cce 1d0e          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
000ccf 1c31          .dw XT_DOCONDBRANCH
000cd0 0cd5          .dw PFA_ICOMPARE_SAMELEN
000cd1 05d9            .dw XT_2DROP
000cd2 1cd4            .dw XT_DROP
000cd3 1d46            .dw XT_TRUE
000cd4 1c1b            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
000cd5 1cbf          .dw XT_SWAP ; ( -- r-addr f-addr len )
000cd6 1d4f          .dw XT_ZERO
000cd7 0362          .dw XT_QDOCHECK
000cd8 1c31          .dw XT_DOCONDBRANCH
000cd9 0cf8          .dw PFA_ICOMPARE_DONE
000cda 1e8a          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
000cdb 1cca          .dw XT_OVER
000cdc 1c74          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
000cdd 1cca          .dw XT_OVER
000cde 1fbb          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
000cdf 1cac          .dw XT_DUP
                     ;.dw XT_BYTESWAP
000ce0 1c38          .dw XT_DOLITERAL
000ce1 0100          .dw $100
000ce2 1d57          .dw XT_ULESS
000ce3 1c31          .dw XT_DOCONDBRANCH
000ce4 0ce9          .dw PFA_ICOMPARE_LASTCELL
000ce5 1cbf          .dw XT_SWAP
000ce6 1c38          .dw XT_DOLITERAL
000ce7 00ff          .dw $00FF
000ce8 1e0e          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000ce9 1d0e          .dw XT_NOTEQUAL
000cea 1c31          .dw XT_DOCONDBRANCH
000ceb 0cf0          .dw PFA_ICOMPARE_NEXTLOOP
000cec 05d9          .dw XT_2DROP
000ced 1d46          .dw XT_TRUE
000cee 1ec3          .dw XT_UNLOOP
000cef 1c1b          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
000cf0 1e2a          .dw XT_1PLUS
000cf1 1cbf          .dw XT_SWAP
000cf2 05c8          .dw XT_CELLPLUS
000cf3 1cbf          .dw XT_SWAP
000cf4 1c38          .dw XT_DOLITERAL
000cf5 0002          .dw 2
000cf6 1ea9          .dw XT_DOPLUSLOOP
000cf7 0cdb          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
000cf8 05d9          .dw XT_2DROP
000cf9 1d4f          .dw XT_ZERO
000cfa 1c1b          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
000cfb ff01          .dw $ff01
000cfc 002a          .db "*",0
000cfd 0cc4          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000cfe 1c01          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
000cff 1da1          .dw XT_MSTAR
000d00 1cd4          .dw XT_DROP
000d01 1c1b          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
000d02 ff01          .dw $FF01
000d03 006a          .db "j",0
000d04 0cfb          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
000d05 1c01          .dw DO_COLON
                 PFA_J:
000d06 1e65          .dw XT_RP_FETCH
000d07 1c38          .dw XT_DOLITERAL
000d08 0007          .dw 7
000d09 1d98          .dw XT_PLUS
000d0a 1c74          .dw XT_FETCH
000d0b 1e65          .dw XT_RP_FETCH
000d0c 1c38          .dw XT_DOLITERAL
000d0d 0009          .dw 9
000d0e 1d98          .dw XT_PLUS
000d0f 1c74          .dw XT_FETCH
000d10 1d98          .dw XT_PLUS
000d11 1c1b          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
000d12 ff04          .dw $ff04
000d13 6164
000d14 7362          .db "dabs"
000d15 0d02          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000d16 1c01          .dw DO_COLON
                 PFA_DABS:
000d17 1cac          .dw XT_DUP
000d18 1d1c          .dw XT_ZEROLESS
000d19 1c31          .dw XT_DOCONDBRANCH
000d1a 0d1c          .dw PFA_DABS1
000d1b 0d23          .dw XT_DNEGATE
                 PFA_DABS1:
000d1c 1c1b          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000d1d ff07          .dw $ff07
000d1e 6e64
000d1f 6765
000d20 7461
000d21 0065          .db "dnegate",0
000d22 0d12          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
000d23 1c01          .dw DO_COLON
                 PFA_DNEGATE:
000d24 01a9          .dw XT_DINVERT
000d25 1c38          .dw XT_DOLITERAL
000d26 0001          .dw 1
000d27 1d4f          .dw XT_ZERO
000d28 0181          .dw XT_DPLUS
000d29 1c1b          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000d2a ff05          .dw $ff05
000d2b 6d63
000d2c 766f
000d2d 0065          .db "cmove",0
000d2e 0d1d          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
000d2f 0d30          .dw PFA_CMOVE
                 PFA_CMOVE:
000d30 93bf          push xh
000d31 93af          push xl
000d32 91e9          ld zl, Y+
000d33 91f9          ld zh, Y+ ; addr-to
000d34 91a9          ld xl, Y+
000d35 91b9          ld xh, Y+ ; addr-from
000d36 2f09          mov temp0, tosh
000d37 2b08          or temp0, tosl
000d38 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
000d39 911d          ld temp1, X+
000d3a 9311          st Z+, temp1
000d3b 9701          sbiw tosl, 1
000d3c f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
000d3d 91af          pop xl
000d3e 91bf          pop xh
000d3f 9189
000d40 9199          loadtos
000d41 940c 1c05     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
000d43 ff05          .dw $ff05
000d44 7332
000d45 6177
000d46 0070          .db "2swap",0
000d47 0d2a          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
000d48 1c01          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
000d49 1cdc          .dw XT_ROT
000d4a 1cfa          .dw XT_TO_R
000d4b 1cdc          .dw XT_ROT
000d4c 1cf1          .dw XT_R_FROM
000d4d 1c1b          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System
                 ; refills the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILLTIB:
000d4e ff0a          .dw $ff0a
000d4f 6572
000d50 6966
000d51 6c6c
000d52 742d
000d53 6269          .db "refill-tib"
000d54 0d43          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
000d55 1c01          .dw DO_COLON
                 PFA_REFILLTIB:
                 .endif
000d56 0d71          .dw XT_TIB
000d57 1c38          .dw XT_DOLITERAL
000d58 005a          .dw TIB_SIZE
000d59 08f9          .dw XT_ACCEPT
000d5a 0d77          .dw XT_NUMBERTIB
000d5b 1c7c          .dw XT_STORE
000d5c 1d4f          .dw XT_ZERO
000d5d 05e9          .dw XT_TO_IN
000d5e 1c7c          .dw XT_STORE
000d5f 1d46          .dw XT_TRUE ; -1
000d60 1c1b          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCETIB:
000d61 ff0a          .dw $FF0A
000d62 6f73
000d63 7275
000d64 6563
000d65 742d
000d66 6269          .db "source-tib"
000d67 0d4e          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
000d68 1c01          .dw DO_COLON
                 PFA_SOURCETIB:
                 .endif
000d69 0d71          .dw XT_TIB
000d6a 0d77          .dw XT_NUMBERTIB
000d6b 1c74          .dw XT_FETCH
000d6c 1c1b          .dw XT_EXIT
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; terminal input buffer address
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TIB:
000d6d ff03          .dw $ff03
000d6e 6974
000d6f 0062          .db "tib",0
000d70 0d61          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
000d71 1c43          .dw PFA_DOVARIABLE
                 PFA_TIB:
000d72 00ab          .dw ram_tib
                 .dseg
0000ab           ram_tib: .byte TIB_SIZE
                 .cseg
                 .endif
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBERTIB:
000d73 ff04          .dw $ff04
000d74 7423
000d75 6269          .db "#tib"
000d76 0d6d          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
000d77 1c43          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000d78 0105          .dw ram_sharptib
                 .dseg
000105           ram_sharptib: .byte 2
                 .cseg
                 .endif
                 
                 .include "words/init-ram.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
000d79 ff06        .dw $ff06
000d7a 6565
000d7b 723e
000d7c 6d61        .db "ee>ram"
000d7d 0d73        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
000d7e 1c01        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
000d7f 1d4f          .dw XT_ZERO
000d80 1e8a          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000d81 1cca          .dw XT_OVER
000d82 1f4e          .dw XT_FETCHE
000d83 1cca          .dw XT_OVER
000d84 1c7c          .dw XT_STORE
000d85 05c8          .dw XT_CELLPLUS
000d86 1cbf          .dw XT_SWAP
000d87 05c8          .dw XT_CELLPLUS
000d88 1cbf          .dw XT_SWAP
000d89 1eb8          .dw XT_DOLOOP
000d8a 0d81          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
000d8b 05d9          .dw XT_2DROP
000d8c 1c1b          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INIT_RAM:
000d8d ff08        .dw $ff08
000d8e 6e69
000d8f 7469
000d90 722d
000d91 6d61        .db "init-ram"
000d92 0d79        .dw VE_HEAD
                   .set VE_HEAD = VE_INIT_RAM
                 XT_INIT_RAM:
000d93 1c01        .dw DO_COLON
                 PFA_INI_RAM:          ; ( -- )
000d94 1c38          .dw XT_DOLITERAL
000d95 005e          .dw EE_INITUSER
000d96 1ef1          .dw XT_UP_FETCH
000d97 1c38          .dw XT_DOLITERAL
000d98 001c          .dw SYSUSERSIZE
000d99 1dff          .dw XT_2SLASH
000d9a 0d7e          .dw XT_EE2RAM
000d9b 1c1b          .dw XT_EXIT
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
000d9c ff06          .dw $ff06
000d9d 6f62
000d9e 6e75
000d9f 7364          .db "bounds"
000da0 0d8d          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
000da1 1c01          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
000da2 1cca          .dw XT_OVER
000da3 1d98          .dw XT_PLUS
000da4 1cbf          .dw XT_SWAP
000da5 1c1b          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
000da6 ff03          .dw $ff03
000da7 3e73
000da8 0064          .db "s>d",0
000da9 0d9c          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
000daa 1c01          .dw DO_COLON
                 PFA_S2D:
                 .endif
000dab 1cac          .dw XT_DUP
000dac 1d1c          .dw XT_ZEROLESS
000dad 1c1b          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
000dae ff05          .dw $ff05
000daf 623e
000db0 646f
000db1 0079          .db ">body",0
000db2 0da6          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
000db3 1e2b          .dw PFA_1PLUS
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTS:
000db4 ff02          .dw $ff02
000db5 732e          .db ".s"
000db6 0dae          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000db7 1c01          .dw DO_COLON
                 PFA_DOTS:
                 .endif
000db8 0af1          .dw XT_DEPTH
000db9 01bf          .dw XT_UDOT
000dba 0852          .dw XT_SPACE
000dbb 0af1          .dw XT_DEPTH
000dbc 1d4f          .dw XT_ZERO
000dbd 0362          .dw XT_QDOCHECK
000dbe 1c31          .dw XT_DOCONDBRANCH
000dbf 0dc6          DEST(PFA_DOTS2)
000dc0 1e8a          .dw XT_DODO
                 PFA_DOTS1:
000dc1 1e9b          .dw XT_I
000dc2 0232          .dw XT_PICK
000dc3 01bf          .dw XT_UDOT
000dc4 1eb8          .dw XT_DOLOOP
000dc5 0dc1          DEST(PFA_DOTS1)
                 PFA_DOTS2:
000dc6 1c1b          .dw XT_EXIT
                 .include "words/spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 1 byte
                 VE_SPIRW:
000dc7 ff06          .dw $ff06
000dc8 2163
000dc9 7340
000dca 6970          .db "c!@spi"
000dcb 0db4          .dw VE_HEAD
                     .set VE_HEAD  = VE_SPIRW
                 XT_SPIRW:
000dcc 0dcd          .dw PFA_SPIRW
                 PFA_SPIRW:
000dcd d003          rcall do_spirw
000dce 2799          clr tosh
000dcf 940c 1c05     jmp_ DO_NEXT
                 
                 do_spirw:
000dd1 b98f          out_ SPDR, tosl
                 do_spirw1:
000dd2 b10e          in_ temp0, SPSR
000dd3 7f08          cbr temp0,7
000dd4 b90e          out_ SPSR, temp0
000dd5 b10e          in_ temp0, SPSR
000dd6 ff07          sbrs temp0, 7
000dd7 cffa          rjmp do_spirw1   ; wait until complete
000dd8 b18f          in_ tosl, SPDR
000dd9 9508          ret
                 .include "words/n-spi.asm"
                 
                 ; MCU
                 ; read len bytes from SPI to addr
                 VE_N_SPIR:
000dda ff05          .dw $ff05
000ddb 406e
000ddc 7073
000ddd 0069          .db "n@spi",0
000dde 0dc7          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIR
                 XT_N_SPIR:
000ddf 0de0          .dw PFA_N_SPIR
                 PFA_N_SPIR:
000de0 018c          movw temp0, tosl
000de1 9189
000de2 9199          loadtos
000de3 01fc          movw zl, tosl
000de4 01c8          movw tosl, temp0
                 PFA_N_SPIR_LOOP:
000de5 b82f          out_ SPDR, zerol
                 PFA_N_SPIR_LOOP1:
000de6 b12e          in_ temp2, SPSR
000de7 ff27          sbrs temp2, SPIF
000de8 cffd          rjmp PFA_N_SPIR_LOOP1
000de9 b12f          in_ temp2, SPDR
000dea 9321          st Z+, temp2
000deb 9701          sbiw tosl, 1
000dec f7c1          brne PFA_N_SPIR_LOOP
000ded 9189
000dee 9199          loadtos
000def 940c 1c05     jmp_ DO_NEXT
                 
                 ; ( addr len -- ) 
                 ; MCU
                 ; write len bytes to SPI from addr
                 VE_N_SPIW:
000df1 ff05          .dw $ff05
000df2 216e
000df3 7073
000df4 0069          .db "n!spi",0
000df5 0dda          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIW
                 XT_N_SPIW:
000df6 0df7          .dw PFA_N_SPIW
                 PFA_N_SPIW:
000df7 018c          movw temp0, tosl
000df8 9189
000df9 9199          loadtos
000dfa 01fc          movw zl, tosl
000dfb 01c8          movw tosl, temp0
                 PFA_N_SPIW_LOOP:
000dfc 9121          ld temp2, Z+
000dfd b92f          out_ SPDR, temp2
                 PFA_N_SPIW_LOOP1:
000dfe b12e          in_ temp2, SPSR
000dff ff27          sbrs temp2, SPIF
000e00 cffd          rjmp PFA_N_SPIW_LOOP1
000e01 b12f          in_ temp2, SPDR ; ignore the data
000e02 9701          sbiw tosl, 1
000e03 f7c1          brne PFA_N_SPIW_LOOP
000e04 9189
000e05 9199          loadtos
000e06 940c 1c05     jmp_ DO_NEXT
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000e08 ff0b          .dw $ff0b
000e09 7061
000e0a 6c70
000e0b 7574
000e0c 6e72
000e0d 656b
000e0e 0079          .db "applturnkey",0
000e0f 0df1          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000e10 1c01          .dw DO_COLON
                 PFA_APPLTURNKEY:
000e11 00a9          .dw XT_USART
000e12 01f0          .dw XT_INTON
000e13 0ba6          .dw XT_DOT_VER
000e14 0852          .dw XT_SPACE
000e15 05aa          .dw XT_F_CPU
000e16 1c38          .dw XT_DOLITERAL
000e17 03e8          .dw 1000
000e18 1dbd          .dw XT_UMSLASHMOD
000e19 1ceb          .dw XT_NIP
000e1a 0648          .dw XT_DECIMAL
000e1b 0792          .dw XT_DOT
000e1c 07dd          .dw XT_DOSLITERAL
000e1d 0004          .dw 4
000e1e 486b
000e1f 207a          .db "kHz "
000e20 0810          .dw XT_ITYPE
000e21 1c1b          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000e22 ff0b          .dw $ff0b
000e23 6573
000e24 2d74
000e25 7563
000e26 7272
000e27 6e65
000e28 0074          .db "set-current",0
000e29 0e08          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
000e2a 1c01          .dw DO_COLON
                 PFA_SET_CURRENT:
000e2b 1c38          .dw XT_DOLITERAL
000e2c 003a          .dw CFG_CURRENT
000e2d 1f2a          .dw XT_STOREE
000e2e 1c1b          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000e2f ff08          .dw $ff08
000e30 6f77
000e31 6472
000e32 696c
000e33 7473          .db "wordlist"
000e34 0e22          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000e35 1c01          .dw DO_COLON
                 PFA_WORDLIST:
000e36 0622          .dw XT_EHERE
000e37 1d4f          .dw XT_ZERO
000e38 1cca          .dw XT_OVER
000e39 1f2a          .dw XT_STOREE
000e3a 1cac          .dw XT_DUP
000e3b 05c8          .dw XT_CELLPLUS
000e3c 0bdb          .dw XT_DOTO
000e3d 0623          .dw PFA_EHERE
000e3e 1c1b          .dw XT_EXIT
                 
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTHWORDLIST:
000e3f ff0e          .dw $ff0e
000e40 6f66
000e41 7472
000e42 2d68
000e43 6f77
000e44 6472
000e45 696c
000e46 7473          .db "forth-wordlist"
000e47 0e2f          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHWORDLIST
                 XT_FORTHWORDLIST:
000e48 1c43          .dw PFA_DOVARIABLE
                 PFA_FORTHWORDLIST:
000e49 003c          .dw CFG_FORTHWORDLIST
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_ORDER:
000e4a ff09          .dw $ff09
000e4b 6573
000e4c 2d74
000e4d 726f
000e4e 6564
000e4f 0072          .db "set-order",0
000e50 0e3f          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
000e51 1c01          .dw DO_COLON
                 PFA_SET_ORDER:
                 .endif
000e52 1c38          .dw XT_DOLITERAL
000e53 003e          .dw CFG_ORDERLISTLEN
000e54 04c5          .dw XT_SET_STACK
000e55 1c1b          .dw XT_EXIT
                 
                 .include "words/set-recognizer.asm"
                 
                 ; Interpreter
                 ; replace the recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_RECOGNIZERS:
000e56 ff0f          .dw $ff0f
000e57 6573
000e58 2d74
000e59 6572
000e5a 6f63
000e5b 6e67
000e5c 7a69
000e5d 7265
000e5e 0073          .db "set-recognizers",0
000e5f 0e4a          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_RECOGNIZERS
                 XT_SET_RECOGNIZERS:
000e60 1c01          .dw DO_COLON
                 PFA_SET_RECOGNIZERS:
                 .endif
000e61 1c38          .dw XT_DOLITERAL
000e62 0050          .dw CFG_RECOGNIZERLISTLEN
000e63 04c5          .dw XT_SET_STACK
000e64 1c1b          .dw XT_EXIT
                 
                 .include "words/get-recognizer.asm"
                 
                 ; Interpreter
                 ; Get the current recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_RECOGNIZERS:
000e65 ff0f          .dw $ff0f
000e66 6567
000e67 2d74
000e68 6572
000e69 6f63
000e6a 6e67
000e6b 7a69
000e6c 7265
000e6d 0073          .db "get-recognizers",0
000e6e 0e56          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_RECOGNIZERS
                 XT_GET_RECOGNIZERS:
000e6f 1c01          .dw DO_COLON
                 PFA_GET_RECOGNIZERS:
                 .endif
000e70 1c38          .dw XT_DOLITERAL
000e71 0050          .dw CFG_RECOGNIZERLISTLEN
000e72 04a4          .dw XT_GET_STACK
000e73 1c1b          .dw XT_EXIT
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000e74 ff04          .dw $ff04
000e75 6f63
000e76 6564          .db "code"
000e77 0e65          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000e78 1c01          .dw DO_COLON
                 PFA_CODE:
000e79 0275          .dw XT_DOCREATE
000e7a 03d5          .dw XT_REVEAL
000e7b 0619          .dw XT_DP
000e7c 0bed          .dw XT_ICELLPLUS
000e7d 02a3          .dw XT_COMMA
000e7e 1c1b          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000e7f ff08          .dw $ff08
000e80 6e65
000e81 2d64
000e82 6f63
000e83 6564          .db "end-code"
000e84 0e74          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000e85 1c01          .dw DO_COLON
                 PFA_ENDCODE:
000e86 0298          .dw XT_COMPILE
000e87 940c          .dw $940c
000e88 0298          .dw XT_COMPILE
000e89 1c05          .dw DO_NEXT
000e8a 1c1b          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
000e8b ff08          .dw $ff08
000e8c 6d28
000e8d 7261
000e8e 656b
000e8f 2972          .db "(marker)"
000e90 0e7f          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000e91 1c6a          .dw PFA_DOVALUE1
                 PFA_MARKER:
000e92 005c          .dw EE_MARKER
000e93 0bf6          .dw XT_EDEFERFETCH
000e94 0c00          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
000e95 0008          .dw $0008
000e96 6f70
000e97 7473
000e98 6f70
000e99 656e          .db "postpone"
000e9a 0e8b          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
000e9b 1c01          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
000e9c 0a1d          .dw XT_PARSENAME
000e9d 0b01          .dw XT_DORECOGNIZER
000e9e 1cac          .dw XT_DUP
000e9f 1cfa          .dw XT_TO_R
000ea0 0bed          .dw XT_ICELLPLUS
000ea1 0bed          .dw XT_ICELLPLUS
000ea2 1fbb          .dw XT_FETCHI
000ea3 1c25          .dw XT_EXECUTE
000ea4 1cf1          .dw XT_R_FROM
000ea5 0bed          .dw XT_ICELLPLUS
000ea6 1fbb          .dw XT_FETCHI
000ea7 02a3          .dw XT_COMMA
000ea8 1c1b          .dw XT_EXIT
                 .endif
                 .include "words/2r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_2R_FETCH:
000ea9 ff03          .dw $ff03
000eaa 7232
000eab 0040          .db "2r@",0
000eac 0e95          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FETCH
                 XT_2R_FETCH:
000ead 0eae          .dw PFA_2R_FETCH
                 PFA_2R_FETCH:
000eae 939a
000eaf 938a          savetos
000eb0 91ef          pop zl
000eb1 91ff          pop zh
000eb2 918f          pop tosl
000eb3 919f          pop tosh
000eb4 939f          push tosh
000eb5 938f          push tosl
000eb6 93ff          push zh
000eb7 93ef          push zl
000eb8 939a
000eb9 938a          savetos
000eba 01cf          movw tosl, zl
000ebb 940c 1c05     jmp_ DO_NEXT
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
001c01 93bf          push XH
001c02 93af          push XL          ; PUSH IP
001c03 01db          movw XL, wl
001c04 9611          adiw xl, 1
                 DO_NEXT:
001c05 f06e          brts DO_INTERRUPT
001c06 01fd          movw zl, XL        ; READ IP
001c07 0fee
001c08 1fff
001c09 9165
001c0a 9175          readflashcell wl, wh
001c0b 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
001c0c 01fb          movw zl, wl
001c0d 0fee
001c0e 1fff
001c0f 9105
001c10 9115          readflashcell temp0,temp1
001c11 01f8          movw zl, temp0
001c12 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
001c13 94e8          clt
001c14 e16e          ldi wl, LOW(XT_ISREXEC)
001c15 e072          ldi wh, HIGH(XT_ISREXEC)
001c16 cff5          rjmp DO_EXECUTE
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
001c17 ff04          .dw $ff04
001c18 7865
001c19 7469          .db "exit"
001c1a 0ea9          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
001c1b 1c1c          .dw PFA_EXIT
                 PFA_EXIT:
001c1c 91af          pop XL
001c1d 91bf          pop XH
001c1e cfe6          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
001c1f ff07          .dw $ff07
001c20 7865
001c21 6365
001c22 7475
001c23 0065          .db "execute",0
001c24 1c17          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
001c25 1c26          .dw PFA_EXECUTE
                 PFA_EXECUTE:
001c26 01bc          movw wl, tosl
001c27 9189
001c28 9199          loadtos
001c29 cfe2          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
001c2a 1c2b          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
001c2b 01fd          movw zl, XL
001c2c 0fee
001c2d 1fff
001c2e 91a5
001c2f 91b5          readflashcell XL,XH
001c30 cfd4          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
001c31 1c32          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
001c32 2b98          or tosh, tosl
001c33 9189
001c34 9199          loadtos
001c35 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
001c36 9611          adiw XL, 1
001c37 cfcd          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
001c38 1c39          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
001c39 939a
001c3a 938a          savetos
001c3b 01fd          movw zl, xl
001c3c 0fee
001c3d 1fff
001c3e 9185
001c3f 9195          readflashcell tosl,tosh
001c40 9611          adiw xl, 1
001c41 cfc3          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
001c42 1c43          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
001c43 939a
001c44 938a          savetos
001c45 01fb          movw zl, wl
001c46 9631          adiw zl,1
001c47 0fee
001c48 1fff
001c49 9185
001c4a 9195          readflashcell tosl,tosh
001c4b cfb9          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
001c4c 1c4d          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
001c4d 939a
001c4e 938a          savetos
001c4f 01cb          movw tosl, wl
001c50 9601          adiw tosl, 1
001c51 cfb3          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
001c52 1c53          .dw PFA_DOUSER
                 PFA_DOUSER:
001c53 939a
001c54 938a          savetos
001c55 01fb          movw zl, wl
001c56 9631          adiw zl, 1
001c57 0fee
001c58 1fff
001c59 9185
001c5a 9195          readflashcell tosl,tosh
001c5b 0d84          add tosl, upl
001c5c 1d95          adc tosh, uph
001c5d cfa7          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
001c5e ff07          .dw $ff07
001c5f 7628
001c60 6c61
001c61 6575
001c62 0029          .db "(value)", 0
001c63 1c1f          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
001c64 1c01          .dw DO_COLON
                 PFA_DOVALUE:
001c65 0275          .dw XT_DOCREATE
001c66 03d5          .dw XT_REVEAL
001c67 0298          .dw XT_COMPILE
001c68 1c6a          .dw PFA_DOVALUE1
001c69 1c1b          .dw XT_EXIT
                 PFA_DOVALUE1:
001c6a 940e 03ee     call_ DO_DODOES
001c6c 1cac          .dw XT_DUP
001c6d 0bed          .dw XT_ICELLPLUS
001c6e 1fbb          .dw XT_FETCHI
001c6f 1c25          .dw XT_EXECUTE
001c70 1c1b          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
001c71 ff01          .dw $ff01
001c72 0040          .db "@",0
001c73 1c5e          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
001c74 1c75          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
001c75 01fc          movw zl, tosl
                     ; low byte is read before the high byte
001c76 9181          ld tosl, z+
001c77 9191          ld tosh, z+
001c78 cf8c          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
001c79 ff01          .dw $ff01
001c7a 0021          .db "!",0
001c7b 1c71          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
001c7c 1c7d          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
001c7d 01fc          movw zl, tosl
001c7e 9189
001c7f 9199          loadtos
                     ; the high byte is written before the low byte
001c80 8391          std Z+1, tosh
001c81 8380          std Z+0, tosl
001c82 9189
001c83 9199          loadtos
001c84 cf80          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
001c85 ff02          .dw $ff02
001c86 2163          .db "c!"
001c87 1c79          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
001c88 1c89          .dw PFA_CSTORE
                 PFA_CSTORE:
001c89 01fc          movw zl, tosl
001c8a 9189
001c8b 9199          loadtos
001c8c 8380          st Z, tosl
001c8d 9189
001c8e 9199          loadtos
001c8f cf75          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
001c90 ff02          .dw $ff02
001c91 4063          .db "c@"
001c92 1c85          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
001c93 1c94          .dw PFA_CFETCH
                 PFA_CFETCH:
001c94 01fc          movw zl, tosl
001c95 2799          clr tosh
001c96 8180          ld tosl, Z
001c97 cf6d          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
001c98 ff02          .dw $ff02
001c99 7540          .db "@u"
001c9a 1c90          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
001c9b 1c01          .dw DO_COLON
                 PFA_FETCHU:
001c9c 1ef1          .dw XT_UP_FETCH
001c9d 1d98          .dw XT_PLUS
001c9e 1c74          .dw XT_FETCH
001c9f 1c1b          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
001ca0 ff02          .dw $ff02
001ca1 7521          .db "!u"
001ca2 1c98          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
001ca3 1c01          .dw DO_COLON
                 PFA_STOREU:
001ca4 1ef1          .dw XT_UP_FETCH
001ca5 1d98          .dw XT_PLUS
001ca6 1c7c          .dw XT_STORE
001ca7 1c1b          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
001ca8 ff03          .dw $ff03
001ca9 7564
001caa 0070          .db "dup",0
001cab 1ca0          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
001cac 1cad          .dw PFA_DUP
                 PFA_DUP:
001cad 939a
001cae 938a          savetos
001caf cf55          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
001cb0 ff04          .dw $ff04
001cb1 643f
001cb2 7075          .db "?dup"
001cb3 1ca8          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
001cb4 1cb5          .dw PFA_QDUP
                 PFA_QDUP:
001cb5 2f08          mov temp0, tosl
001cb6 2b09          or temp0, tosh
001cb7 f011          breq PFA_QDUP1
001cb8 939a
001cb9 938a          savetos
                 PFA_QDUP1:
001cba cf4a          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
001cbb ff04          .dw $ff04
001cbc 7773
001cbd 7061          .db "swap"
001cbe 1cb0          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
001cbf 1cc0          .dw PFA_SWAP
                 PFA_SWAP:
001cc0 018c          movw temp0, tosl
001cc1 9189
001cc2 9199          loadtos
001cc3 931a          st -Y, temp1
001cc4 930a          st -Y, temp0
001cc5 cf3f          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
001cc6 ff04          .dw $ff04
001cc7 766f
001cc8 7265          .db "over"
001cc9 1cbb          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
001cca 1ccb          .dw PFA_OVER
                 PFA_OVER:
001ccb 939a
001ccc 938a          savetos
001ccd 818a          ldd tosl, Y+2
001cce 819b          ldd tosh, Y+3
                 
001ccf cf35          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
001cd0 ff04          .dw $ff04
001cd1 7264
001cd2 706f          .db "drop"
001cd3 1cc6          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
001cd4 1cd5          .dw PFA_DROP
                 PFA_DROP:
001cd5 9189
001cd6 9199          loadtos
001cd7 cf2d          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
001cd8 ff03          .dw $ff03
001cd9 6f72
001cda 0074          .db "rot",0
001cdb 1cd0          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
001cdc 1cdd          .dw PFA_ROT
                 PFA_ROT:
001cdd 018c          movw temp0, tosl
001cde 9129          ld temp2, Y+
001cdf 9139          ld temp3, Y+ 
001ce0 9189
001ce1 9199          loadtos
                         
001ce2 933a          st -Y, temp3
001ce3 932a          st -Y, temp2
001ce4 931a          st -Y, temp1
001ce5 930a          st -Y, temp0
                 
001ce6 cf1e          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
001ce7 ff03          .dw $ff03
001ce8 696e
001ce9 0070          .db "nip",0
001cea 1cd8          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
001ceb 1cec          .dw PFA_NIP
                 PFA_NIP:
001cec 9622          adiw yl, 2
001ced cf17          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
001cee ff02          .dw $ff02
001cef 3e72          .db "r>"
001cf0 1ce7          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
001cf1 1cf2          .dw PFA_R_FROM
                 PFA_R_FROM:
001cf2 939a
001cf3 938a          savetos
001cf4 918f          pop tosl
001cf5 919f          pop tosh
001cf6 cf0e          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
001cf7 ff02          .dw $ff02
001cf8 723e          .db ">r"
001cf9 1cee          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
001cfa 1cfb          .dw PFA_TO_R
                 PFA_TO_R:
001cfb 939f          push tosh
001cfc 938f          push tosl
001cfd 9189
001cfe 9199          loadtos
001cff cf05          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
001d00 ff02          .dw $ff02
001d01 4072          .db "r@"
001d02 1cf7          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
001d03 1d04          .dw PFA_R_FETCH
                 PFA_R_FETCH:
001d04 939a
001d05 938a          savetos
001d06 918f          pop tosl
001d07 919f          pop tosh
001d08 939f          push tosh
001d09 938f          push tosl
001d0a cefa          jmp_ DO_NEXT
                 
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
001d0b ff02          .dw $ff02
001d0c 3e3c          .db "<>"
001d0d 1d00          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
001d0e 1c01          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
001d0f 1fd0
001d10 1d15
001d11 1c1b          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
001d12 ff02          .dw $ff02
001d13 3d30          .db "0="
001d14 1d0b          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
001d15 1d16          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
001d16 2b98          or tosh, tosl
001d17 f5d1          brne PFA_ZERO1
001d18 c030          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
001d19 ff02          .dw $ff02
001d1a 3c30          .db "0<"
001d1b 1d12          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
001d1c 1d1d          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
001d1d fd97          sbrc tosh,7
001d1e c02a          rjmp PFA_TRUE1
001d1f c032          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
001d20 ff02          .dw $ff02
001d21 3e30          .db "0>"
001d22 1d19          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
001d23 1d24          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
001d24 1582          cp tosl, zerol
001d25 0593          cpc tosh, zeroh
001d26 f15c          brlt PFA_ZERO1
001d27 f151          brbs 1, PFA_ZERO1
001d28 c020          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
001d29 ff03          .dw $ff03
001d2a 3064
001d2b 003e          .db "d0>",0
001d2c 1d20          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
001d2d 1d2e          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
001d2e 1582          cp tosl, zerol
001d2f 0593          cpc tosh, zeroh
001d30 9189
001d31 9199          loadtos
001d32 0582          cpc tosl, zerol
001d33 0593          cpc tosh, zeroh
001d34 f0ec          brlt PFA_ZERO1
001d35 f0e1          brbs 1, PFA_ZERO1
001d36 c012          rjmp PFA_TRUE1
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
001d37 ff03          .dw $ff03
001d38 3064
001d39 003c          .db "d0<",0
001d3a 1d29          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
001d3b 1d3c          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
001d3c 9622          adiw Y,2
001d3d fd97          sbrc tosh,7
001d3e 940c 1d49     jmp PFA_TRUE1
001d40 940c 1d52     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
001d42 ff04          .dw $ff04
001d43 7274
001d44 6575          .db "true"
001d45 1d37          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
001d46 1d47          .dw PFA_TRUE
                 PFA_TRUE:
001d47 939a
001d48 938a          savetos
                 PFA_TRUE1:
001d49 ef8f          ser tosl
001d4a ef9f          ser tosh
001d4b ceb9          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
001d4c ff01          .dw $ff01
001d4d 0030          .db "0",0
001d4e 1d42          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
001d4f 1d50          .dw PFA_ZERO
                 PFA_ZERO:
001d50 939a
001d51 938a          savetos
                 PFA_ZERO1:
001d52 01c1          movw tosl, zerol
001d53 ceb1          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
001d54 ff02          .dw $ff02
001d55 3c75          .db "u<"
001d56 1d4c          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
001d57 1d58          .dw PFA_ULESS
                 PFA_ULESS:
001d58 9129          ld temp2, Y+
001d59 9139          ld temp3, Y+
001d5a 1782          cp tosl, temp2
001d5b 0793          cpc tosh, temp3
001d5c f3a8          brlo PFA_ZERO1
001d5d f3a1          brbs 1, PFA_ZERO1
001d5e cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
001d5f ff02          .dw $ff02
001d60 3e75          .db "u>"
001d61 1d54          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
001d62 1c01          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
001d63 1cbf          .DW XT_SWAP
001d64 1d57          .dw XT_ULESS
001d65 1c1b          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
001d66 ff01          .dw $ff01
001d67 003c          .db "<",0
001d68 1d5f          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
001d69 1d6a          .dw PFA_LESS
                 PFA_LESS:
001d6a 9129          ld temp2, Y+
001d6b 9139          ld temp3, Y+
001d6c 1728          cp temp2, tosl
001d6d 0739          cpc temp3, tosh
                 PFA_LESSDONE:
001d6e f71c          brge PFA_ZERO1
001d6f cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
001d70 ff01          .dw $ff01
001d71 003e          .db ">",0
001d72 1d66          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
001d73 1d74          .dw PFA_GREATER
                 PFA_GREATER:
001d74 9129          ld temp2, Y+
001d75 9139          ld temp3, Y+
001d76 1728          cp temp2, tosl
001d77 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
001d78 f2cc          brlt PFA_ZERO1
001d79 f2c1          brbs 1, PFA_ZERO1
001d7a cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
001d7b ff04          .dw $ff04
001d7c 6f6c
001d7d 3267          .db "log2"
001d7e 1d70          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
001d7f 1d80          .dw PFA_LOG2
                 PFA_LOG2:
001d80 01fc          movw zl, tosl
001d81 2799          clr tosh
001d82 e180          ldi tosl, 16
                 PFA_LOG2_1:
001d83 958a          dec tosl
001d84 f022          brmi PFA_LOG2_2 ; wrong data
001d85 0fee          lsl  zl
001d86 1fff          rol  zh
001d87 f7d8          brcc PFA_LOG2_1
001d88 ce7c          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
001d89 959a          dec tosh
001d8a ce7a          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
001d8b ff01          .dw $ff01
001d8c 002d          .db "-",0
001d8d 1d7b          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
001d8e 1d8f          .dw PFA_MINUS
                 PFA_MINUS:
001d8f 9109          ld temp0, Y+
001d90 9119          ld temp1, Y+
001d91 1b08          sub temp0, tosl
001d92 0b19          sbc temp1, tosh
001d93 01c8          movw tosl, temp0
001d94 ce70          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
001d95 ff01          .dw $ff01
001d96 002b          .db "+",0
001d97 1d8b          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
001d98 1d99          .dw PFA_PLUS
                 PFA_PLUS:
001d99 9109          ld temp0, Y+
001d9a 9119          ld temp1, Y+
001d9b 0f80          add tosl, temp0
001d9c 1f91          adc tosh, temp1
001d9d ce67          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
001d9e ff02          .dw $ff02
001d9f 2a6d          .db "m*"
001da0 1d95          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
001da1 1da2          .dw PFA_MSTAR
                 PFA_MSTAR:
001da2 018c          movw temp0, tosl
001da3 9189
001da4 9199          loadtos
001da5 019c          movw temp2, tosl
                     ; high cell ah*bh
001da6 0231          muls temp3, temp1
001da7 0170          movw temp4, r0
                     ; low cell  al*bl
001da8 9f20          mul  temp2, temp0
001da9 01c0          movw tosl, r0
                     ; signed ah*bl
001daa 0330          mulsu temp3, temp0
001dab 08f3          sbc   temp5, zeroh
001dac 0d90          add   tosh,  r0
001dad 1ce1          adc   temp4, r1
001dae 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
001daf 0312          mulsu temp1, temp2
001db0 08f3          sbc   temp5, zeroh
001db1 0d90          add   tosh,  r0
001db2 1ce1          adc   temp4, r1
001db3 1cf3          adc   temp5, zeroh
                 
001db4 939a
001db5 938a          savetos
001db6 01c7          movw tosl, temp4
001db7 ce4d          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
001db8 ff06          .dw $ff06
001db9 6d75
001dba 6d2f
001dbb 646f          .db "um/mod"
001dbc 1d9e          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
001dbd 1dbe          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
001dbe 017c          movw temp4, tosl
                 
001dbf 9129          ld temp2, Y+
001dc0 9139          ld temp3, Y+
                   
001dc1 9109          ld temp0, Y+
001dc2 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
001dc3 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
001dc4 2755          clr temp7
001dc5 0f00          lsl temp0
001dc6 1f11          rol temp1
001dc7 1f22          rol temp2
001dc8 1f33          rol temp3
001dc9 1f55          rol temp7
                 
                   ; try subtracting divisor
001dca 152e          cp temp2, temp4
001dcb 053f          cpc temp3, temp5
001dcc 0552          cpc temp7,zerol
                 
001dcd f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
001dce 9503          inc temp0
001dcf 192e          sub temp2, temp4
001dd0 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
001dd1 954a          dec  temp6
001dd2 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
001dd3 933a          st -Y,temp3
001dd4 932a          st -Y,temp2
                 
                     ; put quotient on stack
001dd5 01c8          movw tosl, temp0
001dd6 ce2e          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
001dd7 ff03          .dw $ff03
001dd8 6d75
001dd9 002a          .db "um*",0
001dda 1db8          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
001ddb 1ddc          .dw PFA_UMSTAR
                 PFA_UMSTAR:
001ddc 018c          movw temp0, tosl
001ddd 9189
001dde 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
001ddf 9f80          mul tosl,temp0
001de0 01f0          movw zl, r0
001de1 2722          clr temp2
001de2 2733          clr temp3
                     ; middle bytes
001de3 9f90          mul tosh, temp0
001de4 0df0          add zh, r0
001de5 1d21          adc temp2, r1
001de6 1d33          adc temp3, zeroh
                         
001de7 9f81          mul tosl, temp1
001de8 0df0          add zh, r0
001de9 1d21          adc temp2, r1
001dea 1d33          adc temp3, zeroh
                     
001deb 9f91          mul tosh, temp1
001dec 0d20          add temp2, r0
001ded 1d31          adc temp3, r1
001dee 01cf          movw tosl, zl
001def 939a
001df0 938a          savetos
001df1 01c9          movw tosl, temp2
001df2 ce12          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
001df3 ff06          .dw $ff06
001df4 6e69
001df5 6576
001df6 7472          .db "invert"
001df7 1dd7          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
001df8 1df9          .dw PFA_INVERT
                 PFA_INVERT:
001df9 9580          com tosl
001dfa 9590          com tosh
001dfb ce09          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
001dfc ff02          .dw $ff02
001dfd 2f32          .db "2/"
001dfe 1df3          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
001dff 1e00          .dw PFA_2SLASH
                 PFA_2SLASH:
001e00 9595          asr tosh
001e01 9587          ror tosl
001e02 ce02          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
001e03 ff02          .dw $ff02
001e04 2a32          .db "2*"
001e05 1dfc          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
001e06 1e07          .dw PFA_2STAR
                 PFA_2STAR:
001e07 0f88          lsl tosl
001e08 1f99          rol tosh
001e09 cdfb          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
001e0a ff03          .dw $ff03
001e0b 6e61
001e0c 0064          .db "and",0
001e0d 1e03          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
001e0e 1e0f          .dw PFA_AND
                 PFA_AND:
001e0f 9109          ld temp0, Y+
001e10 9119          ld temp1, Y+
001e11 2380          and tosl, temp0
001e12 2391          and tosh, temp1
001e13 cdf1          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
001e14 ff02          .dw $ff02
001e15 726f          .db "or"
001e16 1e0a          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
001e17 1e18          .dw PFA_OR
                 PFA_OR:
001e18 9109          ld temp0, Y+
001e19 9119          ld temp1, Y+
001e1a 2b80          or tosl, temp0
001e1b 2b91          or tosh, temp1
001e1c cde8          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
001e1d ff03          .dw $ff03
001e1e 6f78
001e1f 0072          .db "xor",0
001e20 1e14          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
001e21 1e22          .dw PFA_XOR
                 PFA_XOR:
001e22 9109          ld temp0, Y+
001e23 9119          ld temp1, Y+
001e24 2780          eor tosl, temp0
001e25 2791          eor tosh, temp1
001e26 cdde          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
001e27 ff02          .dw $ff02
001e28 2b31          .db "1+"
001e29 1e1d          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
001e2a 1e2b          .dw PFA_1PLUS
                 PFA_1PLUS:
001e2b 9601          adiw tosl,1
001e2c cdd8          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
001e2d ff02          .dw $ff02 
001e2e 2d31          .db "1-"
001e2f 1e27          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
001e30 1e31          .dw PFA_1MINUS
                 PFA_1MINUS:
001e31 9701          sbiw tosl, 1
001e32 cdd2          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
001e33 ff06          .dw $ff06
001e34 736c
001e35 6968
001e36 7466          .db "lshift"
001e37 1e2d          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
001e38 1e39          .dw PFA_LSHIFT
                 PFA_LSHIFT:
001e39 01fc          movw zl, tosl
001e3a 9189
001e3b 9199          loadtos
                 PFA_LSHIFT1:
001e3c 9731          sbiw zl, 1
001e3d f01a          brmi PFA_LSHIFT2
001e3e 0f88          lsl tosl
001e3f 1f99          rol tosh
001e40 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
001e41 cdc3          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
001e42 ff06          .dw $ff06
001e43 7372
001e44 6968
001e45 7466          .db "rshift"
001e46 1e33          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
001e47 1e48          .dw PFA_RSHIFT
                 PFA_RSHIFT:
001e48 01fc          movw zl, tosl
001e49 9189
001e4a 9199          loadtos
                 PFA_RSHIFT1:
001e4b 9731          sbiw zl, 1
001e4c f01a          brmi PFA_RSHIFT2
001e4d 9596          lsr tosh
001e4e 9587          ror tosl
001e4f cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
001e50 cdb4          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
001e51 ff02          .dw $ff02
001e52 212b          .db "+!"
001e53 1e42          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
001e54 1e55          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
001e55 01fc          movw zl, tosl
001e56 9189
001e57 9199          loadtos
001e58 8120          ldd temp2, Z+0
001e59 8131          ldd temp3, Z+1
001e5a 0f82          add tosl, temp2
001e5b 1f93          adc tosh, temp3
001e5c 8380          std Z+0, tosl
001e5d 8391          std Z+1, tosh
001e5e 9189
001e5f 9199          loadtos
001e60 cda4          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
001e61 ff03          .dw $ff03
001e62 7072
001e63 0040          .db "rp@",0
001e64 1e51          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
001e65 1e66          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
001e66 939a
001e67 938a          savetos
001e68 b78d          in tosl, SPL
001e69 b79e          in tosh, SPH
001e6a cd9a          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
001e6b ff03          .dw $ff03
001e6c 7072
001e6d 0021          .db "rp!",0
001e6e 1e61          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
001e6f 1e70          .dw PFA_RP_STORE
                 PFA_RP_STORE:
001e70 b72f          in temp2, SREG
001e71 94f8          cli
001e72 bf8d          out SPL, tosl
001e73 bf9e          out SPH, tosh
001e74 bf2f          out SREG, temp2
001e75 9189
001e76 9199          loadtos
001e77 cd8d          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
001e78 ff03          .dw $ff03
001e79 7073
001e7a 0040          .db "sp@",0
001e7b 1e6b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
001e7c 1e7d          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
001e7d 939a
001e7e 938a          savetos
001e7f 01ce          movw tosl, yl
001e80 cd84          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
001e81 ff03          .dw $ff03
001e82 7073
001e83 0021          .db "sp!",0
001e84 1e78          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
001e85 1e86          .dw PFA_SP_STORE
                 PFA_SP_STORE:
001e86 01ec          movw yl, tosl
001e87 9189
001e88 9199          loadtos
001e89 cd7b          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
001e8a 1e8b          .dw PFA_DODO
                 PFA_DODO:
001e8b 9129          ld temp2, Y+
001e8c 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
001e8d e8e0          ldi zl, $80
001e8e 0f3e          add temp3, zl
001e8f 1b82          sub  tosl, temp2
001e90 0b93          sbc  tosh, temp3
                 
001e91 933f          push temp3
001e92 932f          push temp2    ; limit  ( --> limit + $8000)
001e93 939f          push tosh
001e94 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
001e95 9189
001e96 9199          loadtos
001e97 cd6d          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
001e98 ff01          .dw $FF01
001e99 0069          .db "i",0
001e9a 1e81          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
001e9b 1e9c          .dw PFA_I
                 PFA_I:
001e9c 939a
001e9d 938a          savetos
001e9e 918f          pop tosl
001e9f 919f          pop tosh  ; index
001ea0 91ef          pop zl
001ea1 91ff          pop zh    ; limit
001ea2 93ff          push zh
001ea3 93ef          push zl
001ea4 939f          push tosh
001ea5 938f          push tosl
001ea6 0f8e          add tosl, zl
001ea7 1f9f          adc tosh, zh
001ea8 cd5c          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
001ea9 1eaa          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
001eaa 91ef          pop zl
001eab 91ff          pop zh
001eac 0fe8          add zl, tosl
001ead 1ff9          adc zh, tosh
001eae 9189
001eaf 9199          loadtos
001eb0 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
001eb1 93ff          push zh
001eb2 93ef          push zl
001eb3 cd77          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
001eb4 910f          pop  temp0
001eb5 911f          pop  temp1  ; remove limit
001eb6 9611          adiw xl, 1  ; skip branch-back address
001eb7 cd4d          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
001eb8 1eb9          .dw PFA_DOLOOP
                 PFA_DOLOOP:
001eb9 91ef          pop zl
001eba 91ff          pop zh
001ebb 9631          adiw zl,1
001ebc f3bb          brvs PFA_DOPLUSLOOP_LEAVE
001ebd cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
001ebe ff06          .dw $ff06
001ebf 6e75
001ec0 6f6c
001ec1 706f          .db "unloop"
001ec2 1e98          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
001ec3 1ec4          .dw PFA_UNLOOP
                 PFA_UNLOOP:
001ec4 911f          pop temp1
001ec5 910f          pop temp0
001ec6 911f          pop temp1
001ec7 910f          pop temp0
001ec8 cd3c          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
001ec9 ff06          .dw $ff06
001eca 6d63
001ecb 766f
001ecc 3e65          .db "cmove>"
001ecd 1ebe          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
001ece 1ecf          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
001ecf 93bf          push xh
001ed0 93af          push xl
001ed1 91e9          ld zl, Y+
001ed2 91f9          ld zh, Y+ ; addr-to
001ed3 91a9          ld xl, Y+
001ed4 91b9          ld xh, Y+ ; addr-from
001ed5 2f09          mov temp0, tosh
001ed6 2b08          or temp0, tosl
001ed7 f041          brbs 1, PFA_CMOVE_G1
001ed8 0fe8          add zl, tosl
001ed9 1ff9          adc zh, tosh
001eda 0fa8          add xl, tosl
001edb 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
001edc 911e          ld temp1, -X
001edd 9312          st -Z, temp1
001ede 9701          sbiw tosl, 1
001edf f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
001ee0 91af          pop xl
001ee1 91bf          pop xh
001ee2 9189
001ee3 9199          loadtos
001ee4 cd20          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
001ee5 ff02          .dw $ff02
001ee6 3c3e          .db "><"
001ee7 1ec9          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
001ee8 1ee9          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
001ee9 2f09          mov temp0, tosh
001eea 2f98          mov tosh, tosl
001eeb 2f80          mov tosl, temp0
001eec cd18          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
001eed ff03          .dw $ff03
001eee 7075
001eef 0040          .db "up@",0
001ef0 1ee5          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
001ef1 1ef2          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
001ef2 939a
001ef3 938a          savetos
001ef4 01c2          movw tosl, upl
001ef5 cd0f          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
001ef6 ff03          .dw $ff03
001ef7 7075
001ef8 0021          .db "up!",0
001ef9 1eed          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
001efa 1efb          .dw PFA_UP_STORE
                 PFA_UP_STORE:
001efb 012c          movw upl, tosl
001efc 9189
001efd 9199          loadtos
001efe cd06          jmp_ DO_NEXT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
001eff ff03          .dw $ff03
001f00 6d31
001f01 0073          .db "1ms",0
001f02 1ef6          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
001f03 1f04          .dw PFA_1MS
                 PFA_1MS:
001f04 ede0
001f05 e0f7
001f06 9731
001f07 f7f1          delay 1000
001f08 ccfc          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
001f09 ff03          .dw $ff03
001f0a 3e32
001f0b 0072          .db "2>r",0
001f0c 1eff          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
001f0d 1f0e          .dw PFA_2TO_R
                 PFA_2TO_R:
001f0e 01fc          movw zl, tosl
001f0f 9189
001f10 9199          loadtos
001f11 939f          push tosh
001f12 938f          push tosl
001f13 93ff          push zh
001f14 93ef          push zl
001f15 9189
001f16 9199          loadtos
001f17 cced          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
001f18 ff03          .dw $ff03
001f19 7232
001f1a 003e          .db "2r>",0
001f1b 1f09          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
001f1c 1f1d          .dw PFA_2R_FROM
                 PFA_2R_FROM:
001f1d 939a
001f1e 938a          savetos
001f1f 91ef          pop zl
001f20 91ff          pop zh
001f21 918f          pop tosl
001f22 919f          pop tosh
001f23 939a
001f24 938a          savetos
001f25 01cf          movw tosl, zl
001f26 ccde          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
001f27 ff02          .dw $ff02
001f28 6521          .db "!e"
001f29 1f18          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
001f2a 1f2b          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
001f2b 01fc          movw zl, tosl
001f2c 9189
001f2d 9199          loadtos
001f2e b72f          in_ temp2, SREG
001f2f 94f8          cli
001f30 d028          rcall PFA_FETCHE2
001f31 b30d          in_  temp0, EEDR
001f32 1708          cp temp0,tosl
001f33 f009          breq PFA_STOREE3
001f34 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
001f35 9631          adiw zl,1
001f36 d022          rcall PFA_FETCHE2
001f37 b30d          in_  temp0, EEDR
001f38 1709          cp temp0,tosh
001f39 f011          breq PFA_STOREE4
001f3a 2f89          mov tosl, tosh
001f3b d004          rcall PFA_STOREE1
                 PFA_STOREE4:
001f3c bf2f          out_ SREG, temp2
001f3d 9189
001f3e 9199          loadtos
001f3f ccc5          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
001f40 99e1          sbic EECR, EEPE
001f41 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
001f42 b707          in_ temp0, SPMCSR
001f43 fd00          sbrc temp0,SPMEN
001f44 cffd          rjmp PFA_STOREE2
                 
001f45 bbff          out_ EEARH,zh
001f46 bbee          out_ EEARL,zl
001f47 bb8d          out_ EEDR, tosl
001f48 9ae2          sbi EECR,EEMPE
001f49 9ae1          sbi EECR,EEPE
                 
001f4a 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
001f4b ff02          .dw $ff02
001f4c 6540          .db "@e"
001f4d 1f27          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
001f4e 1f4f          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
001f4f b72f          in_ temp2, SREG
001f50 94f8          cli
001f51 01fc          movw zl, tosl
001f52 d006          rcall PFA_FETCHE2
001f53 b38d          in_ tosl, EEDR
                 
001f54 9631          adiw zl,1
                 
001f55 d003          rcall PFA_FETCHE2
001f56 b39d          in_  tosh, EEDR
001f57 bf2f          out_ SREG, temp2
001f58 ccac          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
001f59 99e1          sbic EECR, EEPE
001f5a cffe          rjmp PFA_FETCHE2
                 
001f5b bbff          out_ EEARH,zh
001f5c bbee          out_ EEARL,zl
                 
001f5d 9ae0          sbi EECR,EERE
001f5e 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
001f5f ff02          .dw $ff02
001f60 6921          .db "!i"
001f61 1f4b          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
001f62 0c55          .dw PFA_DODEFER1
                 PFA_STOREI:
001f63 005a          .dw EE_STOREI
001f64 0bf6          .dw XT_EDEFERFETCH
001f65 0c00          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
001f66 ff09          .dw $ff09
001f67 2128
001f68 2d69
001f69 726e
001f6a 7777
001f6b 0029          .db "(!i-nrww)",0
001f6c 1f5f          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
001f6d 1f6e          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
001f6e b71f        in temp1,SREG
001f6f 931f        push temp1
001f70 94f8        cli
                 
001f71 019c        movw temp2, tosl ; save the (word) address
001f72 9189
001f73 9199        loadtos          ; get the new value for the flash cell
001f74 93af        push xl
001f75 93bf        push xh
001f76 93cf        push yl
001f77 93df        push yh
001f78 d009        rcall DO_STOREI_atmega
001f79 91df        pop yh
001f7a 91cf        pop yl
001f7b 91bf        pop xh
001f7c 91af        pop xl
                   ; finally clear the stack
001f7d 9189
001f7e 9199        loadtos
001f7f 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
001f80 bf1f        out SREG,temp1
                 
001f81 cc83        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
001f82 d011        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
001f83 94e0        com temp4
001f84 94f0        com temp5
001f85 218e        and tosl, temp4
001f86 219f        and tosh, temp5
001f87 2b98        or tosh, tosl
001f88 f021        breq DO_STOREI_writepage 
001f89 94b3          inc erase_counter
001f8a 01f9          movw zl, temp2
001f8b e002          ldi temp0,(1<<PGERS)
001f8c d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
001f8d 01f9        movw zl, temp2
001f8e e004        ldi temp0,(1<<PGWRT)
001f8f d01d        rcall dospm
                 
                   ; reenable RWW section
001f90 01f9        movw zl, temp2
001f91 e100        ldi temp0,(1<<RWWSRE)
001f92 d01a        rcall dospm
001f93 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
001f94 01f9        movw zl, temp2
                   ; get the beginning of page
001f95 7ce0        andi zl,low(pagemask)
001f96 7fff        andi zh,high(pagemask)
001f97 01ef        movw y, z
                   ; loop counter (in words)
001f98 e4a0        ldi xl,low(pagesize)
001f99 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
001f9a 01fe        movw z, y
001f9b 0fee
001f9c 1fff
001f9d 9145
001f9e 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
001f9f 01fe        movw z, y
001fa0 17e2        cp zl, temp2
001fa1 07f3        cpc zh, temp3
001fa2 f011        breq pageload_newdata
001fa3 010a          movw r0, temp6
001fa4 c002          rjmp pageload_cont
                 pageload_newdata:
001fa5 017a          movw temp4, temp6
001fa6 010c          movw r0, tosl
                 pageload_cont:
001fa7 2700        clr temp0
001fa8 d004        rcall dospm
001fa9 9621        adiw y, 1
001faa 9711        sbiw x, 1
001fab f771        brne pageload_loop
                 
                 pageload_done:
001fac 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
001fad 99e1        sbic EECR, EEPE
001fae cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
001faf b717        in_  temp1, SPMCSR
001fb0 fd10        sbrc temp1, SPMEN
001fb1 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
001fb2 0fee
001fb3 1fff        writeflashcell
                   ; execute spm
001fb4 6001        ori temp0, (1<<SPMEN)
001fb5 bf07        out_ SPMCSR,temp0
001fb6 95e8        spm
001fb7 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
001fb8 ff02          .dw $ff02
001fb9 6940          .db "@i"
001fba 1f66          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
001fbb 1fbc          .dw PFA_FETCHI
                 PFA_FETCHI:
001fbc 01fc          movw zl, tosl
001fbd 0fee
001fbe 1fff
001fbf 9185
001fc0 9195          readflashcell tosl,tosh
001fc1 cc43          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .include "dict/core_2k.inc"
                 
                 .else
                 .endif
                 ; now colon words
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2LITERAL:
001fc2 0008          .dw $0008
001fc3 6c32
001fc4 7469
001fc5 7265
001fc6 6c61          .db "2literal"
001fc7 1fb8          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
001fc8 1c01          .dw DO_COLON
                 PFA_2LITERAL:
                 .endif
001fc9 1cbf          .dw XT_SWAP
001fca 02b9          .dw XT_LITERAL
001fcb 02b9          .dw XT_LITERAL
001fcc 1c1b          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
001fcd ff01          .dw $ff01
001fce 003d          .db "=",0
001fcf 1fc2          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
001fd0 1c01          .dw DO_COLON
                 PFA_EQUAL:
001fd1 1d8e          .dw XT_MINUS
001fd2 1d15          .dw XT_ZEROEQUAL
001fd3 1c1b          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
001fd4 ff01          .dw $ff01
001fd5 0031          .db "1",0
001fd6 1fcd          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
001fd7 1c43          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
001fd8 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
001fd9 ff01          .dw $ff01
001fda 0032          .db "2",0
001fdb 1fd4          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
001fdc 1c43          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
001fdd 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
001fde ff02          .dw $ff02
001fdf 312d          .db "-1"
001fe0 1fd9          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
001fe1 1c43          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
001fe2 ffff              .DW -1
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
00002a ff ff     
                 ; some configs
00002c bd 0e     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
00002e 07 01     EE_HERE:     .dw HERESTART       ; Memory Allocation
000030 7c 00     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
000032 03 05     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
                 ; LEAVE stack is between data stack and return stack.
000034 10 04     CFG_LP0:     .dw stackstart+1
000036 10 0e     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
000038 9c 05     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
00003a 3c 00     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
00003c de 1f     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
00003e 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000040 3c 00         .dw CFG_FORTHWORDLIST      ; get/set-order
000042               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
000050 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
000052 67 0b         .dw XT_REC_WORD
000054 53 0b         .dw XT_REC_NUM
000056               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_STOREI:
00005a 6d 1f         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
00005c 5c 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
00005e 00 00         .dw 0  ; USER_STATE
000060 00 00         .dw 0  ; USER_FOLLOWER
000062 5f 04         .dw rstackstart  ; USER_RP
000064 0f 04         .dw stackstart   ; USER_SP0
000066 0f 04         .dw stackstart   ; USER_SP
                     
000068 00 00         .dw 0  ; USER_HANDLER
00006a 0a 00         .dw 10 ; USER_BASE
                     
00006c 85 00         .dw XT_TX  ; USER_EMIT
00006e 93 00         .dw XT_TXQ ; USER_EMITQ
000070 5b 00         .dw XT_RX  ; USER_KEY
000072 75 00         .dw XT_RXQ ; USER_KEYQ
000074 68 0d         .dw XT_SOURCETIB ; USER_SKEY
000076 00 00         .dw 0            ; USER_G_IN
000078 55 0d         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
00007a 0c 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega16" register use summary:
r0 :  20 r1 :   5 r2 :   9 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   1 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  83 r17:  56 r18:  61 r19:  37 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 201 r25: 139 r26:  39 r27:  21 r28:   7 r29:   4 r30:  83 r31:  45 
x  :   4 y  : 205 z  :  48 
Registers used: 29 out of 35 (82.9%)

"ATmega16" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  21 add   :  16 adiw  :  18 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  19 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   1 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  12 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  10 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :   8 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  26 inc   :   3 jmp   :  25 
ld    : 138 ldd   :   4 ldi   :  39 lds   :   2 lpm   :  16 lsl   :  14 
lsr   :   1 mov   :  10 movw  :  70 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  23 pop   :  48 
push  :  42 rcall :  34 ret   :   7 reti  :   2 rjmp  :  93 rol   :  23 
ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 sbis  :   0 
sbiw  :  16 sbr   :   0 sbrc  :   5 sbrs  :   7 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   2 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  74 std   :   8 sts   :   3 
sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 77 out of 113 (68.1%)

"ATmega16" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x003fc6   2056   9430  11486   16384  70.1%
[.dseg] 0x000060 0x000107      0    167    167    1024  16.3%
[.eseg] 0x000000 0x00007c      0    124    124     512  24.2%

Assembly complete, 0 errors, 5 warnings
