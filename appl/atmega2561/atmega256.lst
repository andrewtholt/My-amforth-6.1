
AVRASM ver. 2.1.52  atmega256.asm Sat Oct 17 14:26:18 2015

atmega256.asm(11): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega2561\device.asm'
../../avr8/devices/atmega2561\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m2561def.inc'
atmega256.asm(15): Including file '../../avr8\drivers/usart_1.asm'
../../avr8\drivers/usart_1.asm(31): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(5): Including file '../../avr8\drivers/usart-isr-rx.asm'
../../avr8\drivers/usart_common.asm(17): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(22): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(23): Including file '../../avr8\words/usart.asm'
atmega256.asm(18): Including file '../../avr8\amforth-low.asm'
../../avr8\amforth-low.asm(11): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth-low.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth-low.asm(15): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(9): Including file '../../avr8\dict/appl_8k.inc'
../../avr8\dict/appl_8k.inc(1): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/newest.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/do-create.asm'
../../avr8\dict/compiler1.inc(5): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(9): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(10): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(17): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(33): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(38): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../common\words/create.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../common\words/reveal.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(53): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../common\words/recurse.asm'
../../avr8\dict/compiler1.inc(56): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(61): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(67): Including file '../../common\words/get-order.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(70): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth-low.asm(16): Including file 'dict_appl.inc'
dict_appl.inc(4): Including file 'words/applturnkey.asm'
../../avr8\amforth-low.asm(17): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(36): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(41): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(45): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(46): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(48): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(55): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(62): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(88): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(92): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(94): Including file '../../avr8\words/store-i_big.asm'
../../avr8\dict/nrww.inc(98): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(101): Including file '../../avr8\dict/core_8k.inc'
../../avr8\dict/core_8k.inc(2): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_8k.inc(3): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_8k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_8k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_8k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_8k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_8k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_8k.inc(10): Including file '../../avr8\words/d-equal.asm'
../../avr8\dict/core_8k.inc(11): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_8k.inc(12): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_8k.inc(14): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_8k.inc(15): Including file '../../common\words/words.asm'
../../avr8\dict/core_8k.inc(16): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(2): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(3): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(4): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(8): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/core_8k.inc(18): Including file '../../common\words/pick.asm'
../../avr8\dict/core_8k.inc(19): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_8k.inc(20): Including file '../../common\words/squote.asm'
../../avr8\dict/core_8k.inc(22): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_8k.inc(24): Including file '../../avr8\words/environment.asm'
../../avr8\dict/core_8k.inc(25): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/core_8k.inc(26): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/core_8k.inc(27): Including file '../../common\words/env-slashhold.asm'
../../avr8\dict/core_8k.inc(28): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/core_8k.inc(29): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/core_8k.inc(30): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/core_8k.inc(31): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/core_8k.inc(32): Including file '../../common\words/env-usersize.asm'
../../avr8\dict/core_8k.inc(34): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_8k.inc(35): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_8k.inc(36): Including file '../../common\words/base.asm'
../../avr8\dict/core_8k.inc(38): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_8k.inc(39): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_8k.inc(41): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_8k.inc(42): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_8k.inc(44): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_8k.inc(46): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_8k.inc(47): Including file '../../common\words/pad.asm'
../../avr8\dict/core_8k.inc(48): Including file '../../common\words/emit.asm'
../../avr8\dict/core_8k.inc(49): Including file '../../common\words/emitq.asm'
../../avr8\dict/core_8k.inc(50): Including file '../../common\words/key.asm'
../../avr8\dict/core_8k.inc(51): Including file '../../common\words/keyq.asm'
../../avr8\dict/core_8k.inc(53): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_8k.inc(54): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_8k.inc(55): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_8k.inc(56): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_8k.inc(58): Including file '../../common\words/bin.asm'
../../avr8\dict/core_8k.inc(59): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_8k.inc(60): Including file '../../common\words/hex.asm'
../../avr8\dict/core_8k.inc(61): Including file '../../common\words/bl.asm'
../../avr8\dict/core_8k.inc(63): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_8k.inc(65): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_8k.inc(66): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_8k.inc(67): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_8k.inc(68): Including file '../../common\words/slash.asm'
../../avr8\dict/core_8k.inc(69): Including file '../../common\words/mod.asm'
../../avr8\dict/core_8k.inc(70): Including file '../../avr8\words/abs.asm'
../../avr8\dict/core_8k.inc(71): Including file '../../common\words/min.asm'
../../avr8\dict/core_8k.inc(72): Including file '../../common\words/max.asm'
../../avr8\dict/core_8k.inc(73): Including file '../../common\words/within.asm'
../../avr8\dict/core_8k.inc(75): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_8k.inc(76): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_8k.inc(78): Including file '../../avr8\words/hld.asm'
../../avr8\dict/core_8k.inc(79): Including file '../../common\words/hold.asm'
../../avr8\dict/core_8k.inc(80): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/core_8k.inc(81): Including file '../../common\words/sharp.asm'
../../avr8\dict/core_8k.inc(82): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/core_8k.inc(83): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/core_8k.inc(84): Including file '../../common\words/sign.asm'
../../avr8\dict/core_8k.inc(85): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/core_8k.inc(86): Including file '../../common\words/dot-r.asm'
../../avr8\dict/core_8k.inc(87): Including file '../../common\words/d-dot.asm'
../../avr8\dict/core_8k.inc(88): Including file '../../common\words/dot.asm'
../../avr8\dict/core_8k.inc(89): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/core_8k.inc(90): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/core_8k.inc(91): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/core_8k.inc(92): Including file '../../common\words/digit-q.asm'
../../avr8\dict/core_8k.inc(94): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/core_8k.inc(95): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/core_8k.inc(96): Including file '../../avr8\words/itype.asm'
../../avr8\dict/core_8k.inc(97): Including file '../../avr8\words/icount.asm'
../../avr8\dict/core_8k.inc(98): Including file '../../common\words/cr.asm'
../../avr8\dict/core_8k.inc(99): Including file '../../common\words/space.asm'
../../avr8\dict/core_8k.inc(100): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_8k.inc(101): Including file '../../common\words/type.asm'
../../avr8\dict/core_8k.inc(102): Including file '../../common\words/tick.asm'
../../avr8\dict/core_8k.inc(104): Including file '../../common\words/handler.asm'
../../avr8\dict/core_8k.inc(105): Including file '../../common\words/catch.asm'
../../avr8\dict/core_8k.inc(106): Including file '../../common\words/throw.asm'
../../avr8\dict/core_8k.inc(108): Including file '../../common\words/cskip.asm'
../../avr8\dict/core_8k.inc(109): Including file '../../common\words/cscan.asm'
../../avr8\dict/core_8k.inc(110): Including file '../../common\words/accept.asm'
../../avr8\dict/core_8k.inc(111): Including file '../../common\words/refill.asm'
../../avr8\dict/core_8k.inc(112): Including file '../../common\words/char.asm'
../../avr8\dict/core_8k.inc(113): Including file '../../common\words/number.asm'
../../avr8\dict/core_8k.inc(114): Including file '../../common\words/q-sign.asm'
../../avr8\dict/core_8k.inc(115): Including file '../../common\words/set-base.asm'
../../avr8\dict/core_8k.inc(116): Including file '../../common\words/to-number.asm'
../../avr8\dict/core_8k.inc(117): Including file '../../common\words/parse.asm'
../../avr8\dict/core_8k.inc(118): Including file '../../common\words/source.asm'
../../avr8\dict/core_8k.inc(119): Including file '../../common\words/slash-string.asm'
../../avr8\dict/core_8k.inc(120): Including file '../../common\words/parse-name.asm'
../../avr8\dict/core_8k.inc(121): Including file '../../common\words/find-name.asm'
../../avr8\dict/core_8k.inc(123): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_8k.inc(124): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_8k.inc(125): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_8k.inc(127): Including file '../../common\words/quit.asm'
../../avr8\dict/core_8k.inc(128): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_8k.inc(129): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_8k.inc(130): Including file '../../common\words/warm.asm'
../../avr8\dict/core_8k.inc(132): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/core_8k.inc(133): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/core_8k.inc(134): Including file '../../common\words/depth.asm'
../../avr8\dict/core_8k.inc(135): Including file '../../common\words/interpret.asm'
../../avr8\dict/core_8k.inc(136): Including file '../../common\words/do-recognizer.asm'
../../avr8\dict/core_8k.inc(137): Including file '../../common\words/r-intnumber.asm'
../../avr8\dict/core_8k.inc(138): Including file '../../common\words/r-word.asm'
../../avr8\dict/core_8k.inc(139): Including file '../../common\words/r-fail.asm'
../../avr8\dict/core_8k.inc(141): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_8k.inc(142): Including file '../../common\words/ver.asm'
../../avr8\dict/core_8k.inc(144): Including file '../../common\words/noop.asm'
../../avr8\dict/core_8k.inc(145): Including file '../../avr8\words/unused.asm'
../../avr8\dict/core_8k.inc(147): Including file '../../common\words/to.asm'
../../avr8\dict/core_8k.inc(148): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/core_8k.inc(150): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_8k.inc(151): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_8k.inc(152): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_8k.inc(153): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_8k.inc(154): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_8k.inc(155): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_8k.inc(156): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_8k.inc(157): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_8k.inc(158): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_8k.inc(160): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/core_8k.inc(161): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/core_8k.inc(162): Including file '../../common\words/name2string.asm'
../../avr8\dict/core_8k.inc(163): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/core_8k.inc(164): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/core_8k.inc(166): Including file '../../common\words/star.asm'
../../avr8\dict/core_8k.inc(167): Including file '../../avr8\words/j.asm'
../../avr8\dict/core_8k.inc(169): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/core_8k.inc(170): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/core_8k.inc(171): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/core_8k.inc(172): Including file '../../common\words/2swap.asm'
../../avr8\dict/core_8k.inc(174): Including file '../../common\words/tib.asm'
../../avr8\dict/core_8k.inc(176): Including file '../../avr8\words/init-ram.asm'
../../avr8\dict/core_8k.inc(177): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../common\words/set-order.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../common\words/set-recognizer.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../common\words/get-recognizer.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(16): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(17): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(18): Including file '../../common\words/postpone.asm'
../../avr8\dict/core_8k.inc(178): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_8k.inc(179): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_8k.inc(180): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/nrww.inc(111): Including file '../../common\words/2literal.asm'
../../avr8\dict/nrww.inc(112): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(113): Including file '../../common\words/num-constants.asm'
../../avr8\amforth-low.asm(18): Including file 'dict_appl_core.inc'
../../avr8\amforth-low.asm(27): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; both a 24bit address space and they need a special
                 ; flash store placement in the NRWW section, way outside
                 ; of the standard 16bit jump distance.
                 
                 ; note that dict_appl_core includes a store-i_big.asm
                 ; instead if the normal store-i.asm file. This file
                 ; has all the magic needed for the large address space.
                 ; *everything else* is identical to other controllers.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set SYSUSERSIZE = 28
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot      = r10
                   .def erase_counter = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  512
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_TWI = 0
                 .set WANT_SPI = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_PORTG = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_USART1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TIMER_COUNTER_5 = 0
                 .set WANT_TIMER_COUNTER_4 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_JTAG = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_CPU = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_BOOT_LOAD = 0
                 .equ intvecsize = 2 ; please verify; flash size: 262144 bytes
                 .equ pclen = 3 ; please verify
                 .overlap
                 .org 2
000002 d121      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d11f      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d11d      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d11b      	 rcall isr ; External Interrupt Request 3
                 .org 10
00000a d119      	 rcall isr ; External Interrupt Request 4
                 .org 12
00000c d117      	 rcall isr ; External Interrupt Request 5
                 .org 14
00000e d115      	 rcall isr ; External Interrupt Request 6
                 .org 16
000010 d113      	 rcall isr ; External Interrupt Request 7
                 .org 18
000012 d111      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 20
000014 d10f      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 22
000016 d10d      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 24
000018 d10b      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 26
00001a d109      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 28
00001c d107      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 30
00001e d105      	 rcall isr ; Timer/Counter2 Overflow
                 .org 32
000020 d103      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 34
000022 d101      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 36
000024 d0ff      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 38
000026 d0fd      	 rcall isr ; Timer/Counter1 Compare Match C
                 .org 40
000028 d0fb      	 rcall isr ; Timer/Counter1 Overflow
                 .org 42
00002a d0f9      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 44
00002c d0f7      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 46
00002e d0f5      	 rcall isr ; Timer/Counter0 Overflow
                 .org 48
000030 d0f3      	 rcall isr ; SPI Serial Transfer Complete
                 .org 50
000032 d0f1      	 rcall isr ; USART0, Rx Complete
                 .org 52
000034 d0ef      	 rcall isr ; USART0 Data register Empty
                 .org 54
000036 d0ed      	 rcall isr ; USART0, Tx Complete
                 .org 56
000038 d0eb      	 rcall isr ; Analog Comparator
                 .org 58
00003a d0e9      	 rcall isr ; ADC Conversion Complete
                 .org 60
00003c d0e7      	 rcall isr ; EEPROM Ready
                 .org 62
00003e d0e5      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d0e3      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d0e1      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d0df      	 rcall isr ; Timer/Counter3 Compare Match C
                 .org 70
000046 d0dd      	 rcall isr ; Timer/Counter3 Overflow
                 .org 72
000048 d0db      	 rcall isr ; USART1, Rx Complete
                 .org 74
00004a d0d9      	 rcall isr ; USART1 Data register Empty
                 .org 76
00004c d0d7      	 rcall isr ; USART1, Tx Complete
                 .org 78
00004e d0d5      	 rcall isr ; 2-wire Serial Interface
                 .org 80
000050 d0d3      	 rcall isr ; Store Program Memory Read
                 .org 82
000052 d0d1      	 rcall isr ; Timer/Counter4 Capture Event
                 .org 84
000054 d0cf      	 rcall isr ; Timer/Counter4 Compare Match A
                 .org 86
000056 d0cd      	 rcall isr ; Timer/Counter4 Compare Match B
                 .org 88
000058 d0cb      	 rcall isr ; Timer/Counter4 Compare Match C
                 .org 90
00005a d0c9      	 rcall isr ; Timer/Counter4 Overflow
                 .org 92
00005c d0c7      	 rcall isr ; Timer/Counter5 Capture Event
                 .org 94
00005e d0c5      	 rcall isr ; Timer/Counter5 Compare Match A
                 .org 96
000060 d0c3      	 rcall isr ; Timer/Counter5 Compare Match B
                 .org 98
000062 d0c1      	 rcall isr ; Timer/Counter5 Compare Match C
                 .org 100
000064 d0bf      	 rcall isr ; Timer/Counter5 Overflow
                 .org 102
000066 d0bd      	 rcall isr ; USART2, Rx Complete
                 .org 104
000068 d0bb      	 rcall isr ; USART2 Data register Empty
                 .org 106
00006a d0b9      	 rcall isr ; USART2, Tx Complete
                 .org 108
00006c d0b7      	 rcall isr ; USART3, Rx Complete
                 .org 110
00006e d0b5      	 rcall isr ; USART3 Data register Empty
                 .org 112
000070 d0b3      	 rcall isr ; USART3, Tx Complete
                 .equ INTVECTORS = 57
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000071 2000      	.dw 8192
                 mcu_eepromsize:
000072 1000      	.dw 4096
                 mcu_maxdp:
000073 ffff      	.dw 65535 
                 mcu_numints:
000074 0039      	.dw 57
                 mcu_name:
000075 000a      	.dw 10
000076 5441
000077 656d
000078 6167
000079 3532
00007a 3136      	.db "ATmega2561"
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; receiving is asynchron, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 14745600
                 .include "drivers/usart_1.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR1H
                   .equ USART_C = UCSR1C
                   .equ USART_B = UCSR1B
                   .equ USART_A = UCSR1A
                   .equ USART_DATA = UDR1
                 
                 .equ URXCaddr = URXC1addr
                 .equ UDREaddr = UDRE1addr
                 
                 .equ bm_USART_RXRD = 1 << RXC1
                 .equ bm_USART_TXRD = 1 << UDRE1
                 .equ bm_ENABLE_TX  = 1 << TXEN1
                 .equ bm_ENABLE_RX  = 1 << RXEN1
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE1
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE1
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-isr-rx.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000200           usart_rx_data: .byte usart_rx_size+2
000212           usart_rx_in: .byte 2
000214           usart_rx_out: .byte 2
                 
                 .cseg
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; forth code:
                 ; : rx-isr USART_DATA c@
                 ;    usart_rx_data usart_rx_in c@ dup >r
                 ;    + !
                 ;    r> 1+ usart_rx_mask and usart_rx_in c!
                 ; ;
                 ; setup with
                 ; ' rx-isr URXCaddr int!
                 usart_rx_isr:
00007b 93af        push xl
00007c b7af        in xl, SREG
00007d 93af        push xl
00007e 93bf        push xh
00007f 93ef        push zl
000080 93ff        push zh
                 
000081 91b0 00ce   lds xh, USART_DATA
                 usart_rx_store:
000083 91a0 0212   lds xl, usart_rx_in
000085 e0e0        ldi zl, low(usart_rx_data)
000086 e0f2        ldi zh, high(usart_rx_data)
000087 0fea        add zl, xl
000088 1df3        adc zh, zeroh
000089 83b0        st Z, xh
                 
00008a 95a3        inc xl
00008b 70af        andi xl,usart_rx_mask
                 
00008c 93a0 0212   sts usart_rx_in, xl
                 
                 usart_rx_isr_finish:
00008e 91ff        pop zh
00008f 91ef        pop zl
000090 91bf        pop xh
000091 91af        pop xl
000092 bfaf        out SREG, xl
000093 91af        pop xl
000094 9518        reti
                 
                 .set usartpc = pc
                 .org URXCaddr
000048 c032        jmp_ usart_rx_isr
                 .org usartpc
                 
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RX:
                 ;  .dw $ff06
                 ;  .db "+usart"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RX
                 XT_USART_INIT_RX_ISR:
000095 0108        .dw DO_COLON
                 PFA_USART_INIT_RX_ISR:          ; ( -- )
000096 05bc        .dw XT_ZERO
000097 049d        .dw XT_DOLITERAL
000098 0212        .dw usart_rx_in
000099 04f5        .dw XT_CSTORE
00009a 05bc        .dw XT_ZERO
00009b 049d        .dw XT_DOLITERAL
00009c 0214        .dw usart_rx_out
00009d 04f5        .dw XT_CSTORE
                 
00009e 047d        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_ISR:
00009f ff06          .dw $ff06
0000a0 7872
0000a1 692d
0000a2 7273          .db "rx-isr"
0000a3 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_ISR
                 XT_RX_ISR:
0000a4 0108          .dw DO_COLON
                 PFA_RX_ISR:
0000a5 00be        .dw XT_RXQ_ISR
0000a6 0496        .dw XT_DOCONDBRANCH
0000a7 00a5        .dw PFA_RX_ISR
0000a8 049d        .dw XT_DOLITERAL
0000a9 0214        .dw usart_rx_out
0000aa 0500        .dw XT_CFETCH
0000ab 0519        .dw XT_DUP
0000ac 0697        .dw XT_1PLUS
0000ad 049d        .dw XT_DOLITERAL
0000ae 000f        .dw usart_rx_mask
0000af 067b        .dw XT_AND
0000b0 049d        .dw XT_DOLITERAL
0000b1 0214        .dw usart_rx_out
0000b2 04f5        .dw XT_CSTORE
0000b3 049d        .dw XT_DOLITERAL
0000b4 0200        .dw usart_rx_data
0000b5 0605        .dw XT_PLUS
0000b6 0500        .dw XT_CFETCH
0000b7 047d        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue using interrupt driver
                 VE_RXQ_ISR:
0000b8 ff07          .dw $ff07
0000b9 7872
0000ba 2d3f
0000bb 7369
0000bc 0072          .db "rx?-isr",0
0000bd 009f          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_ISR
                 XT_RXQ_ISR:
0000be 0108          .dw DO_COLON
                 PFA_RXQ_ISR:
0000bf 0e6f        .dw XT_PAUSE
0000c0 049d        .dw XT_DOLITERAL
0000c1 0214        .dw usart_rx_out
0000c2 0500        .dw XT_CFETCH
0000c3 049d        .dw XT_DOLITERAL
0000c4 0212        .dw usart_rx_in
0000c5 0500        .dw XT_CFETCH
0000c6 057b        .dw XT_NOTEQUAL
0000c7 047d        .dw XT_EXIT
                   .set XT_RX  = XT_RX_ISR
                   .set XT_RXQ = XT_RXQ_ISR
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_ISR
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000c8 ff07          .dw $ff07
0000c9 7874
0000ca 702d
0000cb 6c6f
0000cc 006c          .db "tx-poll",0
0000cd 00b8          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000ce 0108          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000cf 00dc        .dw XT_TXQ_POLL
0000d0 0496        .dw XT_DOCONDBRANCH
0000d1 00cf        .dw PFA_TX_POLL
                   ; send to usart
0000d2 049d        .dw XT_DOLITERAL
0000d3 00ce        .dw USART_DATA
0000d4 04f5        .dw XT_CSTORE
0000d5 047d        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000d6 ff08          .dw $ff08
0000d7 7874
0000d8 2d3f
0000d9 6f70
0000da 6c6c          .db "tx?-poll"
0000db 00c8          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000dc 0108          .dw DO_COLON
                 PFA_TXQ_POLL:
0000dd 0e6f        .dw XT_PAUSE
0000de 049d        .dw XT_DOLITERAL
0000df 00c8        .dw USART_A
0000e0 0500        .dw XT_CFETCH
0000e1 049d        .dw XT_DOLITERAL
0000e2 0020        .dw bm_USART_TXRD
0000e3 067b        .dw XT_AND
0000e4 047d        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000e5 ff04        .dw $ff04
0000e6 6275
0000e7 7272        .db "ubrr"
0000e8 00d6        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000e9 04d8        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000ea 00c2        .dw EE_UBRRVAL
0000eb 0fc3        .dw XT_EDEFERFETCH
0000ec 0fcd        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000ed ff06        .dw $ff06
0000ee 752b
0000ef 6173
0000f0 7472        .db "+usart"
0000f1 00e5        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000f2 0108        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000f3 049d        .dw XT_DOLITERAL
0000f4 0098        .dw USART_B_VALUE
0000f5 049d        .dw XT_DOLITERAL
0000f6 00c9        .dw USART_B
0000f7 04f5        .dw XT_CSTORE
                 
0000f8 049d        .dw XT_DOLITERAL
0000f9 0006        .dw USART_C_VALUE
0000fa 049d        .dw XT_DOLITERAL
0000fb 00ca        .dw USART_C | bm_USARTC_en
0000fc 04f5        .dw XT_CSTORE
                 
0000fd 00e9        .dw XT_UBRR
0000fe 0519        .dw XT_DUP
0000ff 0755        .dw XT_BYTESWAP
000100 049d        .dw XT_DOLITERAL
000101 00cd        .dw BAUDRATE_HIGH
000102 04f5        .dw XT_CSTORE
000103 049d        .dw XT_DOLITERAL
000104 00cc        .dw BAUDRATE_LOW
000105 04f5        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
000106 0095        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
000107 047d        .dw XT_EXIT
                 
                 ; all of amforth is in one segment
                 .include "amforth-low.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 
                 .org $0000
000000 940c 0e78   jmp_ PFA_COLD
                 .org pc_
                 
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
000108 93bf          push XH
000109 93af          push XL          ; PUSH IP
00010a 01db          movw XL, wl
00010b 9611          adiw xl, 1
                 DO_NEXT:
00010c f09e          brts DO_INTERRUPT
00010d 01fd          movw zl, XL        ; READ IP
00010e 2755
00010f 0fee
000110 1fff
000111 1f55
000112 bf5b
000113 9167
000114 9177          readflashcell wl, wh
000115 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
000116 01fb          movw zl, wl
000117 2755
000118 0fee
000119 1fff
00011a 1f55
00011b bf5b
00011c 9107
00011d 9117          readflashcell temp0,temp1
00011e 01f8          movw zl, temp0
00011f 9409          ijmp
                 
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
000120 94e8          clt
000121 ed63          ldi wl, LOW(XT_ISREXEC)
000122 e078          ldi wh, HIGH(XT_ISREXEC)
000123 cff2          rjmp DO_EXECUTE
                 .include "drivers/generic-isr.asm"
                 
                 .dseg
000216           intcur: .byte 1
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
000124 920a          st -Y, r0
000125 b60f          in r0, SREG
000126 920a          st -Y, r0
                 .if (pclen==3)
000127 900f          pop r0 ; some 128+K Flash devices use 3 cells for call/ret
                 .endif
000128 900f          pop r0
000129 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
00012a 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
00012b 9200 0216     sts intcur, r0
00012d 9009          ld r0, Y+
00012e be0f          out SREG, r0
00012f 9009          ld r0, Y+
000130 9468          set ; set the interrupt flag for the inner interpreter
000131 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000132 ff02          .dw $ff02
000133 2b6d          .db "m+"
000134 00ed          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
000135 0108          .dw DO_COLON
                 PFA_MPLUS:
000136 11fe          .dw XT_S2D
000137 083c          .dw XT_DPLUS
000138 047d          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
000139 ff03          .dw $ff03
00013a 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
00013b 002a          .db "ud*"
00013c 0132          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
00013d 0108          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
00013e 0519
00013f 0567
000140 0648
000141 0541              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000142 052c
000143 055e
000144 0648
000145 0549
000146 0605
000147 047d              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
000148 ff04          .dw $ff04
000149 6d75
00014a 7861          .db "umax"
00014b 0139          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
00014c 0108          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
00014d 099d
00014e 05c4              .DW XT_2DUP,XT_ULESS
00014f 0496      	.dw XT_DOCONDBRANCH
000150 0152      	 DEST(UMAX1)
000151 052c              .DW XT_SWAP
000152 0541      UMAX1:  .DW XT_DROP
000153 047d      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
000154 ff04          .dw $ff04
000155 6d75
000156 6e69          .db "umin"
000157 0148          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
000158 0108          .dw DO_COLON
                 PFA_UMIN:
                 .endif
000159 099d
00015a 05cf              .DW XT_2DUP,XT_UGREATER
00015b 0496      	.dw XT_DOCONDBRANCH
00015c 015e      	DEST(UMIN1)
00015d 052c              .DW XT_SWAP
00015e 0541      UMIN1:  .DW XT_DROP
00015f 047d      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000160 0108          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000161 049d          .dw XT_DOLITERAL
000162 8000          .dw $8000
000163 067b          .dw XT_AND
000164 0582          .dw XT_ZEROEQUAL
000165 0496          .dw XT_DOCONDBRANCH
000166 016a          DEST(IMMEDIATEQ1)
000167 049d           .dw XT_DOLITERAL
000168 0001           .dw 1
000169 047d           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
00016a 05b3          .dw XT_TRUE
00016b 047d          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
00016c ff0a          .dw $ff0a
00016d 616e
00016e 656d
00016f 663e
000170 616c
000171 7367          .db "name>flags"
000172 0154          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000173 0108          .dw DO_COLON
                 PFA_NAME2FLAGS:
000174 07ef          .dw XT_FETCHI ; skip to link field
000175 049d          .dw XT_DOLITERAL
000176 ff00          .dw $ff00
000177 067b          .dw XT_AND
000178 047d          .dw XT_EXIT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .include "dict/appl_8k.inc"
                 
                 
                 .include "words/newest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_NEWEST:
000179 ff06          .dw $ff06
00017a 656e
00017b 6577
00017c 7473          .db "newest"
00017d 016c          .dw VE_HEAD
                     .set VE_HEAD = VE_NEWEST
                 XT_NEWEST:
00017e 04ab          .dw PFA_DOVARIABLE
                 PFA_NEWEST:
00017f 0217          .dw ram_newest
                 
                 .dseg
000217           ram_newest: .byte 4
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_LATEST:
000180 ff06          .dw $ff06
000181 616c
000182 6574
000183 7473          .db "latest"
000184 0179          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000185 04ab          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000186 021b          .dw ram_latest
                 
                 .dseg
00021b           ram_latest: .byte 2
                 .include "words/do-create.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE:
000187 ff08          .dw $ff08
000188 6328
000189 6572
00018a 7461
00018b 2965          .db "(create)"
00018c 0180          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
00018d 0108          .dw DO_COLON
                 PFA_DOCREATE:
                 .endif
00018e 0dea
00018f 02e4          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
000190 0519
000191 017e
000192 0995
000193 04e9          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
000194 02c9
000195 017e
000196 04e9          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
000197 047d          .DW XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
000198 0001          .dw $0001
000199 005c          .db $5c,0
00019a 0187          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
00019b 0108          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
00019c 0dd1          .dw XT_SOURCE
00019d 0558          .dw XT_NIP
00019e 09b6          .dw XT_TO_IN
00019f 04e9          .dw XT_STORE
0001a0 047d          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
0001a1 0001          .dw $0001
0001a2 0028          .db "(" ,0
0001a3 0198          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
0001a4 0108          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
0001a5 049d          .dw XT_DOLITERAL
0001a6 0029          .dw ')'
0001a7 0dbd          .dw XT_PARSE
0001a8 09a6          .dw XT_2DROP
0001a9 047d          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
0001aa ff07          .dw $ff07
0001ab 6f63
0001ac 706d
0001ad 6c69
0001ae 0065          .db "compile",0
0001af 01a1          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001b0 0108          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
0001b1 055e          .dw XT_R_FROM
0001b2 0519          .dw XT_DUP
0001b3 0fba          .dw XT_ICELLPLUS
0001b4 0567          .dw XT_TO_R
0001b5 07ef          .dw XT_FETCHI
0001b6 01bb          .dw XT_COMMA
0001b7 047d          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001b8 ff01          .dw $ff01
0001b9 002c          .db ',',0 ; ,
0001ba 01aa          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001bb 0108          .dw DO_COLON
                 PFA_COMMA:
0001bc 09e6          .dw XT_DP
0001bd 07d0          .dw XT_STOREI
0001be 09e6          .dw XT_DP
0001bf 0697          .dw XT_1PLUS
0001c0 0fa8          .dw XT_DOTO
0001c1 09e7          .dw PFA_DP
0001c2 047d          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
0001c3 0003          .dw $0003
0001c4 275b
0001c5 005d          .db "[']",0
0001c6 01b8          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001c7 0108          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
0001c8 0c47          .dw XT_TICK
0001c9 01d1          .dw XT_LITERAL
0001ca 047d          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
0001cb 0007          .dw $0007
0001cc 696c
0001cd 6574
0001ce 6172
0001cf 006c          .db "literal",0
0001d0 01c3          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
0001d1 0108          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
0001d2 01b0              .DW XT_COMPILE
0001d3 049d              .DW XT_DOLITERAL
0001d4 01bb              .DW XT_COMMA
0001d5 047d              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
0001d6 0008        .dw $0008
0001d7 6c73
0001d8 7469
0001d9 7265
0001da 6c61        .db "sliteral"
0001db 01cb        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
0001dc 0108          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
0001dd 01b0          .dw XT_COMPILE
0001de 0baa          .dw XT_DOSLITERAL    ; ( -- addr n)
0001df 0bb8          .dw XT_SCOMMA
0001e0 047d          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
0001e1 0108          .dw DO_COLON
                 PFA_GMARK:
0001e2 09e6          .dw XT_DP
0001e3 01b0          .dw XT_COMPILE
0001e4 ffff          .dw -1           ; ffff does not erase flash
0001e5 047d          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
0001e6 0108          .dw DO_COLON
                 PFA_GRESOLVE:
0001e7 0f66          .dw XT_QSTACK
0001e8 09e6          .dw XT_DP
0001e9 052c          .dw XT_SWAP
0001ea 07d0          .dw XT_STOREI
0001eb 047d          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
0001ec 0108          .dw DO_COLON
                 PFA_LMARK:
0001ed 09e6          .dw XT_DP
0001ee 047d          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
0001ef 0108          .dw DO_COLON
                 PFA_LRESOLVE:
0001f0 0f66          .dw XT_QSTACK
0001f1 01bb          .dw XT_COMMA
0001f2 047d          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
0001f3 0005          .dw $0005
0001f4 6861
0001f5 6165
0001f6 0064          .db "ahead",0
0001f7 01d6          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
0001f8 0108          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
0001f9 01b0          .dw XT_COMPILE
0001fa 048c          .dw XT_DOBRANCH
0001fb 01e1          .dw XT_GMARK
0001fc 047d          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
0001fd 0002          .dw $0002
0001fe 6669          .db "if"
0001ff 01f3          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000200 0108          .dw DO_COLON
                 PFA_IF:
                 .endif
000201 01b0          .dw XT_COMPILE
000202 0496          .dw XT_DOCONDBRANCH
000203 01e1          .dw XT_GMARK
000204 047d          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
000205 0004          .dw $0004
000206 6c65
000207 6573          .db "else"
000208 01fd          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000209 0108          .dw DO_COLON
                 PFA_ELSE:
                 .endif
00020a 01b0          .dw XT_COMPILE
00020b 048c          .dw XT_DOBRANCH
00020c 01e1          .dw XT_GMARK
00020d 052c          .dw XT_SWAP
00020e 01e6          .dw XT_GRESOLVE
00020f 047d          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
000210 0004          .dw $0004
000211 6874
000212 6e65          .db "then"
000213 0205          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000214 0108          .dw DO_COLON
                 PFA_THEN:
                 .endif
000215 01e6          .dw XT_GRESOLVE
000216 047d          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
000217 0005          .dw $0005
000218 6562
000219 6967
00021a 006e          .db "begin",0
00021b 0210          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
00021c 0108          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
00021d 01ec          .dw XT_LMARK
00021e 047d          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
00021f 0005          .dw $0005
000220 6877
000221 6c69
000222 0065          .db "while",0
000223 0217          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000224 0108          .dw DO_COLON
                 PFA_WHILE:
                 .endif
000225 0200          .dw XT_IF
000226 052c          .dw XT_SWAP
000227 047d          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
000228 0006          .dw $0006
000229 6572
00022a 6570
00022b 7461          .db "repeat"
00022c 021f          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
00022d 0108          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
00022e 0241          .dw XT_AGAIN
00022f 0214          .dw XT_THEN
000230 047d          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
000231 0005          .dw $0005
000232 6e75
000233 6974
000234 006c          .db "until",0
000235 0228          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000236 0108          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
000237 049d          .dw XT_DOLITERAL
000238 0496          .dw XT_DOCONDBRANCH
000239 01bb          .dw XT_COMMA
                 
00023a 01ef          .dw XT_LRESOLVE
00023b 047d          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
00023c 0005          .dw $0005
00023d 6761
00023e 6961
00023f 006e          .db "again",0
000240 0231          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000241 0108          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
000242 01b0          .dw XT_COMPILE
000243 048c          .dw XT_DOBRANCH
000244 01ef          .dw XT_LRESOLVE
000245 047d          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
000246 0002          .dw $0002
000247 6f64          .db "do"
000248 023c          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000249 0108          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
00024a 01b0          .dw XT_COMPILE
00024b 06f7          .dw XT_DODO
00024c 01ec          .dw XT_LMARK
00024d 05bc          .dw XT_ZERO
00024e 02a4          .dw XT_TO_L
00024f 047d          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
000250 0004          .dw $0004
000251 6f6c
000252 706f          .db "loop"
000253 0246          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
000254 0108          .dw DO_COLON
                 PFA_LOOP:
                 .endif
000255 01b0          .dw XT_COMPILE
000256 0725          .dw XT_DOLOOP
000257 028b          .dw XT_ENDLOOP
000258 047d          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000259 0005          .dw $0005
00025a 6c2b
00025b 6f6f
00025c 0070          .db "+loop",0
00025d 0250          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
00025e 0108          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
00025f 01b0          .dw XT_COMPILE
000260 0716          .dw XT_DOPLUSLOOP
000261 028b          .dw XT_ENDLOOP
000262 047d          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
000263 0005         .dw $0005
000264 656c
000265 7661
000266 0065         .db "leave",0
000267 0259         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000268 0108          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
000269 01b0
00026a 0730          .DW XT_COMPILE,XT_UNLOOP
00026b 01f8
00026c 02a4
00026d 047d          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
00026e 0003          .dw $0003
00026f 643f
000270 006f          .db "?do",0
000271 0263          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
000272 0108          .dw DO_COLON
                 PFA_QDO:
                 .endif
000273 01b0          .dw XT_COMPILE
000274 027a          .dw XT_QDOCHECK
000275 0200          .dw XT_IF
000276 0249          .dw XT_DO
000277 052c          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
000278 02a4          .dw XT_TO_L    ; then follows at the end.
000279 047d          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
00027a 0108          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
00027b 099d          .dw XT_2DUP
00027c 1216          .dw XT_EQUAL
00027d 0519          .dw XT_DUP
00027e 0567          .dw XT_TO_R
00027f 0496          .dw XT_DOCONDBRANCH
000280 0282          DEST(PFA_QDOCHECK1)
000281 09a6          .dw XT_2DROP
                 PFA_QDOCHECK1:
000282 055e          .dw XT_R_FROM
000283 0665          .dw XT_INVERT
000284 047d          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
000285 ff07          .dw $ff07
000286 6e65
000287 6c64
000288 6f6f
000289 0070          .db "endloop",0
00028a 026e          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
00028b 0108          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
00028c 01ef              .DW XT_LRESOLVE
00028d 0298
00028e 0521
00028f 0496      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
000290 0294               DEST(LOOP2)
000291 0214              .DW XT_THEN
000292 048c      	.dw XT_DOBRANCH
000293 028d               DEST(LOOP1)
000294 047d      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
000295 ff02          .dw $ff02
000296 3e6c          .db "l>"
000297 0285          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
000298 0108          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
000299 02b7          .dw XT_LP
00029a 04e1          .dw XT_FETCH
00029b 04e1          .dw XT_FETCH
00029c 049d          .dw XT_DOLITERAL
00029d fffe          .dw -2
00029e 02b7          .dw XT_LP
00029f 06c1          .dw XT_PLUSSTORE
0002a0 047d          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
0002a1 ff02          .dw $ff02
0002a2 6c3e          .db ">l"
0002a3 0295          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
0002a4 0108          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
0002a5 1222              .dw XT_TWO
0002a6 02b7      	.dw XT_LP
0002a7 06c1      	.dw XT_PLUSSTORE
0002a8 02b7      	.dw XT_LP
0002a9 04e1      	.dw XT_FETCH
0002aa 04e9      	.dw XT_STORE
0002ab 047d      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
0002ac ff03          .dw $ff03
0002ad 706c
0002ae 0030          .db "lp0",0
0002af 02a1          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
0002b0 04d8          .dw PFA_DOVALUE1
                 PFA_LP0:
0002b1 007c          .dw CFG_LP0
0002b2 0fc3          .dw XT_EDEFERFETCH
0002b3 0fcd          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
0002b4 ff02          .dw $ff02
0002b5 706c          .db "lp"
0002b6 02ac          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
0002b7 04ab          .dw PFA_DOVARIABLE
                 PFA_LP:
0002b8 021d          .dw ram_lp
                 
                 .dseg
00021d           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CREATE:
0002b9 ff06          .dw $ff06
0002ba 7263
0002bb 6165
0002bc 6574          .db "create"
0002bd 02b4          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0002be 0108          .dw DO_COLON
                 PFA_CREATE:
                 .endif
0002bf 018d          .dw XT_DOCREATE
0002c0 02ed          .dw XT_REVEAL
0002c1 01b0          .dw XT_COMPILE
0002c2 04b8          .dw PFA_DOCONSTANT
0002c3 047d          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0002c4 ff06          .dw $ff06
0002c5 6568
0002c6 6461
0002c7 7265          .db "header"
0002c8 02b9          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0002c9 0108          .dw DO_COLON
                 PFA_HEADER:
0002ca 09e6          .dw XT_DP           ; the new Name Field
0002cb 0567          .dw XT_TO_R
0002cc 0567          .dw XT_TO_R		; ( R: NFA WID )
0002cd 0519          .dw XT_DUP    
0002ce 0590          .dw XT_GREATERZERO 
0002cf 0496          .dw XT_DOCONDBRANCH
0002d0 02db          .dw PFA_HEADER1
0002d1 0519          .dw XT_DUP
0002d2 049d          .dw XT_DOLITERAL
0002d3 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0002d4 0684          .dw XT_OR
0002d5 0bbc          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0002d6 055e          .dw XT_R_FROM
0002d7 07bc          .dw XT_FETCHE
0002d8 01bb          .dw XT_COMMA
0002d9 055e          .dw XT_R_FROM
0002da 047d          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0002db 049d          .dw XT_DOLITERAL
0002dc fff0          .dw -16
0002dd 0c76          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0002de ff07          .dw $ff07
0002df 6c77
0002e0 6373
0002e1 706f
0002e2 0065          .db "wlscope",0
0002e3 02c4          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0002e4 1022          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
0002e5 007a          .dw CFG_WLSCOPE
0002e6 0fc3          .dw XT_EDEFERFETCH
0002e7 0fcd          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REVEAL:
0002e8 ff06          .dw $ff06
0002e9 6572
0002ea 6576
0002eb 6c61          .db "reveal"
0002ec 02de          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
0002ed 0108          .dw DO_COLON
                 PFA_REVEAL:
                 .endif
0002ee 017e
0002ef 0995
0002f0 04e1          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
0002f1 0521
0002f2 0496          .DW XT_QDUP,XT_DOCONDBRANCH
0002f3 02f8          DEST(REVEAL1)
0002f4 017e
0002f5 04e1
0002f6 052c
0002f7 0798          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                 REVEAL1:
0002f8 047d          .DW XT_EXIT
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
0002f9 0005          .dw $0005
0002fa 6f64
0002fb 7365
0002fc 003e          .db "does>",0
0002fd 02e8          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
0002fe 0108          .dw DO_COLON
                 PFA_DOES:
0002ff 01b0          .dw XT_COMPILE
000300 0311          .dw XT_DODOES
000301 01b0          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
000302 940e          .dw $940e       ; the address of this compiled
000303 01b0          .dw XT_COMPILE  ; code will replace the XT of the 
000304 0306          .dw DO_DODOES   ; word that CREATE created
000305 047d          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000306 939a
000307 938a          savetos
000308 01cb          movw tosl, wl
000309 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
00030a 917f          pop wh ; some 128K Flash devices use 3 cells for call/ret
                 .endif
00030b 917f          pop wh
00030c 916f          pop wl
                 
00030d 93bf          push XH
00030e 93af          push XL
00030f 01db          movw XL, wl
000310 cdfb          jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000311 0108          .dw DO_COLON
                 PFA_DODOES:
000312 055e          .dw XT_R_FROM
000313 017e          .dw XT_NEWEST
000314 0995          .dw XT_CELLPLUS
000315 04e1          .dw XT_FETCH
000316 07bc          .dw XT_FETCHE
000317 108d          .dw XT_NFA2CFA
000318 07d0          .dw XT_STOREI
000319 047d          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
00031a ff01          .dw $ff01
00031b 003a          .db ":",0
00031c 02f9          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
00031d 0108          .dw DO_COLON
                 PFA_COLON:
                 .endif
00031e 018d          .dw XT_DOCREATE
00031f 0328          .dw XT_COLONNONAME
000320 0541          .dw XT_DROP
000321 047d          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000322 ff07          .dw $ff07
000323 6e3a
000324 6e6f
000325 6d61
000326 0065          .db ":noname",0
000327 031a          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000328 0108          .dw DO_COLON
                 PFA_COLONNONAME:
000329 09e6          .dw XT_DP
00032a 0519          .dw XT_DUP
00032b 0185          .dw XT_LATEST
00032c 04e9          .dw XT_STORE
                 
00032d 01b0          .dw XT_COMPILE
00032e 0108          .dw DO_COLON
                 
00032f 033d          .dw XT_RBRACKET
000330 047d          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
000331 0001          .dw $0001
000332 003b          .db $3b,0
000333 0322          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000334 0108          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
000335 01b0          .dw XT_COMPILE
000336 047d          .dw XT_EXIT
000337 0345          .dw XT_LBRACKET
000338 02ed          .dw XT_REVEAL
000339 047d          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
00033a ff01          .dw $ff01
00033b 005d          .db "]",0
00033c 0331          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
00033d 0108          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
00033e 121d          .dw XT_ONE
00033f 0982          .dw XT_STATE
000340 04e9          .dw XT_STORE
000341 047d          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
000342 0001          .dw $0001
000343 005b          .db "[",0
000344 033a          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000345 0108          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
000346 05bc          .dw XT_ZERO
000347 0982          .dw XT_STATE
000348 04e9          .dw XT_STORE
000349 047d          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
00034a ff08          .dw $ff08
00034b 6176
00034c 6972
00034d 6261
00034e 656c          .db "variable"
00034f 0342          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000350 0108          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
000351 09f7          .dw XT_HERE
000352 035c          .dw XT_CONSTANT
000353 1222          .dw XT_TWO
000354 0a00          .dw XT_ALLOT
000355 047d          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
000356 ff08          .dw $ff08
000357 6f63
000358 736e
000359 6174
00035a 746e          .db "constant"
00035b 034a          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
00035c 0108          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
00035d 018d          .dw XT_DOCREATE
00035e 02ed          .dw XT_REVEAL
00035f 01b0          .dw XT_COMPILE
000360 04ab          .dw PFA_DOVARIABLE
000361 01bb          .dw XT_COMMA
000362 047d          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000363 ff04          .dw $ff04
000364 7375
000365 7265          .db "user"
000366 0356          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000367 0108          .dw DO_COLON
                 PFA_USER:
000368 018d          .dw XT_DOCREATE
000369 02ed          .dw XT_REVEAL
                 
00036a 01b0          .dw XT_COMPILE
00036b 04be          .dw PFA_DOUSER
00036c 01bb          .dw XT_COMMA
00036d 047d          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECURSE:
00036e 0007          .dw $0007
00036f 6572
000370 7563
000371 7372
000372 0065          .db "recurse",0
000373 0363          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000374 0108          .dw DO_COLON
                 PFA_RECURSE:
                 .endif
000375 0185          .dw XT_LATEST
000376 04e1          .dw XT_FETCH
000377 01bb          .dw XT_COMMA
000378 047d          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000379 ff09          .dw $ff09
00037a 6d69
00037b 656d
00037c 6964
00037d 7461
00037e 0065          .db "immediate",0
00037f 036e          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000380 0108          .dw DO_COLON
                 PFA_IMMEDIATE:
000381 041b          .dw XT_GET_CURRENT
000382 07bc          .dw XT_FETCHE
000383 0519          .dw XT_DUP
000384 07ef          .dw XT_FETCHI
000385 049d          .dw XT_DOLITERAL
000386 7fff          .dw $7fff
000387 067b          .dw XT_AND
000388 052c          .dw XT_SWAP
000389 07d0          .dw XT_STOREI
00038a 047d          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
00038b 0006          .dw $0006
00038c 635b
00038d 6168
00038e 5d72          .db "[char]"
00038f 0379          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000390 0108          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
000391 01b0          .dw XT_COMPILE
000392 049d          .dw XT_DOLITERAL
000393 0d1f          .dw XT_CHAR
000394 01bb          .dw XT_COMMA
000395 047d          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
000396 0006          .dw $0006
000397 6261
000398 726f
000399 2274          .db "abort",'"'
00039a 038b          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
00039b 0108          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
00039c 08f8          .dw XT_SQUOTE
00039d 01b0          .dw XT_COMPILE
00039e 03ad          .dw XT_QABORT
00039f 047d          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
0003a0 ff05          .dw $ff05
0003a1 6261
0003a2 726f
0003a3 0074          .db "abort",0
0003a4 0396          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
0003a5 0108          .dw DO_COLON
                 PFA_ABORT:
                 .endif
0003a6 05b3          .dw XT_TRUE
0003a7 0c76          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
0003a8 ff06          .dw $ff06
0003a9 613f
0003aa 6f62
0003ab 7472          .db "?abort"
0003ac 03a0          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
0003ad 0108          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
0003ae 0549
0003af 0496              .DW XT_ROT,XT_DOCONDBRANCH
0003b0 03b3              DEST(QABO1)
0003b1 0bdd
0003b2 03a5              .DW XT_ITYPE,XT_ABORT
0003b3 09a6
0003b4 047d      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
0003b5 ff09          .dw $ff09
0003b6 6567
0003b7 2d74
0003b8 7473
0003b9 6361
0003ba 006b          .db "get-stack",0
0003bb 03a8          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
0003bc 0108          .dw DO_COLON
                 .endif
0003bd 0519          .dw XT_DUP
0003be 0995          .dw XT_CELLPLUS
0003bf 052c          .dw XT_SWAP
0003c0 07bc          .dw XT_FETCHE
0003c1 0519          .dw XT_DUP
0003c2 0567          .dw XT_TO_R
0003c3 05bc          .dw XT_ZERO
0003c4 052c          .dw XT_SWAP    ; go from bigger to smaller addresses
0003c5 027a          .dw XT_QDOCHECK
0003c6 0496          .dw XT_DOCONDBRANCH
0003c7 03d3          DEST(PFA_N_FETCH_E2)
0003c8 06f7          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
0003c9 0708          .dw XT_I
0003ca 069d          .dw XT_1MINUS
0003cb 098f          .dw XT_CELLS ; ( -- ee-addr i*2 )
0003cc 0537          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
0003cd 0605          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
0003ce 07bc          .dw XT_FETCHE ;( -- ee-addr item_i )
0003cf 052c          .dw XT_SWAP   ;( -- item_i ee-addr )
0003d0 05b3          .dw XT_TRUE  ; shortcut for -1
0003d1 0716          .dw XT_DOPLUSLOOP
0003d2 03c9          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
0003d3 09a6          .dw XT_2DROP
0003d4 055e          .dw XT_R_FROM
0003d5 047d          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
0003d6 ff09          .dw $ff09
0003d7 6573
0003d8 2d74
0003d9 7473
0003da 6361
0003db 006b          .db "set-stack",0
0003dc 03b5          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
0003dd 0108          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
0003de 099d          .dw XT_2DUP
0003df 0798          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
0003e0 052c          .dw XT_SWAP    
0003e1 05bc          .dw XT_ZERO
0003e2 027a          .dw XT_QDOCHECK
0003e3 0496          .dw XT_DOCONDBRANCH
0003e4 03eb          DEST(PFA_SET_STACK2)
0003e5 06f7          .dw XT_DODO
                 PFA_SET_STACK1:
0003e6 0995          .dw XT_CELLPLUS ; ( -- i_x e-addr )
0003e7 09ae          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
0003e8 0798          .dw XT_STOREE
0003e9 0725          .dw XT_DOLOOP
0003ea 03e6          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
0003eb 0541          .dw XT_DROP
0003ec 047d          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
0003ed ff09          .dw $ff09
0003ee 616d
0003ef 2d70
0003f0 7473
0003f1 6361
0003f2 006b          .db "map-stack",0
0003f3 03d6          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
0003f4 0108          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
0003f5 0519          .dw XT_DUP
0003f6 0995          .dw XT_CELLPLUS
0003f7 052c          .dw XT_SWAP
0003f8 07bc          .dw XT_FETCHE
0003f9 098f          .dw XT_CELLS
0003fa 11f5          .dw XT_BOUNDS
0003fb 027a          .dw XT_QDOCHECK
0003fc 0496          .dw XT_DOCONDBRANCH
0003fd 0410          DEST(PFA_MAPSTACK3)
0003fe 06f7          .dw XT_DODO
                 PFA_MAPSTACK1:
0003ff 0708            .dw XT_I
000400 07bc            .dw XT_FETCHE   ; -- i*x XT id
000401 052c            .dw XT_SWAP
000402 0567            .dw XT_TO_R
000403 0570            .dw XT_R_FETCH
000404 0487            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
000405 0521            .dw XT_QDUP
000406 0496            .dw XT_DOCONDBRANCH
000407 040c            DEST(PFA_MAPSTACK2)
000408 055e               .dw XT_R_FROM
000409 0541               .dw XT_DROP
00040a 0730               .dw XT_UNLOOP
00040b 047d               .dw XT_EXIT
                 PFA_MAPSTACK2:
00040c 055e            .dw XT_R_FROM
00040d 1222            .dw XT_TWO
00040e 0716            .dw XT_DOPLUSLOOP
00040f 03ff            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
000410 0541          .dw XT_DROP
000411 05bc          .dw XT_ZERO
000412 047d          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000413 ff0b          .dw $ff0b
000414 6567
000415 2d74
000416 7563
000417 7272
000418 6e65
000419 0074          .db "get-current",0
00041a 03ed          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
00041b 0108          .dw DO_COLON
                 PFA_GET_CURRENT:
00041c 049d          .dw XT_DOLITERAL
00041d 0082          .dw CFG_CURRENT
00041e 07bc          .dw XT_FETCHE
00041f 047d          .dw XT_EXIT
                 .include "words/get-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_ORDER:
000420 ff09          .dw $ff09
000421 6567
000422 2d74
000423 726f
000424 6564
000425 0072          .db "get-order",0
000426 0413          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_ORDER
                 XT_GET_ORDER:
000427 0108          .dw DO_COLON
                 PFA_GET_ORDER:
                 .endif
000428 049d          .dw XT_DOLITERAL
000429 0086          .dw CFG_ORDERLISTLEN
00042a 03bc          .dw XT_GET_STACK
00042b 047d          .dw XT_EXIT
                 
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
00042c ff07          .dw $ff07
00042d 6f63
00042e 706d
00042f 7261
000430 0065          .db "compare",0
000431 0420          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000432 0433          .dw PFA_COMPARE
                 PFA_COMPARE:
000433 93bf          push xh
000434 93af          push xl
000435 018c          movw temp0, tosl
000436 9189
000437 9199          loadtos
000438 01dc          movw xl, tosl
000439 9189
00043a 9199          loadtos
00043b 019c          movw temp2, tosl
00043c 9189
00043d 9199          loadtos
00043e 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
00043f 90ed          ld temp4, X+
000440 90f1          ld temp5, Z+
000441 14ef          cp temp4, temp5
000442 f451          brne PFA_COMPARE_NOTEQUAL
000443 950a          dec temp0
000444 f019          breq PFA_COMPARE_ENDREACHED2
000445 952a          dec temp2
000446 f7c1          brne PFA_COMPARE_LOOP
000447 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000448 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000449 2b02          or temp0, temp2
00044a f411          brne PFA_COMPARE_CHECKLASTCHAR
00044b 2788          clr tosl
00044c c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
00044d ef8f          ser tosl
00044e c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
00044f 2f98          mov tosh, tosl
000450 91af          pop xl
000451 91bf          pop xh
000452 ccb9          jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000453 ff07         .dw $ff07
000454 666e
000455 3e61
000456 666c
000457 0061         .db "nfa>lfa",0
000458 042c         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000459 0108          .dw DO_COLON
                 PFA_NFA2LFA:
00045a 1081          .dw XT_NAME2STRING
00045b 0697          .dw XT_1PLUS
00045c 066c          .dw XT_2SLASH
00045d 0605          .dw XT_PLUS
00045e 047d          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
00045f ff0b          .dw $ff0b
000460 7061
000461 6c70
000462 7574
000463 6e72
000464 656b
000465 0079          .db "applturnkey",0
000466 0453          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000467 0108          .dw DO_COLON
                 PFA_APPLTURNKEY:
000468 00f2          .dw XT_USART
                 
000469 08a8          .dw XT_INTON
00046a 0f73          .dw XT_DOT_VER
00046b 0c1f          .dw XT_SPACE
00046c 0977          .dw XT_F_CPU
00046d 049d          .dw XT_DOLITERAL
00046e 03e8          .dw 1000
00046f 062a          .dw XT_UMSLASHMOD
000470 0558          .dw XT_NIP
000471 0a15          .dw XT_DECIMAL
000472 0b5f          .dw XT_DOT
000473 0baa          .dw XT_DOSLITERAL
000474 0004          .dw 4
000475 486b
000476 207a          .db "kHz "
000477 0bdd          .dw XT_ITYPE
                     
000478 047d          .dw XT_EXIT
                 
                 .include "dict/nrww.inc" ; well, not really nrww, but simplifies things alot
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
000479 ff04          .dw $ff04
00047a 7865
00047b 7469          .db "exit"
00047c 045f          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00047d 047e          .dw PFA_EXIT
                 PFA_EXIT:
00047e 91af          pop XL
00047f 91bf          pop XH
000480 cc8b          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
000481 ff07          .dw $ff07
000482 7865
000483 6365
000484 7475
000485 0065          .db "execute",0
000486 0479          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
000487 0488          .dw PFA_EXECUTE
                 PFA_EXECUTE:
000488 01bc          movw wl, tosl
000489 9189
00048a 9199          loadtos
00048b cc8a          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00048c 048d          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00048d 01fd          movw zl, XL
00048e 2755
00048f 0fee
000490 1fff
000491 1f55
000492 bf5b
000493 91a7
000494 91b7          readflashcell XL,XH
000495 cc76          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
000496 0497          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
000497 2b98          or tosh, tosl
000498 9189
000499 9199          loadtos
00049a f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00049b 9611          adiw XL, 1
00049c cc6f          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00049d 049e          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00049e 939a
00049f 938a          savetos
0004a0 01fd          movw zl, xl
0004a1 2755
0004a2 0fee
0004a3 1fff
0004a4 1f55
0004a5 bf5b
0004a6 9187
0004a7 9197          readflashcell tosl,tosh
0004a8 9611          adiw xl, 1
0004a9 cc62          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
0004aa 04ab          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
0004ab 939a
0004ac 938a          savetos
0004ad 01fb          movw zl, wl
0004ae 9631          adiw zl,1
0004af 2755
0004b0 0fee
0004b1 1fff
0004b2 1f55
0004b3 bf5b
0004b4 9187
0004b5 9197          readflashcell tosl,tosh
0004b6 cc55          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
0004b7 04b8          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
0004b8 939a
0004b9 938a          savetos
0004ba 01cb          movw tosl, wl
0004bb 9601          adiw tosl, 1
0004bc cc4f          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
0004bd 04be          .dw PFA_DOUSER
                 PFA_DOUSER:
0004be 939a
0004bf 938a          savetos
0004c0 01fb          movw zl, wl
0004c1 9631          adiw zl, 1
0004c2 2755
0004c3 0fee
0004c4 1fff
0004c5 1f55
0004c6 bf5b
0004c7 9187
0004c8 9197          readflashcell tosl,tosh
0004c9 0d84          add tosl, upl
0004ca 1d95          adc tosh, uph
0004cb cc40          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
0004cc ff07          .dw $ff07
0004cd 7628
0004ce 6c61
0004cf 6575
0004d0 0029          .db "(value)", 0
0004d1 0481          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
0004d2 0108          .dw DO_COLON
                 PFA_DOVALUE:
0004d3 018d          .dw XT_DOCREATE
0004d4 02ed          .dw XT_REVEAL
0004d5 01b0          .dw XT_COMPILE
0004d6 04d8          .dw PFA_DOVALUE1
0004d7 047d          .dw XT_EXIT
                 PFA_DOVALUE1:
0004d8 de2d          call_ DO_DODOES
0004d9 0519          .dw XT_DUP
0004da 0fba          .dw XT_ICELLPLUS
0004db 07ef          .dw XT_FETCHI
0004dc 0487          .dw XT_EXECUTE
0004dd 047d          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
0004de ff01          .dw $ff01
0004df 0040          .db "@",0
0004e0 04cc          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
0004e1 04e2          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
0004e2 01fc          movw zl, tosl
                     ; low byte is read before the high byte
0004e3 9181          ld tosl, z+
0004e4 9191          ld tosh, z+
0004e5 cc26          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
0004e6 ff01          .dw $ff01
0004e7 0021          .db "!",0
0004e8 04de          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
0004e9 04ea          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
0004ea 01fc          movw zl, tosl
0004eb 9189
0004ec 9199          loadtos
                     ; the high byte is written before the low byte
0004ed 8391          std Z+1, tosh
0004ee 8380          std Z+0, tosl
0004ef 9189
0004f0 9199          loadtos
0004f1 cc1a          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
0004f2 ff02          .dw $ff02
0004f3 2163          .db "c!"
0004f4 04e6          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
0004f5 04f6          .dw PFA_CSTORE
                 PFA_CSTORE:
0004f6 01fc          movw zl, tosl
0004f7 9189
0004f8 9199          loadtos
0004f9 8380          st Z, tosl
0004fa 9189
0004fb 9199          loadtos
0004fc cc0f          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
0004fd ff02          .dw $ff02
0004fe 4063          .db "c@"
0004ff 04f2          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
000500 0501          .dw PFA_CFETCH
                 PFA_CFETCH:
000501 01fc          movw zl, tosl
000502 2799          clr tosh
000503 8180          ld tosl, Z
000504 cc07          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
000505 ff02          .dw $ff02
000506 7540          .db "@u"
000507 04fd          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
000508 0108          .dw DO_COLON
                 PFA_FETCHU:
000509 075e          .dw XT_UP_FETCH
00050a 0605          .dw XT_PLUS
00050b 04e1          .dw XT_FETCH
00050c 047d          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
00050d ff02          .dw $ff02
00050e 7521          .db "!u"
00050f 0505          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
000510 0108          .dw DO_COLON
                 PFA_STOREU:
000511 075e          .dw XT_UP_FETCH
000512 0605          .dw XT_PLUS
000513 04e9          .dw XT_STORE
000514 047d          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
000515 ff03          .dw $ff03
000516 7564
000517 0070          .db "dup",0
000518 050d          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
000519 051a          .dw PFA_DUP
                 PFA_DUP:
00051a 939a
00051b 938a          savetos
00051c cbef          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
00051d ff04          .dw $ff04
00051e 643f
00051f 7075          .db "?dup"
000520 0515          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
000521 0522          .dw PFA_QDUP
                 PFA_QDUP:
000522 2f08          mov temp0, tosl
000523 2b09          or temp0, tosh
000524 f011          breq PFA_QDUP1
000525 939a
000526 938a          savetos
                 PFA_QDUP1:
000527 cbe4          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
000528 ff04          .dw $ff04
000529 7773
00052a 7061          .db "swap"
00052b 051d          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
00052c 052d          .dw PFA_SWAP
                 PFA_SWAP:
00052d 018c          movw temp0, tosl
00052e 9189
00052f 9199          loadtos
000530 931a          st -Y, temp1
000531 930a          st -Y, temp0
000532 cbd9          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
000533 ff04          .dw $ff04
000534 766f
000535 7265          .db "over"
000536 0528          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
000537 0538          .dw PFA_OVER
                 PFA_OVER:
000538 939a
000539 938a          savetos
00053a 818a          ldd tosl, Y+2
00053b 819b          ldd tosh, Y+3
                 
00053c cbcf          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
00053d ff04          .dw $ff04
00053e 7264
00053f 706f          .db "drop"
000540 0533          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
000541 0542          .dw PFA_DROP
                 PFA_DROP:
000542 9189
000543 9199          loadtos
000544 cbc7          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
000545 ff03          .dw $ff03
000546 6f72
000547 0074          .db "rot",0
000548 053d          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
000549 054a          .dw PFA_ROT
                 PFA_ROT:
00054a 018c          movw temp0, tosl
00054b 9129          ld temp2, Y+
00054c 9139          ld temp3, Y+ 
00054d 9189
00054e 9199          loadtos
                         
00054f 933a          st -Y, temp3
000550 932a          st -Y, temp2
000551 931a          st -Y, temp1
000552 930a          st -Y, temp0
                 
000553 cbb8          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
000554 ff03          .dw $ff03
000555 696e
000556 0070          .db "nip",0
000557 0545          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
000558 0559          .dw PFA_NIP
                 PFA_NIP:
000559 9622          adiw yl, 2
00055a cbb1          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
00055b ff02          .dw $ff02
00055c 3e72          .db "r>"
00055d 0554          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
00055e 055f          .dw PFA_R_FROM
                 PFA_R_FROM:
00055f 939a
000560 938a          savetos
000561 918f          pop tosl
000562 919f          pop tosh
000563 cba8          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
000564 ff02          .dw $ff02
000565 723e          .db ">r"
000566 055b          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
000567 0568          .dw PFA_TO_R
                 PFA_TO_R:
000568 939f          push tosh
000569 938f          push tosl
00056a 9189
00056b 9199          loadtos
00056c cb9f          jmp_ DO_NEXT
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
00056d ff02          .dw $ff02
00056e 4072          .db "r@"
00056f 0564          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
000570 0571          .dw PFA_R_FETCH
                 PFA_R_FETCH:
000571 939a
000572 938a          savetos
000573 918f          pop tosl
000574 919f          pop tosh
000575 939f          push tosh
000576 938f          push tosl
000577 cb94          jmp_ DO_NEXT
                 
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
000578 ff02          .dw $ff02
000579 3e3c          .db "<>"
00057a 056d          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00057b 0108          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
00057c 1216
00057d 0582
00057e 047d          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
00057f ff02          .dw $ff02
000580 3d30          .db "0="
000581 0578          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
000582 0583          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
000583 2b98          or tosh, tosl
000584 f5d1          brne PFA_ZERO1
000585 c030          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
000586 ff02          .dw $ff02
000587 3c30          .db "0<"
000588 057f          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
000589 058a          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
00058a fd97          sbrc tosh,7
00058b c02a          rjmp PFA_TRUE1
00058c c032          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
00058d ff02          .dw $ff02
00058e 3e30          .db "0>"
00058f 0586          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
000590 0591          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
000591 1582          cp tosl, zerol
000592 0593          cpc tosh, zeroh
000593 f15c          brlt PFA_ZERO1
000594 f151          brbs 1, PFA_ZERO1
000595 c020          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
000596 ff03          .dw $ff03
000597 3064
000598 003e          .db "d0>",0
000599 058d          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00059a 059b          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00059b 1582          cp tosl, zerol
00059c 0593          cpc tosh, zeroh
00059d 9189
00059e 9199          loadtos
00059f 0582          cpc tosl, zerol
0005a0 0593          cpc tosh, zeroh
0005a1 f0ec          brlt PFA_ZERO1
0005a2 f0e1          brbs 1, PFA_ZERO1
0005a3 c012          rjmp PFA_TRUE1
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
0005a4 ff03          .dw $ff03
0005a5 3064
0005a6 003c          .db "d0<",0
0005a7 0596          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
0005a8 05a9          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
0005a9 9622          adiw Y,2
0005aa fd97          sbrc tosh,7
0005ab 940c 05b6     jmp PFA_TRUE1
0005ad 940c 05bf     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
0005af ff04          .dw $ff04
0005b0 7274
0005b1 6575          .db "true"
0005b2 05a4          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
0005b3 05b4          .dw PFA_TRUE
                 PFA_TRUE:
0005b4 939a
0005b5 938a          savetos
                 PFA_TRUE1:
0005b6 ef8f          ser tosl
0005b7 ef9f          ser tosh
0005b8 cb53          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
0005b9 ff01          .dw $ff01
0005ba 0030          .db "0",0
0005bb 05af          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
0005bc 05bd          .dw PFA_ZERO
                 PFA_ZERO:
0005bd 939a
0005be 938a          savetos
                 PFA_ZERO1:
0005bf 01c1          movw tosl, zerol
0005c0 cb4b          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
0005c1 ff02          .dw $ff02
0005c2 3c75          .db "u<"
0005c3 05b9          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
0005c4 05c5          .dw PFA_ULESS
                 PFA_ULESS:
0005c5 9129          ld temp2, Y+
0005c6 9139          ld temp3, Y+
0005c7 1782          cp tosl, temp2
0005c8 0793          cpc tosh, temp3
0005c9 f3a8          brlo PFA_ZERO1
0005ca f3a1          brbs 1, PFA_ZERO1
0005cb cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
0005cc ff02          .dw $ff02
0005cd 3e75          .db "u>"
0005ce 05c1          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
0005cf 0108          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
0005d0 052c          .DW XT_SWAP
0005d1 05c4          .dw XT_ULESS
0005d2 047d          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
0005d3 ff01          .dw $ff01
0005d4 003c          .db "<",0
0005d5 05cc          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
0005d6 05d7          .dw PFA_LESS
                 PFA_LESS:
0005d7 9129          ld temp2, Y+
0005d8 9139          ld temp3, Y+
0005d9 1728          cp temp2, tosl
0005da 0739          cpc temp3, tosh
                 PFA_LESSDONE:
0005db f71c          brge PFA_ZERO1
0005dc cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
0005dd ff01          .dw $ff01
0005de 003e          .db ">",0
0005df 05d3          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
0005e0 05e1          .dw PFA_GREATER
                 PFA_GREATER:
0005e1 9129          ld temp2, Y+
0005e2 9139          ld temp3, Y+
0005e3 1728          cp temp2, tosl
0005e4 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
0005e5 f2cc          brlt PFA_ZERO1
0005e6 f2c1          brbs 1, PFA_ZERO1
0005e7 cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
0005e8 ff04          .dw $ff04
0005e9 6f6c
0005ea 3267          .db "log2"
0005eb 05dd          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
0005ec 05ed          .dw PFA_LOG2
                 PFA_LOG2:
0005ed 01fc          movw zl, tosl
0005ee 2799          clr tosh
0005ef e180          ldi tosl, 16
                 PFA_LOG2_1:
0005f0 958a          dec tosl
0005f1 f022          brmi PFA_LOG2_2 ; wrong data
0005f2 0fee          lsl  zl
0005f3 1fff          rol  zh
0005f4 f7d8          brcc PFA_LOG2_1
0005f5 cb16          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
0005f6 959a          dec tosh
0005f7 cb14          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
0005f8 ff01          .dw $ff01
0005f9 002d          .db "-",0
0005fa 05e8          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
0005fb 05fc          .dw PFA_MINUS
                 PFA_MINUS:
0005fc 9109          ld temp0, Y+
0005fd 9119          ld temp1, Y+
0005fe 1b08          sub temp0, tosl
0005ff 0b19          sbc temp1, tosh
000600 01c8          movw tosl, temp0
000601 cb0a          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
000602 ff01          .dw $ff01
000603 002b          .db "+",0
000604 05f8          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
000605 0606          .dw PFA_PLUS
                 PFA_PLUS:
000606 9109          ld temp0, Y+
000607 9119          ld temp1, Y+
000608 0f80          add tosl, temp0
000609 1f91          adc tosh, temp1
00060a cb01          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00060b ff02          .dw $ff02
00060c 2a6d          .db "m*"
00060d 0602          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
00060e 060f          .dw PFA_MSTAR
                 PFA_MSTAR:
00060f 018c          movw temp0, tosl
000610 9189
000611 9199          loadtos
000612 019c          movw temp2, tosl
                     ; high cell ah*bh
000613 0231          muls temp3, temp1
000614 0170          movw temp4, r0
                     ; low cell  al*bl
000615 9f20          mul  temp2, temp0
000616 01c0          movw tosl, r0
                     ; signed ah*bl
000617 0330          mulsu temp3, temp0
000618 08f3          sbc   temp5, zeroh
000619 0d90          add   tosh,  r0
00061a 1ce1          adc   temp4, r1
00061b 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
00061c 0312          mulsu temp1, temp2
00061d 08f3          sbc   temp5, zeroh
00061e 0d90          add   tosh,  r0
00061f 1ce1          adc   temp4, r1
000620 1cf3          adc   temp5, zeroh
                 
000621 939a
000622 938a          savetos
000623 01c7          movw tosl, temp4
000624 cae7          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
000625 ff06          .dw $ff06
000626 6d75
000627 6d2f
000628 646f          .db "um/mod"
000629 060b          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
00062a 062b          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
00062b 017c          movw temp4, tosl
                 
00062c 9129          ld temp2, Y+
00062d 9139          ld temp3, Y+
                   
00062e 9109          ld temp0, Y+
00062f 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
000630 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
000631 2755          clr temp7
000632 0f00          lsl temp0
000633 1f11          rol temp1
000634 1f22          rol temp2
000635 1f33          rol temp3
000636 1f55          rol temp7
                 
                   ; try subtracting divisor
000637 152e          cp temp2, temp4
000638 053f          cpc temp3, temp5
000639 0552          cpc temp7,zerol
                 
00063a f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
00063b 9503          inc temp0
00063c 192e          sub temp2, temp4
00063d 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
00063e 954a          dec  temp6
00063f f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
000640 933a          st -Y,temp3
000641 932a          st -Y,temp2
                 
                     ; put quotient on stack
000642 01c8          movw tosl, temp0
000643 cac8          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
000644 ff03          .dw $ff03
000645 6d75
000646 002a          .db "um*",0
000647 0625          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
000648 0649          .dw PFA_UMSTAR
                 PFA_UMSTAR:
000649 018c          movw temp0, tosl
00064a 9189
00064b 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
00064c 9f80          mul tosl,temp0
00064d 01f0          movw zl, r0
00064e 2722          clr temp2
00064f 2733          clr temp3
                     ; middle bytes
000650 9f90          mul tosh, temp0
000651 0df0          add zh, r0
000652 1d21          adc temp2, r1
000653 1d33          adc temp3, zeroh
                         
000654 9f81          mul tosl, temp1
000655 0df0          add zh, r0
000656 1d21          adc temp2, r1
000657 1d33          adc temp3, zeroh
                     
000658 9f91          mul tosh, temp1
000659 0d20          add temp2, r0
00065a 1d31          adc temp3, r1
00065b 01cf          movw tosl, zl
00065c 939a
00065d 938a          savetos
00065e 01c9          movw tosl, temp2
00065f caac          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
000660 ff06          .dw $ff06
000661 6e69
000662 6576
000663 7472          .db "invert"
000664 0644          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
000665 0666          .dw PFA_INVERT
                 PFA_INVERT:
000666 9580          com tosl
000667 9590          com tosh
000668 caa3          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
000669 ff02          .dw $ff02
00066a 2f32          .db "2/"
00066b 0660          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
00066c 066d          .dw PFA_2SLASH
                 PFA_2SLASH:
00066d 9595          asr tosh
00066e 9587          ror tosl
00066f ca9c          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
000670 ff02          .dw $ff02
000671 2a32          .db "2*"
000672 0669          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
000673 0674          .dw PFA_2STAR
                 PFA_2STAR:
000674 0f88          lsl tosl
000675 1f99          rol tosh
000676 ca95          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
000677 ff03          .dw $ff03
000678 6e61
000679 0064          .db "and",0
00067a 0670          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00067b 067c          .dw PFA_AND
                 PFA_AND:
00067c 9109          ld temp0, Y+
00067d 9119          ld temp1, Y+
00067e 2380          and tosl, temp0
00067f 2391          and tosh, temp1
000680 ca8b          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
000681 ff02          .dw $ff02
000682 726f          .db "or"
000683 0677          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
000684 0685          .dw PFA_OR
                 PFA_OR:
000685 9109          ld temp0, Y+
000686 9119          ld temp1, Y+
000687 2b80          or tosl, temp0
000688 2b91          or tosh, temp1
000689 ca82          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00068a ff03          .dw $ff03
00068b 6f78
00068c 0072          .db "xor",0
00068d 0681          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
00068e 068f          .dw PFA_XOR
                 PFA_XOR:
00068f 9109          ld temp0, Y+
000690 9119          ld temp1, Y+
000691 2780          eor tosl, temp0
000692 2791          eor tosh, temp1
000693 ca78          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
000694 ff02          .dw $ff02
000695 2b31          .db "1+"
000696 068a          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
000697 0698          .dw PFA_1PLUS
                 PFA_1PLUS:
000698 9601          adiw tosl,1
000699 ca72          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00069a ff02          .dw $ff02 
00069b 2d31          .db "1-"
00069c 0694          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
00069d 069e          .dw PFA_1MINUS
                 PFA_1MINUS:
00069e 9701          sbiw tosl, 1
00069f ca6c          jmp_ DO_NEXT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
0006a0 ff06          .dw $ff06
0006a1 736c
0006a2 6968
0006a3 7466          .db "lshift"
0006a4 069a          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
0006a5 06a6          .dw PFA_LSHIFT
                 PFA_LSHIFT:
0006a6 01fc          movw zl, tosl
0006a7 9189
0006a8 9199          loadtos
                 PFA_LSHIFT1:
0006a9 9731          sbiw zl, 1
0006aa f01a          brmi PFA_LSHIFT2
0006ab 0f88          lsl tosl
0006ac 1f99          rol tosh
0006ad cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
0006ae ca5d          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
0006af ff06          .dw $ff06
0006b0 7372
0006b1 6968
0006b2 7466          .db "rshift"
0006b3 06a0          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
0006b4 06b5          .dw PFA_RSHIFT
                 PFA_RSHIFT:
0006b5 01fc          movw zl, tosl
0006b6 9189
0006b7 9199          loadtos
                 PFA_RSHIFT1:
0006b8 9731          sbiw zl, 1
0006b9 f01a          brmi PFA_RSHIFT2
0006ba 9596          lsr tosh
0006bb 9587          ror tosl
0006bc cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
0006bd ca4e          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
0006be ff02          .dw $ff02
0006bf 212b          .db "+!"
0006c0 06af          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
0006c1 06c2          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
0006c2 01fc          movw zl, tosl
0006c3 9189
0006c4 9199          loadtos
0006c5 8120          ldd temp2, Z+0
0006c6 8131          ldd temp3, Z+1
0006c7 0f82          add tosl, temp2
0006c8 1f93          adc tosh, temp3
0006c9 8380          std Z+0, tosl
0006ca 8391          std Z+1, tosh
0006cb 9189
0006cc 9199          loadtos
0006cd ca3e          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
0006ce ff03          .dw $ff03
0006cf 7072
0006d0 0040          .db "rp@",0
0006d1 06be          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
0006d2 06d3          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
0006d3 939a
0006d4 938a          savetos
0006d5 b78d          in tosl, SPL
0006d6 b79e          in tosh, SPH
0006d7 ca34          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
0006d8 ff03          .dw $ff03
0006d9 7072
0006da 0021          .db "rp!",0
0006db 06ce          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
0006dc 06dd          .dw PFA_RP_STORE
                 PFA_RP_STORE:
0006dd b72f          in temp2, SREG
0006de 94f8          cli
0006df bf8d          out SPL, tosl
0006e0 bf9e          out SPH, tosh
0006e1 bf2f          out SREG, temp2
0006e2 9189
0006e3 9199          loadtos
0006e4 ca27          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
0006e5 ff03          .dw $ff03
0006e6 7073
0006e7 0040          .db "sp@",0
0006e8 06d8          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
0006e9 06ea          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
0006ea 939a
0006eb 938a          savetos
0006ec 01ce          movw tosl, yl
0006ed ca1e          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
0006ee ff03          .dw $ff03
0006ef 7073
0006f0 0021          .db "sp!",0
0006f1 06e5          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
0006f2 06f3          .dw PFA_SP_STORE
                 PFA_SP_STORE:
0006f3 01ec          movw yl, tosl
0006f4 9189
0006f5 9199          loadtos
0006f6 ca15          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
0006f7 06f8          .dw PFA_DODO
                 PFA_DODO:
0006f8 9129          ld temp2, Y+
0006f9 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
0006fa e8e0          ldi zl, $80
0006fb 0f3e          add temp3, zl
0006fc 1b82          sub  tosl, temp2
0006fd 0b93          sbc  tosh, temp3
                 
0006fe 933f          push temp3
0006ff 932f          push temp2    ; limit  ( --> limit + $8000)
000700 939f          push tosh
000701 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
000702 9189
000703 9199          loadtos
000704 ca07          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
000705 ff01          .dw $FF01
000706 0069          .db "i",0
000707 06ee          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
000708 0709          .dw PFA_I
                 PFA_I:
000709 939a
00070a 938a          savetos
00070b 918f          pop tosl
00070c 919f          pop tosh  ; index
00070d 91ef          pop zl
00070e 91ff          pop zh    ; limit
00070f 93ff          push zh
000710 93ef          push zl
000711 939f          push tosh
000712 938f          push tosl
000713 0f8e          add tosl, zl
000714 1f9f          adc tosh, zh
000715 c9f6          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
000716 0717          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
000717 91ef          pop zl
000718 91ff          pop zh
000719 0fe8          add zl, tosl
00071a 1ff9          adc zh, tosh
00071b 9189
00071c 9199          loadtos
00071d f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
00071e 93ff          push zh
00071f 93ef          push zl
000720 cd6c          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
000721 910f          pop  temp0
000722 911f          pop  temp1  ; remove limit
000723 9611          adiw xl, 1  ; skip branch-back address
000724 c9e7          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
000725 0726          .dw PFA_DOLOOP
                 PFA_DOLOOP:
000726 91ef          pop zl
000727 91ff          pop zh
000728 9631          adiw zl,1
000729 f3bb          brvs PFA_DOPLUSLOOP_LEAVE
00072a cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
00072b ff06          .dw $ff06
00072c 6e75
00072d 6f6c
00072e 706f          .db "unloop"
00072f 0705          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
000730 0731          .dw PFA_UNLOOP
                 PFA_UNLOOP:
000731 911f          pop temp1
000732 910f          pop temp0
000733 911f          pop temp1
000734 910f          pop temp0
000735 c9d6          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
000736 ff06          .dw $ff06
000737 6d63
000738 766f
000739 3e65          .db "cmove>"
00073a 072b          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
00073b 073c          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
00073c 93bf          push xh
00073d 93af          push xl
00073e 91e9          ld zl, Y+
00073f 91f9          ld zh, Y+ ; addr-to
000740 91a9          ld xl, Y+
000741 91b9          ld xh, Y+ ; addr-from
000742 2f09          mov temp0, tosh
000743 2b08          or temp0, tosl
000744 f041          brbs 1, PFA_CMOVE_G1
000745 0fe8          add zl, tosl
000746 1ff9          adc zh, tosh
000747 0fa8          add xl, tosl
000748 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
000749 911e          ld temp1, -X
00074a 9312          st -Z, temp1
00074b 9701          sbiw tosl, 1
00074c f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
00074d 91af          pop xl
00074e 91bf          pop xh
00074f 9189
000750 9199          loadtos
000751 c9ba          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
000752 ff02          .dw $ff02
000753 3c3e          .db "><"
000754 0736          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
000755 0756          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
000756 2f09          mov temp0, tosh
000757 2f98          mov tosh, tosl
000758 2f80          mov tosl, temp0
000759 c9b2          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
00075a ff03          .dw $ff03
00075b 7075
00075c 0040          .db "up@",0
00075d 0752          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
00075e 075f          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
00075f 939a
000760 938a          savetos
000761 01c2          movw tosl, upl
000762 c9a9          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
000763 ff03          .dw $ff03
000764 7075
000765 0021          .db "up!",0
000766 075a          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
000767 0768          .dw PFA_UP_STORE
                 PFA_UP_STORE:
000768 012c          movw upl, tosl
000769 9189
00076a 9199          loadtos
00076b c9a0          jmp_ DO_NEXT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
00076c ff03          .dw $ff03
00076d 6d31
00076e 0073          .db "1ms",0
00076f 0763          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
000770 0771          .dw PFA_1MS
                 PFA_1MS:
000771 e6e6
000772 e0fe
000773 9731
000774 f7f1
000775 0000          delay 1000
000776 c995          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
000777 ff03          .dw $ff03
000778 3e32
000779 0072          .db "2>r",0
00077a 076c          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
00077b 077c          .dw PFA_2TO_R
                 PFA_2TO_R:
00077c 01fc          movw zl, tosl
00077d 9189
00077e 9199          loadtos
00077f 939f          push tosh
000780 938f          push tosl
000781 93ff          push zh
000782 93ef          push zl
000783 9189
000784 9199          loadtos
000785 c986          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
000786 ff03          .dw $ff03
000787 7232
000788 003e          .db "2r>",0
000789 0777          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
00078a 078b          .dw PFA_2R_FROM
                 PFA_2R_FROM:
00078b 939a
00078c 938a          savetos
00078d 91ef          pop zl
00078e 91ff          pop zh
00078f 918f          pop tosl
000790 919f          pop tosh
000791 939a
000792 938a          savetos
000793 01cf          movw tosl, zl
000794 c977          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
000795 ff02          .dw $ff02
000796 6521          .db "!e"
000797 0786          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
000798 0799          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
000799 01fc          movw zl, tosl
00079a 9189
00079b 9199          loadtos
00079c b72f          in_ temp2, SREG
00079d 94f8          cli
00079e d028          rcall PFA_FETCHE2
00079f b500          in_  temp0, EEDR
0007a0 1708          cp temp0,tosl
0007a1 f009          breq PFA_STOREE3
0007a2 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
0007a3 9631          adiw zl,1
0007a4 d022          rcall PFA_FETCHE2
0007a5 b500          in_  temp0, EEDR
0007a6 1709          cp temp0,tosh
0007a7 f011          breq PFA_STOREE4
0007a8 2f89          mov tosl, tosh
0007a9 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
0007aa bf2f          out_ SREG, temp2
0007ab 9189
0007ac 9199          loadtos
0007ad c95e          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
0007ae 99f9          sbic EECR, EEPE
0007af cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
0007b0 b707          in_ temp0, SPMCSR
0007b1 fd00          sbrc temp0,SPMEN
0007b2 cffd          rjmp PFA_STOREE2
                 
0007b3 bdf2          out_ EEARH,zh
0007b4 bde1          out_ EEARL,zl
0007b5 bd80          out_ EEDR, tosl
0007b6 9afa          sbi EECR,EEMPE
0007b7 9af9          sbi EECR,EEPE
                 
0007b8 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
0007b9 ff02          .dw $ff02
0007ba 6540          .db "@e"
0007bb 0795          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
0007bc 07bd          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
0007bd b72f          in_ temp2, SREG
0007be 94f8          cli
0007bf 01fc          movw zl, tosl
0007c0 d006          rcall PFA_FETCHE2
0007c1 b580          in_ tosl, EEDR
                 
0007c2 9631          adiw zl,1
                 
0007c3 d003          rcall PFA_FETCHE2
0007c4 b590          in_  tosh, EEDR
0007c5 bf2f          out_ SREG, temp2
0007c6 c945          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
0007c7 99f9          sbic EECR, EEPE
0007c8 cffe          rjmp PFA_FETCHE2
                 
0007c9 bdf2          out_ EEARH,zh
0007ca bde1          out_ EEARL,zl
                 
0007cb 9af8          sbi EECR,EERE
0007cc 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
0007cd ff02          .dw $ff02
0007ce 6921          .db "!i"
0007cf 07b9          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
0007d0 1022          .dw PFA_DODEFER1
                 PFA_STOREI:
0007d1 00a2          .dw EE_STOREI
0007d2 0fc3          .dw XT_EDEFERFETCH
0007d3 0fcd          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                   .include "words/store-i_big.asm"
                 
                 ; R( -- )
                 ; writes a cell in flash
                 VE_DO_STOREI:
0007d4 ff04          .dw $ff04
0007d5 6928
0007d6 2921          .db "(i!)"
0007d7 07cd          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI
                 XT_DO_STOREI:
0007d8 07d9          .dw PFA_DO_STOREI
                 PFA_DO_STOREI:
0007d9 019c        movw temp2, tosl ; save the (word) address
0007da 9189
0007db 9199        loadtos          ; get the new value for the flash cell
0007dc 93af        push xl
0007dd 93bf        push xh
0007de 93cf        push yl
0007df 93df        push yh
0007e0 e0e1        ldi zl, byte3(DO_ISTORE_atmega)
0007e1 bfeb        out_ rampz, zl
0007e2 eff0        ldi zh, byte2(DO_ISTORE_atmega)
0007e3 e0e0        ldi zl, byte1(DO_ISTORE_atmega)
0007e4 9519        eicall 
0007e5 91df        pop yh
0007e6 91cf        pop yl
0007e7 91bf        pop xh
0007e8 91af        pop xl
                   ; finally clear the stack
0007e9 9189
0007ea 9199        loadtos
0007eb c920        jmp_ DO_NEXT
                 
                 ;
                 .set _pc = pc
                 .org NRWW_START_ADDR
                 DO_ISTORE_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
01f000 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
01f001 94e0        com temp4
01f002 94f0        com temp5
01f003 218e        and tosl, temp4
01f004 219f        and tosh, temp5
01f005 2b98        or tosh, tosl
01f006 f019        breq DO_ISTORE_writepage 
                 
01f007 01f9          movw zl, temp2
01f008 e003          ldi temp0,(1<<PGERS|1<<SPMEN)
01f009 d023          rcall dospm
                 
                 DO_ISTORE_writepage:
                   ; write page
01f00a 01f9        movw zl, temp2
01f00b e005        ldi temp0,(1<<PGWRT|1<<SPMEN)
01f00c d020        rcall dospm
                 
                   ; reenable RWW section
01f00d 01f9        movw zl, temp2
01f00e e101        ldi temp0,(1<<RWWSRE|1<<SPMEN)
01f00f d01d        rcall dospm
01f010 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
01f011 01f9        movw zl, temp2
                   ; get the beginning of page
01f012 78e0        andi zl,low(pagemask)
01f013 7fff        andi zh,high(pagemask)
01f014 01ef        movw y, z
                   ; loop counter (in words)
01f015 e8a0        ldi xl,low(pagesize)
01f016 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
01f017 01fe        movw z, y
01f018 2755
01f019 0fee
01f01a 1fff
01f01b 1f55
01f01c bf5b
01f01d 9147
01f01e 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
01f01f 01fe        movw z, y
01f020 17e2        cp zl, temp2
01f021 07f3        cpc zh, temp3
01f022 f011        breq pageload_newdata
01f023 010a          movw r0, temp6
01f024 c002          rjmp pageload_cont
                 pageload_newdata:
01f025 017a          movw temp4, temp6
01f026 010c          movw r0, tosl
                 pageload_cont:
01f027 e001        ldi temp0,(1<<SPMEN)
01f028 d004        rcall dospm
01f029 9621        adiw y, 1
01f02a 9711        sbiw x, 1
01f02b f759        brne pageload_loop
                 
                 pageload_done:
01f02c 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                   ; store status register
01f02d b71f        in temp1,SREG
01f02e 931f        push temp1
01f02f 94f8        cli
                 Wait_ee:
01f030 99f9        sbic EECR, EEPE
01f031 cffe        rjmp Wait_ee
                 wait_spm:
01f032 b717        in   temp1, SPMCSR
01f033 fd10        sbrc temp1, SPMEN
01f034 cffd        rjmp Wait_spm
                 
                   ; turn the word addres into a byte address
01f035 2755
01f036 0fee
01f037 1fff
01f038 1f55
01f039 bf5b        writeflashcell
                   ; execute spm
01f03a bf07        out SPMCSR,temp0
01f03b 95e8        spm
01f03c 911f        pop temp1
                   ; restore status register
01f03d bf1f        out SREG,temp1
01f03e 9508        ret
                 
                 .org _pc
                 .else
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
0007ec ff02          .dw $ff02
0007ed 6940          .db "@i"
0007ee 07d4          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
0007ef 07f0          .dw PFA_FETCHI
                 PFA_FETCHI:
0007f0 01fc          movw zl, tosl
0007f1 2755
0007f2 0fee
0007f3 1fff
0007f4 1f55
0007f5 bf5b
0007f6 9187
0007f7 9197          readflashcell tosl,tosh
0007f8 c913          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .include "dict/core_8k.inc"
                 
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
0007f9 ff03          .dw $ff03
0007fa 3e6e
0007fb 0072          .db "n>r",0
0007fc 07ec          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
0007fd 07fe          .dw PFA_N_TO_R
                 PFA_N_TO_R:
0007fe 01fc          movw zl, tosl
0007ff 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
000800 9189
000801 9199          loadtos
000802 939f          push tosh
000803 938f          push tosl
000804 950a          dec temp0
000805 f7d1          brne PFA_N_TO_R1
000806 93ef          push zl
000807 93ff          push zh
000808 9189
000809 9199          loadtos
00080a c901          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
00080b ff03          .dw $ff03
00080c 726e
00080d 003e          .db "nr>",0
00080e 07f9          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
00080f 0810          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
000810 939a
000811 938a          savetos
000812 91ff          pop zh
000813 91ef          pop zl
000814 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
000815 918f          pop tosl
000816 919f          pop tosh
000817 939a
000818 938a          savetos
000819 950a          dec temp0
00081a f7d1          brne PFA_N_R_FROM1
00081b 01cf          movw tosl, zl
00081c c8ef          jmp_ DO_NEXT
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
00081d ff03          .dw $ff03
00081e 3264
00081f 002a          .db "d2*",0
000820 080b          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
000821 0822          .dw PFA_D2STAR
                 PFA_D2STAR:
000822 9109          ld temp0, Y+
000823 9119          ld temp1, Y+
000824 0f00          lsl temp0
000825 1f11          rol temp1
000826 1f88          rol tosl
000827 1f99          rol tosh
000828 931a          st -Y, temp1
000829 930a          st -Y, temp0
00082a c8e1          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
00082b ff03          .dw $ff03
00082c 3264
00082d 002f          .db "d2/",0
00082e 081d          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
00082f 0830          .dw PFA_D2SLASH
                 PFA_D2SLASH:
000830 9109          ld temp0, Y+
000831 9119          ld temp1, Y+
000832 9595          asr tosh
000833 9587          ror tosl
000834 9517          ror temp1
000835 9507          ror temp0
000836 931a          st -Y, temp1
000837 930a          st -Y, temp0
000838 c8d3          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
000839 ff02          .dw $ff02
00083a 2b64          .db "d+"
00083b 082b          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
00083c 083d          .dw PFA_DPLUS
                 PFA_DPLUS:
00083d 9129          ld temp2, Y+
00083e 9139          ld temp3, Y+
                 
00083f 90e9          ld temp4, Y+
000840 90f9          ld temp5, Y+
000841 9149          ld temp6, Y+
000842 9159          ld temp7, Y+
                 
000843 0f24          add temp2, temp6
000844 1f35          adc temp3, temp7
000845 1d8e          adc tosl, temp4
000846 1d9f          adc tosh, temp5
                     
000847 933a          st -Y, temp3
000848 932a          st -Y, temp2
000849 c8c2          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
00084a ff02          .dw $ff02
00084b 2d64          .db "d-"
00084c 0839          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
00084d 084e          .dw PFA_DMINUS
                 PFA_DMINUS:
00084e 9129          ld temp2, Y+
00084f 9139          ld temp3, Y+
                 
000850 90e9          ld temp4, Y+
000851 90f9          ld temp5, Y+
000852 9149          ld temp6, Y+
000853 9159          ld temp7, Y+
                 
000854 1b42          sub temp6, temp2
000855 0b53          sbc temp7, temp3
000856 0ae8          sbc temp4, tosl
000857 0af9          sbc temp5, tosh
                 
000858 935a          st -Y, temp7
000859 934a          st -Y, temp6
00085a 01c7          movw tosl, temp4
00085b c8b0          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
00085c ff07          .dw $ff07
00085d 6964
00085e 766e
00085f 7265
000860 0074          .db "dinvert",0
000861 084a          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
000862 0863          .dw PFA_DINVERT
                 PFA_DINVERT:
000863 9109          ld temp0, Y+
000864 9119          ld temp1, Y+
000865 9580          com tosl
000866 9590          com tosh
000867 9500          com temp0
000868 9510          com temp1
000869 931a          st -Y, temp1
00086a 930a          st -Y, temp0
00086b c8a0          jmp_ DO_NEXT
                 .include "words/d-equal.asm"
                 
                 ; Compare
                 ; compares two double cell values
                 VE_DEQUAL:
00086c ff02          .dw $ff02
00086d 3d64          .db "d="
00086e 085c          .dw VE_HEAD
                     .set VE_HEAD = VE_DEQUAL
                 XT_DEQUAL:
00086f 0108          .dw DO_COLON
                 PFA_DEQUAL:
000870 084d          .dw XT_DMINUS
000871 0684          .dw XT_OR
000872 0582          .dw XT_ZEROEQUAL
000873 047d          .dw XT_EXIT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
000874 ff02          .dw $ff02
000875 2e75          .db "u."
000876 086c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
000877 0108          .dw DO_COLON
                 PFA_UDOT:
                 .endif
000878 05bc          .dw XT_ZERO
000879 0b67          .dw XT_UDDOT
00087a 047d          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
00087b ff03          .dw $ff03
00087c 2e75
00087d 0072          .db "u.r",0
00087e 0874          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
00087f 0108          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
000880 05bc          .dw XT_ZERO
000881 052c          .dw XT_SWAP
000882 0b70          .dw XT_UDDOTR
000883 047d          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
000884 ff0d          .dw $ff0d
000885 6873
000886 776f
000887 772d
000888 726f
000889 6c64
00088a 7369
00088b 0074          .db "show-wordlist",0
00088c 087b          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
00088d 0108          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
00088e 049d          .dw XT_DOLITERAL
00088f 0893          .dw XT_SHOWWORD
000890 052c          .dw XT_SWAP
000891 1066          .dw XT_TRAVERSEWORDLIST
000892 047d          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
000893 0108          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
000894 1081          .dw XT_NAME2STRING
000895 0bdd          .dw XT_ITYPE
000896 0c1f          .dw XT_SPACE         ; ( -- addr n)
000897 05b3          .dw XT_TRUE
000898 047d          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_WORDS:
000899 ff05          .dw $ff05
00089a 6f77
00089b 6472
00089c 0073          .db "words",0
00089d 0884          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
00089e 0108          .dw DO_COLON
                 PFA_WORDS:
                 .endif
00089f 049d          .dw XT_DOLITERAL
0008a0 0088          .dw CFG_ORDERLISTLEN+2
0008a1 07bc          .dw XT_FETCHE
0008a2 088d          .dw XT_SHOWWORDLIST
0008a3 047d          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
0008a4 ff04          .dw $ff04
0008a5 692b
0008a6 746e          .db "+int"
0008a7 0899          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
0008a8 08a9          .dw PFA_INTON
                 PFA_INTON:
0008a9 9478          sei
0008aa c861          jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
0008ab ff04          .dw $ff04
0008ac 692d
0008ad 746e          .db "-int"
0008ae 08a4          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
0008af 08b0          .dw PFA_INTOFF
                 PFA_INTOFF:
0008b0 94f8          cli
0008b1 c85a          jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
0008b2 ff04          .dw $ff04
0008b3 6e69
0008b4 2174          .db "int!"
0008b5 08ab          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
0008b6 0108          .dw DO_COLON
                 PFA_INTSTORE:
0008b7 049d          .dw XT_DOLITERAL
0008b8 0000          .dw intvec
0008b9 0605          .dw XT_PLUS
0008ba 0798          .dw XT_STOREE
0008bb 047d          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
0008bc ff04          .dw $ff04
0008bd 6e69
0008be 4074          .db "int@"
0008bf 08b2          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
0008c0 0108          .dw DO_COLON
                 PFA_INTFETCH:
0008c1 049d          .dw XT_DOLITERAL
0008c2 0000          .dw intvec
0008c3 0605          .dw XT_PLUS
0008c4 07bc          .dw XT_FETCHE
0008c5 047d          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
0008c6 ff08          .dw $ff08
0008c7 6e69
0008c8 2d74
0008c9 7274
0008ca 7061          .db "int-trap"
0008cb 08bc          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
0008cc 08cd          .dw PFA_INTTRAP
                 PFA_INTTRAP:
0008cd 9380 0216     sts intcur, tosl
0008cf 9189
0008d0 9199          loadtos
0008d1 9468          set ; set the interrupt flag for the inner interpreter
0008d2 c839          jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
0008d3 0108          .dw DO_COLON
                 PFA_ISREXEC:
0008d4 049d          .dw XT_DOLITERAL
0008d5 0216          .dw intcur
0008d6 0500          .dw XT_CFETCH
0008d7 049d          .dw XT_DOLITERAL
0008d8 0000          .dw intvec
0008d9 0605          .dw XT_PLUS
0008da 07bc          .dw XT_FETCHE
0008db 0487          .dw XT_EXECUTE
0008dc 08de          .dw XT_ISREND
0008dd 047d          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
0008de 08df          .dw PFA_ISREND
                 PFA_ISREND:
0008df d001          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
0008e0 c82b          jmp_ DO_NEXT
                 PFA_ISREND1:
0008e1 9518          reti
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
0008e2 ff04          .dw $ff04
0008e3 6970
0008e4 6b63          .db "pick"
0008e5 08c6          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
0008e6 0108          .dw DO_COLON
                 PFA_PICK:
                 .endif
0008e7 0697          .dw XT_1PLUS
0008e8 098f          .dw XT_CELLS
0008e9 06e9          .dw XT_SP_FETCH
0008ea 0605          .dw XT_PLUS
0008eb 04e1          .dw XT_FETCH
0008ec 047d          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
0008ed 0002          .dw $0002
0008ee 222e          .db ".",$22
0008ef 08e2          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
0008f0 0108          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
0008f1 08f8          .dw XT_SQUOTE
0008f2 01b0          .dw XT_COMPILE
0008f3 0bdd          .dw XT_ITYPE
0008f4 047d          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
0008f5 0002        .dw $0002
0008f6 2273        .db "s",$22
0008f7 08ed        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
0008f8 0108          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
0008f9 049d          .dw XT_DOLITERAL
0008fa 0022          .dw 34   ; 0x22 
0008fb 0dbd          .dw XT_PARSE       ; ( -- addr n)
0008fc 0982          .dw XT_STATE
0008fd 04e1          .dw XT_FETCH
0008fe 0496          .dw XT_DOCONDBRANCH
0008ff 0901          DEST(PFA_SQUOTE1)
000900 01dc            .dw XT_SLITERAL
                 PFA_SQUOTE1:
000901 047d          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
000902 ff04          .dw $ff04
000903 6966
000904 6c6c          .db "fill"
000905 08f5          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
000906 0108          .dw DO_COLON
                 PFA_FILL:
000907 0549          .dw XT_ROT
000908 0549          .dw XT_ROT
000909 0521
00090a 0496          .dw XT_QDUP,XT_DOCONDBRANCH
00090b 0913          DEST(PFA_FILL2)
00090c 11f5          .dw XT_BOUNDS
00090d 06f7          .dw XT_DODO
                 PFA_FILL1:
00090e 0519          .dw XT_DUP
00090f 0708          .dw XT_I
000910 04f5          .dw XT_CSTORE  ; ( -- c c-addr)
000911 0725          .dw XT_DOLOOP
000912 090e          .dw PFA_FILL1
                 PFA_FILL2:
000913 0541          .dw XT_DROP
000914 047d          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000915 ff0b          .dw $ff0b
000916 6e65
000917 6976
000918 6f72
000919 6d6e
00091a 6e65
00091b 0074          .db "environment",0
00091c 0902          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
00091d 04ab          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
00091e 0080          .dw CFG_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
00091f ff09          .dw $ff09
000920 6f77
000921 6472
000922 696c
000923 7473
000924 0073          .db "wordlists",0
000925 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000926 0108          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000927 049d          .dw XT_DOLITERAL
000928 0008          .dw NUMWORDLISTS
000929 047d          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
00092a ff04          .dw $ff04
00092b 702f
00092c 6461          .db "/pad"
00092d 091f          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
00092e 0108          .dw DO_COLON
                 PFA_ENVSLASHPAD:
00092f 06e9          .dw XT_SP_FETCH
000930 09bc          .dw XT_PAD
000931 05fb          .dw XT_MINUS
000932 047d          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENVSLASHHOLD:
000933 ff05          .dw $ff05
000934 682f
000935 6c6f
000936 0064          .db "/hold",0
000937 092a          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000938 0108          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
                 .endif
000939 09bc          .dw XT_PAD
00093a 09f7          .dw XT_HERE
00093b 05fb          .dw XT_MINUS
00093c 047d          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
00093d ff0a          .dw $ff0a
00093e 6f66
00093f 7472
000940 2d68
000941 616e
000942 656d          .db "forth-name"
000943 0933          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
000944 0108          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000945 0baa          .dw XT_DOSLITERAL
000946 0007          .dw 7
                 .endif
000947 6d61
000948 6f66
000949 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
00094a 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
00094b 047d          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
00094c ff07          .dw $ff07
00094d 6576
00094e 7372
00094f 6f69
000950 006e          .db "version",0
000951 093d          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
000952 0108          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
000953 049d          .dw XT_DOLITERAL
000954 003d          .dw 61
000955 047d          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
000956 ff03          .dw $ff03
000957 7063
000958 0075          .db "cpu",0
000959 094c          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
00095a 0108          .dw DO_COLON
                 PFA_EN_CPU:
                 .endif
00095b 049d          .dw XT_DOLITERAL
00095c 0075          .dw mcu_name
00095d 0c09          .dw XT_ICOUNT
00095e 047d          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
00095f ff08          .dw $ff08
000960 636d
000961 2d75
000962 6e69
000963 6f66          .db "mcu-info"
000964 0956          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000965 0108          .dw DO_COLON
                 PFA_EN_MCUINFO:
000966 049d          .dw XT_DOLITERAL
000967 0071          .dw mcu_info
000968 047d          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_ENVUSERSIZE:
000969 ff05          .dw $ff05
00096a 752f
00096b 6573
00096c 0072          .db "/user",0
00096d 095f          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
00096e 0108          .dw DO_COLON
                 PFA_ENVUSERSIZE:
                 .endif
00096f 049d          .dw XT_DOLITERAL
000970 0026          .dw SYSUSERSIZE + APPUSERSIZE
000971 047d          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
000972 ff05          .dw $ff05
000973 5f66
000974 7063
000975 0075          .db "f_cpu",0
000976 0915          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
000977 0108          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
000978 049d          .dw XT_DOLITERAL
000979 0000          .dw (F_CPU % 65536)
00097a 049d          .dw XT_DOLITERAL
00097b 00e1          .dw (F_CPU / 65536)
00097c 047d          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
00097d ff05          .dw $ff05
00097e 7473
00097f 7461
000980 0065          .db "state",0
000981 0972          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
000982 04ab          .dw PFA_DOVARIABLE
                 PFA_STATE:
000983 021f          .dw ram_state
                 
                 .dseg
00021f           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
000984 ff04          .dw $ff04
000985 6162
000986 6573          .db "base"
000987 097d          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
000988 04be          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
000989 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
00098a ff05          .dw $ff05
00098b 6563
00098c 6c6c
00098d 0073          .db "cells",0
00098e 0984          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
00098f 0674          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
000990 ff05          .dw $ff05
000991 6563
000992 6c6c
000993 002b          .db "cell+",0
000994 098a          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
000995 0996          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
000996 9602          adiw tosl, CELLSIZE
000997 940c 010c     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
000999 ff04          .dw $ff04
00099a 6432
00099b 7075          .db "2dup"
00099c 0990          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
00099d 0108          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
00099e 0537          .dw XT_OVER
00099f 0537          .dw XT_OVER
0009a0 047d          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
0009a1 ff05          .dw $ff05
0009a2 6432
0009a3 6f72
0009a4 0070          .db "2drop",0
0009a5 0999          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
0009a6 0108          .dw DO_COLON
                 PFA_2DROP:
                 .endif
0009a7 0541          .dw XT_DROP
0009a8 0541          .dw XT_DROP
0009a9 047d          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
0009aa ff04          .dw $ff04
0009ab 7574
0009ac 6b63          .db "tuck"
0009ad 09a1          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
0009ae 0108          .dw DO_COLON
                 PFA_TUCK:
                 .endif
0009af 052c          .dw XT_SWAP
0009b0 0537          .dw XT_OVER
0009b1 047d          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
0009b2 ff03          .dw $ff03
0009b3 693e
0009b4 006e          .db ">in",0
0009b5 09aa          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
0009b6 04be          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
0009b7 0018          .dw USER_TO_IN
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PAD:
0009b8 ff03          .dw $ff03
0009b9 6170
0009ba 0064          .db "pad",0
0009bb 09b2          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
0009bc 0108          .dw DO_COLON
                 PFA_PAD:
                 .endif
0009bd 09f7          .dw XT_HERE
0009be 049d          .dw XT_DOLITERAL
0009bf 0028          .dw 40
0009c0 0605          .dw XT_PLUS
0009c1 047d          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMIT:
0009c2 ff04          .dw $ff04
0009c3 6d65
0009c4 7469          .db "emit"
0009c5 09b8          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
0009c6 1022          .dw PFA_DODEFER1
                 PFA_EMIT:
                 .endif
0009c7 000e          .dw USER_EMIT
0009c8 0feb          .dw XT_UDEFERFETCH
0009c9 0ff7          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMITQ:
0009ca ff05          .dw $ff05
0009cb 6d65
0009cc 7469
0009cd 003f          .db "emit?",0
0009ce 09c2          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
0009cf 1022          .dw PFA_DODEFER1
                 PFA_EMITQ:
                 .endif
0009d0 0010          .dw USER_EMITQ
0009d1 0feb          .dw XT_UDEFERFETCH
0009d2 0ff7          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEY:
0009d3 ff03          .dw $ff03
0009d4 656b
0009d5 0079          .db "key",0
0009d6 09ca          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
0009d7 1022          .dw PFA_DODEFER1
                 PFA_KEY:
                 .endif
0009d8 0012          .dw USER_KEY
0009d9 0feb          .dw XT_UDEFERFETCH
0009da 0ff7          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEYQ:
0009db ff04          .dw $ff04
0009dc 656b
0009dd 3f79          .db "key?"
0009de 09d3          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
0009df 1022          .dw PFA_DODEFER1
                 PFA_KEYQ:
                 .endif
0009e0 0014          .dw USER_KEYQ
0009e1 0feb          .dw XT_UDEFERFETCH
0009e2 0ff7          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
0009e3 ff02          .dw $ff02
0009e4 7064          .db "dp"
0009e5 09db          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
0009e6 04d8          .dw PFA_DOVALUE1
                 PFA_DP:
0009e7 0074          .dw CFG_DP
0009e8 0fc3          .dw XT_EDEFERFETCH
0009e9 0fcd          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
0009ea ff05          .dw $ff05
0009eb 6865
0009ec 7265
0009ed 0065          .db "ehere",0
0009ee 09e3          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
0009ef 04d8          .dw PFA_DOVALUE1
                 PFA_EHERE:
0009f0 0078          .dw EE_EHERE
0009f1 0fc3          .dw XT_EDEFERFETCH
0009f2 0fcd          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
0009f3 ff04          .dw $ff04
0009f4 6568
0009f5 6572          .db "here"
0009f6 09ea          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
0009f7 04d8          .dw PFA_DOVALUE1
                 PFA_HERE:
0009f8 0076          .dw EE_HERE
0009f9 0fc3          .dw XT_EDEFERFETCH
0009fa 0fcd          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
0009fb ff05          .dw $ff05
0009fc 6c61
0009fd 6f6c
0009fe 0074          .db "allot",0
0009ff 09f3          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
000a00 0108          .dw DO_COLON
                 PFA_ALLOT:
000a01 09f7          .dw XT_HERE
000a02 0605          .dw XT_PLUS
000a03 0fa8          .dw XT_DOTO
000a04 09f8          .dw PFA_HERE
000a05 047d          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
000a06 ff03          .dw $ff03
000a07 6962
000a08 006e          .db "bin",0
000a09 09fb          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
000a0a 0108          .dw DO_COLON
                 PFA_BIN:
                 .endif
000a0b 1222          .dw XT_TWO
000a0c 0988          .dw XT_BASE
000a0d 04e9          .dw XT_STORE
000a0e 047d          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
000a0f ff07          .dw $ff07
000a10 6564
000a11 6963
000a12 616d
000a13 006c          .db "decimal",0
000a14 0a06          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
000a15 0108          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
000a16 049d          .dw XT_DOLITERAL
000a17 000a          .dw 10
000a18 0988          .dw XT_BASE
000a19 04e9          .dw XT_STORE
000a1a 047d          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
000a1b ff03          .dw $ff03
000a1c 6568
000a1d 0078          .db "hex",0
000a1e 0a0f          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
000a1f 0108          .dw DO_COLON
                 PFA_HEX:
                 .endif
000a20 049d          .dw XT_DOLITERAL
000a21 0010          .dw 16
000a22 0988          .dw XT_BASE
000a23 04e9          .dw XT_STORE
000a24 047d          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
000a25 ff02          .dw $ff02
000a26 6c62          .db "bl"
000a27 0a1b          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
000a28 04ab          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
000a29 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
000a2a ff07          .dw $ff07
000a2b 7574
000a2c 6e72
000a2d 656b
000a2e 0079          .db "turnkey",0
000a2f 0a25          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
000a30 1022          .dw PFA_DODEFER1
                 PFA_TURNKEY:
000a31 007e          .dw CFG_TURNKEY
000a32 0fc3          .dw XT_EDEFERFETCH
000a33 0fcd          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
000a34 ff04          .dw $ff04
000a35 6d2f
000a36 646f          .db "/mod"
000a37 0a2a          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
000a38 0a39          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
000a39 019c          movw temp2, tosl
                     
000a3a 9109          ld temp0, Y+
000a3b 9119          ld temp1, Y+
                 
000a3c 2f41          mov	temp6,temp1	;move dividend High to sign register
000a3d 2743          eor	temp6,temp3	;xor divisor High with sign register
000a3e ff17          sbrs	temp1,7	;if MSB in dividend set
000a3f c004          rjmp	PFA_SLASHMOD_1
000a40 9510          com	temp1		;    change sign of dividend
000a41 9500          com	temp0		
000a42 5f0f          subi	temp0,low(-1)
000a43 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
000a44 ff37          sbrs	temp3,7	;if MSB in divisor set
000a45 c004          rjmp	PFA_SLASHMOD_2
000a46 9530          com	temp3		;    change sign of divisor
000a47 9520          com	temp2		
000a48 5f2f          subi	temp2,low(-1)
000a49 4f3f          sbci	temp3,high(-1)
000a4a 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
000a4b 18ff          sub	temp5,temp5;clear remainder High byte and carry
000a4c e151          ldi	temp7,17	;init loop counter
                 
000a4d 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
000a4e 1f11          rol	temp1
000a4f 955a          dec	temp7		;decrement counter
000a50 f439          brne	PFA_SLASHMOD_5		;if done
000a51 ff47          sbrs	temp6,7		;    if MSB in sign register set
000a52 c004          rjmp	PFA_SLASHMOD_4
000a53 9510          com	temp1	;        change sign of result
000a54 9500          com	temp0
000a55 5f0f          subi	temp0,low(-1)
000a56 4f1f          sbci	temp1,high(-1)
000a57 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
000a58 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
000a59 1cff          rol	temp5
000a5a 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
000a5b 0af3          sbc	temp5,temp3	;
000a5c f420          brcc	PFA_SLASHMOD_6		;if result negative
000a5d 0ee2          add	temp4,temp2	;    restore remainder
000a5e 1ef3          adc	temp5,temp3
000a5f 9488          clc			;    clear carry to be shifted into result
000a60 cfec          rjmp	PFA_SLASHMOD_3		;else
000a61 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
000a62 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
000a63 92fa          st -Y,temp5
000a64 92ea          st -Y,temp4
                 
                     ; put quotient on stack
000a65 01c8          movw tosl, temp0
000a66 940c 010c     jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
000a68 ff05          .dw $ff05
000a69 2f75
000a6a 6f6d
000a6b 0064          .db "u/mod",0
000a6c 0a34          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
000a6d 0108          .dw DO_COLON
                 PFA_USLASHMOD:
000a6e 0567          .dw XT_TO_R
000a6f 05bc          .dw XT_ZERO
000a70 055e          .dw XT_R_FROM
000a71 062a          .dw XT_UMSLASHMOD
000a72 047d          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
000a73 ff06          .dw $ff06
000a74 656e
000a75 6167
000a76 6574          .db "negate"
000a77 0a68          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
000a78 0108          .dw DO_COLON
                 PFA_NEGATE:
000a79 0665          .dw XT_INVERT
000a7a 0697          .dw XT_1PLUS
000a7b 047d          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
000a7c ff01          .dw $ff01
000a7d 002f          .db "/",0
000a7e 0a73          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
000a7f 0108          .dw DO_COLON
                 PFA_SLASH:
                 .endif
000a80 0a38          .dw XT_SLASHMOD
000a81 0558          .dw XT_NIP
000a82 047d          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
000a83 ff03          .dw $ff03
000a84 6f6d
000a85 0064          .db "mod",0
000a86 0a7c          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
000a87 0108          .dw DO_COLON
                 PFA_MOD:
                 .endif
000a88 0a38          .dw XT_SLASHMOD
000a89 0541          .dw XT_DROP
000a8a 047d          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ; Arithmetics
                 ; get the absolute value
                 VE_ABS:
000a8b ff03          .dw $ff03
000a8c 6261
000a8d 0073          .db "abs",0
000a8e 0a83          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
000a8f 0a90          .dw PFA_ABS
                 PFA_ABS:
000a90 2399          tst tosh
000a91 f41a          brpl PFA_ABS1
000a92 9580          com tosl
000a93 9590          com tosh
000a94 9601          adiw tosl, 1
                 PFA_ABS1:
000a95 940c 010c     jmp_ do_next
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
000a97 ff03          .dw $ff03
000a98 696d
000a99 006e          .db "min",0
000a9a 0a8b          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
000a9b 0108          .dw DO_COLON
                 PFA_MIN:
                 .endif
000a9c 099d          .dw XT_2DUP
000a9d 05e0          .dw XT_GREATER
000a9e 0496          .dw XT_DOCONDBRANCH
000a9f 0aa1          DEST(PFA_MIN1)
000aa0 052c          .dw XT_SWAP
                 PFA_MIN1:
000aa1 0541          .dw XT_DROP
000aa2 047d          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
000aa3 ff03          .dw $ff03
000aa4 616d
000aa5 0078          .db "max",0
000aa6 0a97          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
000aa7 0108          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
000aa8 099d          .dw XT_2DUP
000aa9 05d6          .dw XT_LESS
000aaa 0496          .dw XT_DOCONDBRANCH
000aab 0aad          DEST(PFA_MAX1)
000aac 052c          .dw XT_SWAP
                 PFA_MAX1:
000aad 0541          .dw XT_DROP
000aae 047d          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
000aaf ff06          .dw $ff06
000ab0 6977
000ab1 6874
000ab2 6e69          .db "within"
000ab3 0aa3          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
000ab4 0108          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
000ab5 0537          .dw XT_OVER
000ab6 05fb          .dw XT_MINUS
000ab7 0567          .dw XT_TO_R
000ab8 05fb          .dw XT_MINUS
000ab9 055e          .dw XT_R_FROM
000aba 05c4          .dw XT_ULESS
000abb 047d          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
000abc ff07          .dw $ff07 
000abd 6f74
000abe 7075
000abf 6570
000ac0 0072          .db "toupper",0
000ac1 0aaf          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
000ac2 0108          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
000ac3 0519          .dw XT_DUP 
000ac4 049d          .dw XT_DOLITERAL 
000ac5 0061          .dw 'a' 
000ac6 049d          .dw XT_DOLITERAL 
000ac7 007b          .dw 'z'+1
000ac8 0ab4          .dw XT_WITHIN 
000ac9 0496          .dw XT_DOCONDBRANCH
000aca 0ace          DEST(PFA_TOUPPER0)
000acb 049d          .dw XT_DOLITERAL
000acc 00df          .dw 223 ; inverse of 0x20: 0xdf
000acd 067b          .dw XT_AND 
                 PFA_TOUPPER0:
000ace 047d          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
000acf ff07          .dw $ff07
000ad0 6f74
000ad1 6f6c
000ad2 6577
000ad3 0072          .db "tolower",0
000ad4 0abc          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
000ad5 0108          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
000ad6 0519          .dw XT_DUP
000ad7 049d          .dw XT_DOLITERAL
000ad8 0041          .dw 'A'
000ad9 049d          .dw XT_DOLITERAL
000ada 005b          .dw 'Z'+1
000adb 0ab4          .dw XT_WITHIN
000adc 0496          .dw XT_DOCONDBRANCH
000add 0ae1          DEST(PFA_TOLOWER0)
000ade 049d          .dw XT_DOLITERAL
000adf 0020          .dw 32
000ae0 0684          .dw XT_OR 
                 PFA_TOLOWER0:
000ae1 047d          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
000ae2 ff03          .dw $ff03
000ae3 6c68
000ae4 0064          .db "hld",0
000ae5 0acf          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
000ae6 04ab          .dw PFA_DOVARIABLE
                 PFA_HLD:
000ae7 0221          .dw ram_hld
                 
                 .dseg
000221           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
000ae8 ff04          .dw $ff04
000ae9 6f68
000aea 646c          .db "hold"
000aeb 0ae2          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
000aec 0108          .dw DO_COLON
                 PFA_HOLD:
                 .endif
000aed 0ae6          .dw XT_HLD
000aee 0519          .dw XT_DUP
000aef 04e1          .dw XT_FETCH
000af0 069d          .dw XT_1MINUS
000af1 0519          .dw XT_DUP
000af2 0567          .dw XT_TO_R
000af3 052c          .dw XT_SWAP
000af4 04e9          .dw XT_STORE
000af5 055e          .dw XT_R_FROM
000af6 04f5          .dw XT_CSTORE
000af7 047d          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
000af8 ff02          .dw $ff02
000af9 233c          .db "<#"
000afa 0ae8          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
000afb 0108          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
000afc 09bc          .dw XT_PAD
000afd 0ae6          .dw XT_HLD
000afe 04e9          .dw XT_STORE
000aff 047d          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
000b00 ff01          .dw $ff01
000b01 0023          .db "#",0
000b02 0af8          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
000b03 0108          .dw DO_COLON
                 PFA_SHARP:
                 .endif
000b04 0988          .dw XT_BASE
000b05 04e1          .dw XT_FETCH
000b06 0b80          .dw XT_UDSLASHMOD
000b07 0549          .dw XT_ROT
000b08 049d          .dw XT_DOLITERAL
000b09 0009          .dw 9
000b0a 0537          .dw XT_OVER
000b0b 05d6          .dw XT_LESS
000b0c 0496          .dw XT_DOCONDBRANCH
000b0d 0b11          DEST(PFA_SHARP1)
000b0e 049d          .dw XT_DOLITERAL
000b0f 0007          .dw 7
000b10 0605          .dw XT_PLUS
                 PFA_SHARP1:
000b11 049d          .dw XT_DOLITERAL
000b12 0030          .dw 48 ; ASCII 0
000b13 0605          .dw XT_PLUS
000b14 0aec          .dw XT_HOLD
000b15 047d          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
000b16 ff02          .dw $ff02
000b17 7323          .db "#s"
000b18 0b00          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
000b19 0108          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
000b1a 0b03          .dw XT_SHARP
000b1b 099d          .dw XT_2DUP
000b1c 0684          .dw XT_OR
000b1d 0582          .dw XT_ZEROEQUAL
000b1e 0496          .dw XT_DOCONDBRANCH
000b1f 0b1a          DEST(NUMS1) ; PFA_SHARP_S
000b20 047d          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
000b21 ff02          .dw $ff02
000b22 3e23          .db "#>"
000b23 0b16          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
000b24 0108          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
000b25 09a6          .dw XT_2DROP
000b26 0ae6          .dw XT_HLD
000b27 04e1          .dw XT_FETCH
000b28 09bc          .dw XT_PAD
000b29 0537          .dw XT_OVER
000b2a 05fb          .dw XT_MINUS
000b2b 047d          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
000b2c ff04          .dw $ff04
000b2d 6973
000b2e 6e67          .db "sign"
000b2f 0b21          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
000b30 0108          .dw DO_COLON
                 PFA_SIGN:
                 .endif
000b31 0589          .dw XT_ZEROLESS
000b32 0496          .dw XT_DOCONDBRANCH
000b33 0b37          DEST(PFA_SIGN1)
000b34 049d          .dw XT_DOLITERAL
000b35 002d          .dw 45 ; ascii -
000b36 0aec          .dw XT_HOLD
                 PFA_SIGN1:
000b37 047d          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
000b38 ff03          .dw $ff03
000b39 2e64
000b3a 0072          .db "d.r",0
000b3b 0b2c          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000b3c 0108          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
000b3d 0567          .dw XT_TO_R
000b3e 09ae          .dw XT_TUCK
000b3f 10e3          .dw XT_DABS
000b40 0afb          .dw XT_L_SHARP
000b41 0b19          .dw XT_SHARP_S
000b42 0549          .dw XT_ROT
000b43 0b30          .dw XT_SIGN
000b44 0b24          .dw XT_SHARP_G
000b45 055e          .dw XT_R_FROM
000b46 0537          .dw XT_OVER
000b47 05fb          .dw XT_MINUS
000b48 0c28          .dw XT_SPACES
000b49 0c38          .dw XT_TYPE
000b4a 047d          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
000b4b ff02          .dw $ff02
000b4c 722e          .db ".r"
000b4d 0b38          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
000b4e 0108          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
000b4f 0567          .dw XT_TO_R
000b50 11fe          .dw XT_S2D
000b51 055e          .dw XT_R_FROM
000b52 0b3c          .dw XT_DDOTR
000b53 047d          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
000b54 ff02          .dw $ff02
000b55 2e64          .db "d."
000b56 0b4b          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000b57 0108          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
000b58 05bc          .dw XT_ZERO
000b59 0b3c          .dw XT_DDOTR
000b5a 0c1f          .dw XT_SPACE
000b5b 047d          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
000b5c ff01          .dw $ff01
000b5d 002e          .db ".",0
000b5e 0b54          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000b5f 0108          .dw DO_COLON
                 PFA_DOT:
                 .endif
000b60 11fe          .dw XT_S2D
000b61 0b57          .dw XT_DDOT
000b62 047d          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
000b63 ff03          .dw $ff03
000b64 6475
000b65 002e          .db "ud.",0
000b66 0b5c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000b67 0108          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
000b68 05bc          .dw XT_ZERO
000b69 0b70          .dw XT_UDDOTR
000b6a 0c1f          .dw XT_SPACE
000b6b 047d          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
000b6c ff04          .dw $ff04
000b6d 6475
000b6e 722e          .db "ud.r"
000b6f 0b63          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
000b70 0108          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
000b71 0567          .dw XT_TO_R
000b72 0afb          .dw XT_L_SHARP
000b73 0b19          .dw XT_SHARP_S
000b74 0b24          .dw XT_SHARP_G
000b75 055e          .dw XT_R_FROM
000b76 0537          .dw XT_OVER
000b77 05fb          .dw XT_MINUS
000b78 0c28          .dw XT_SPACES
000b79 0c38          .dw XT_TYPE
000b7a 047d          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
000b7b ff06          .dw $ff06
000b7c 6475
000b7d 6d2f
000b7e 646f          .db "ud/mod"
000b7f 0b6c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
000b80 0108          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
000b81 0567          .dw XT_TO_R
000b82 05bc          .dw XT_ZERO
000b83 0570          .dw XT_R_FETCH
000b84 062a          .dw XT_UMSLASHMOD
000b85 055e          .dw XT_R_FROM
000b86 052c          .dw XT_SWAP
000b87 0567          .dw XT_TO_R
000b88 062a          .dw XT_UMSLASHMOD
000b89 055e          .dw XT_R_FROM
000b8a 047d          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
000b8b ff06          .dw $ff06 
000b8c 6964
000b8d 6967
000b8e 3f74          .db "digit?"
000b8f 0b7b          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
000b90 0108          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
000b91 0ac2          .dw XT_TOUPPER
000b92 0519
000b93 049d
000b94 0039
000b95 05e0
000b96 049d
000b97 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
000b98 067b
000b99 0605
000b9a 0519
000b9b 049d
000b9c 0140
000b9d 05e0          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
000b9e 049d
000b9f 0107
000ba0 067b
000ba1 05fb
000ba2 049d
000ba3 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
000ba4 05fb
000ba5 0519
000ba6 0988
000ba7 04e1
000ba8 05c4          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
000ba9 047d          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
000baa 0108        .dw DO_COLON
                 PFA_DOSLITERAL:
000bab 0570        .dw XT_R_FETCH   ; ( -- addr )
000bac 0c09        .dw XT_ICOUNT
000bad 055e        .dw XT_R_FROM
000bae 0537        .dw XT_OVER     ; ( -- addr' n addr n)
000baf 0697        .dw XT_1PLUS
000bb0 066c        .dw XT_2SLASH   ; ( -- addr' n addr k )
000bb1 0605        .dw XT_PLUS     ; ( -- addr' n addr'' )
000bb2 0697        .dw XT_1PLUS
000bb3 0567        .dw XT_TO_R     ; ( -- )
000bb4 047d        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
000bb5 ff02        .dw $ff02
000bb6 2c73        .db "s",$2c
000bb7 0b8b        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
000bb8 0108          .dw DO_COLON
                 PFA_SCOMMA:
000bb9 0519          .dw XT_DUP
000bba 0bbc          .dw XT_DOSCOMMA
000bbb 047d          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
000bbc 0108          .dw DO_COLON
                 PFA_DOSCOMMA:
000bbd 01bb          .dw XT_COMMA
000bbe 0519          .dw XT_DUP   ; ( --addr len len)
000bbf 066c          .dw XT_2SLASH ; ( -- addr len len/2
000bc0 09ae          .dw XT_TUCK   ; ( -- addr len/2 len len/2
000bc1 0673          .dw XT_2STAR  ; ( -- addr len/2 len len'
000bc2 05fb          .dw XT_MINUS  ; ( -- addr len/2 rem
000bc3 0567          .dw XT_TO_R
000bc4 05bc          .dw XT_ZERO
000bc5 027a          .dw XT_QDOCHECK
000bc6 0496          .dw XT_DOCONDBRANCH
000bc7 0bcf          .dw PFA_SCOMMA2
000bc8 06f7          .dw XT_DODO
                 PFA_SCOMMA1:
000bc9 0519          .dw XT_DUP         ; ( -- addr addr )
000bca 04e1          .dw XT_FETCH       ; ( -- addr c1c2 )
000bcb 01bb          .dw XT_COMMA       ; ( -- addr )
000bcc 0995          .dw XT_CELLPLUS    ; ( -- addr+cell )
000bcd 0725          .dw XT_DOLOOP
000bce 0bc9          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
000bcf 055e          .dw XT_R_FROM
000bd0 0590          .dw XT_GREATERZERO
000bd1 0496          .dw XT_DOCONDBRANCH
000bd2 0bd6          .dw PFA_SCOMMA3
000bd3 0519            .dw XT_DUP     ; well, tricky
000bd4 0500            .dw XT_CFETCH
000bd5 01bb            .dw XT_COMMA
                 PFA_SCOMMA3:
000bd6 0541          .dw XT_DROP        ; ( -- )
000bd7 047d          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
000bd8 ff05          .dw $ff05
000bd9 7469
000bda 7079
000bdb 0065          .db "itype",0
000bdc 0bb5          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
000bdd 0108          .dw DO_COLON
                 PFA_ITYPE:
000bde 0519          .dw XT_DUP    ; ( --addr len len)
000bdf 066c          .dw XT_2SLASH ; ( -- addr len len/2
000be0 09ae          .dw XT_TUCK   ; ( -- addr len/2 len len/2
000be1 0673          .dw XT_2STAR  ; ( -- addr len/2 len len'
000be2 05fb          .dw XT_MINUS  ; ( -- addr len/2 rem
000be3 0567          .dw XT_TO_R
000be4 05bc          .dw XT_ZERO
000be5 027a          .dw XT_QDOCHECK
000be6 0496          .dw XT_DOCONDBRANCH
000be7 0bf1          .dw PFA_ITYPE2
000be8 06f7          .dw XT_DODO
                 PFA_ITYPE1:
000be9 0519          .dw XT_DUP         ; ( -- addr addr )
000bea 07ef          .dw XT_FETCHI      ; ( -- addr c1c2 )
000beb 0519          .dw XT_DUP
000bec 0bfe          .dw XT_LOWEMIT
000bed 0bfa          .dw XT_HIEMIT
000bee 0697          .dw XT_1PLUS    ; ( -- addr+cell )
000bef 0725          .dw XT_DOLOOP
000bf0 0be9          .dw PFA_ITYPE1
                 PFA_ITYPE2:
000bf1 055e          .dw XT_R_FROM
000bf2 0590          .dw XT_GREATERZERO
000bf3 0496          .dw XT_DOCONDBRANCH
000bf4 0bf8          .dw PFA_ITYPE3
000bf5 0519            .dw XT_DUP     ; make sure the drop below has always something to do
000bf6 07ef            .dw XT_FETCHI
000bf7 0bfe            .dw XT_LOWEMIT
                 PFA_ITYPE3:
000bf8 0541          .dw XT_DROP
000bf9 047d          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
000bfa 0108          .dw DO_COLON
                 PFA_HIEMIT:
000bfb 0755          .dw XT_BYTESWAP
000bfc 0bfe          .dw XT_LOWEMIT
000bfd 047d          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
000bfe 0108          .dw DO_COLON
                 PFA_LOWEMIT:
000bff 049d          .dw XT_DOLITERAL
000c00 00ff          .dw $00ff
000c01 067b          .dw XT_AND
000c02 09c6          .dw XT_EMIT
000c03 047d          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
000c04 ff06          .dw $ff06
000c05 6369
000c06 756f
000c07 746e          .db "icount"
000c08 0bd8          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
000c09 0108          .dw DO_COLON
                 PFA_ICOUNT:
000c0a 0519          .dw XT_DUP
000c0b 0697          .dw XT_1PLUS
000c0c 052c          .dw XT_SWAP
000c0d 07ef          .dw XT_FETCHI
000c0e 047d          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
000c0f ff02          .dw 0xff02
000c10 7263          .db "cr"
000c11 0c04          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
000c12 0108          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
000c13 049d          .dw XT_DOLITERAL
000c14 000d          .dw 13
000c15 09c6          .dw XT_EMIT
000c16 049d          .dw XT_DOLITERAL
000c17 000a          .dw 10
000c18 09c6          .dw XT_EMIT
000c19 047d          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
000c1a ff05          .dw $ff05
000c1b 7073
000c1c 6361
000c1d 0065          .db "space",0
000c1e 0c0f          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
000c1f 0108          .dw DO_COLON
                 PFA_SPACE:
                 .endif
000c20 0a28          .dw XT_BL
000c21 09c6          .dw XT_EMIT
000c22 047d          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
000c23 ff06          .dw $ff06
000c24 7073
000c25 6361
000c26 7365          .db "spaces"
000c27 0c1a          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
000c28 0108          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
000c29 05bc
000c2a 0aa7      	.DW XT_ZERO, XT_MAX
000c2b 0519
000c2c 0496      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
000c2d 0c32              DEST(SPCS2)
000c2e 0c1f
000c2f 069d
000c30 048c              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
000c31 0c2b              DEST(SPCS1)
000c32 0541
000c33 047d      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
000c34 ff04          .dw $ff04
000c35 7974
000c36 6570          .db "type"
000c37 0c23          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000c38 0108          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
000c39 11f5          .dw XT_BOUNDS
000c3a 027a          .dw XT_QDOCHECK
000c3b 0496          .dw XT_DOCONDBRANCH
000c3c 0c43          DEST(PFA_TYPE2)
000c3d 06f7          .dw XT_DODO
                 PFA_TYPE1:
000c3e 0708          .dw XT_I
000c3f 0500          .dw XT_CFETCH
000c40 09c6          .dw XT_EMIT
000c41 0725          .dw XT_DOLOOP
000c42 0c3e          DEST(PFA_TYPE1)
                 PFA_TYPE2:
000c43 047d          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
000c44 ff01          .dw $ff01
000c45 0027          .db "'",0
000c46 0c34          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000c47 0108          .dw DO_COLON
                 PFA_TICK:
                 .endif
000c48 0dea          .dw XT_PARSENAME
000c49 0ee7          .dw XT_DORECOGNIZER
000c4a 0f44          .dw XT_R_WORD
000c4b 1216          .dw XT_EQUAL
000c4c 0496          .dw XT_DOCONDBRANCH
000c4d 0c50          DEST(PFA_TICK1)
000c4e 0541          .dw XT_DROP
000c4f 047d          .dw XT_EXIT
                 PFA_TICK1:
000c50 049d          .dw XT_DOLITERAL
000c51 fff3          .dw -13
000c52 0c76          .dw XT_THROW
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
000c53 ff07          .dw $ff07
000c54 6168
000c55 646e
000c56 656c
000c57 0072          .db "handler",0
000c58 0c44          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
000c59 04be          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
000c5a 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
000c5b ff05          .dw $ff05
000c5c 6163
000c5d 6374
000c5e 0068          .db "catch",0
000c5f 0c53          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
000c60 0108          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
000c61 06e9          .dw XT_SP_FETCH
000c62 0567          .dw XT_TO_R
                     ; handler @ >r
000c63 0c59          .dw XT_HANDLER
000c64 04e1          .dw XT_FETCH
000c65 0567          .dw XT_TO_R
                     ; rp@ handler !
000c66 06d2          .dw XT_RP_FETCH
000c67 0c59          .dw XT_HANDLER
000c68 04e9          .dw XT_STORE
000c69 0487          .dw XT_EXECUTE
                     ; r> handler !
000c6a 055e          .dw XT_R_FROM
000c6b 0c59          .dw XT_HANDLER
000c6c 04e9          .dw XT_STORE
000c6d 055e          .dw XT_R_FROM
000c6e 0541          .dw XT_DROP
000c6f 05bc          .dw XT_ZERO
000c70 047d          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
000c71 ff05          .dw $ff05
000c72 6874
000c73 6f72
000c74 0077          .db "throw",0
000c75 0c5b          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
000c76 0108          .dw DO_COLON
                 PFA_THROW:
                 .endif
000c77 0519          .dw XT_DUP
000c78 0582          .dw XT_ZEROEQUAL
000c79 0496          .dw XT_DOCONDBRANCH
000c7a 0c7d          DEST(PFA_THROW1)
000c7b 0541      	.dw XT_DROP
000c7c 047d      	.dw XT_EXIT
                 PFA_THROW1:
000c7d 0c59          .dw XT_HANDLER
000c7e 04e1          .dw XT_FETCH
000c7f 06dc          .dw XT_RP_STORE
000c80 055e          .dw XT_R_FROM
000c81 0c59          .dw XT_HANDLER
000c82 04e9          .dw XT_STORE
000c83 055e          .dw XT_R_FROM
000c84 052c          .dw XT_SWAP
000c85 0567          .dw XT_TO_R
000c86 06f2          .dw XT_SP_STORE
000c87 0541          .dw XT_DROP
000c88 055e          .dw XT_R_FROM    
000c89 047d          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
000c8a ff05          .dw $ff05
000c8b 7363
000c8c 696b
000c8d 0070          .db "cskip",0
000c8e 0c71          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
000c8f 0108          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
000c90 0567          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
000c91 0519          .dw XT_DUP            ; ( -- addr' n' n' )
000c92 0496          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000c93 0c9e          DEST(PFA_CSKIP2)
000c94 0537          .dw XT_OVER           ; ( -- addr' n' addr' )
000c95 0500          .dw XT_CFETCH         ; ( -- addr' n' c' )
000c96 0570          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000c97 1216          .dw XT_EQUAL          ; ( -- addr' n' f )
000c98 0496          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000c99 0c9e          DEST(PFA_CSKIP2)
000c9a 121d          .dw XT_ONE
000c9b 0ddb          .dw XT_SLASHSTRING
000c9c 048c          .dw XT_DOBRANCH
000c9d 0c91          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
000c9e 055e          .dw XT_R_FROM
000c9f 0541          .dw XT_DROP           ; ( -- addr2 n2)
000ca0 047d          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
000ca1 ff05          .dw $ff05
000ca2 7363
000ca3 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
000ca4 006e          .db "cscan"
000ca5 0c8a          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
000ca6 0108          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
000ca7 0567          .dw XT_TO_R
000ca8 0537          .dw XT_OVER
                 PFA_CSCAN1:
000ca9 0519          .dw XT_DUP
000caa 0500          .dw XT_CFETCH
000cab 0570          .dw XT_R_FETCH
000cac 1216          .dw XT_EQUAL
000cad 0582          .dw XT_ZEROEQUAL
000cae 0496          .dw XT_DOCONDBRANCH
000caf 0cbb          DEST(PFA_CSCAN2)
000cb0 052c            .dw XT_SWAP
000cb1 069d            .dw XT_1MINUS
000cb2 052c            .dw XT_SWAP
000cb3 0537            .dw XT_OVER
000cb4 0589            .dw XT_ZEROLESS ; not negative
000cb5 0582            .dw XT_ZEROEQUAL
000cb6 0496            .dw XT_DOCONDBRANCH
000cb7 0cbb            DEST(PFA_CSCAN2)
000cb8 0697              .dw XT_1PLUS
000cb9 048c              .dw XT_DOBRANCH
000cba 0ca9              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
000cbb 0558          .dw XT_NIP
000cbc 0537          .dw XT_OVER
000cbd 05fb          .dw XT_MINUS
000cbe 055e          .dw XT_R_FROM
000cbf 0541          .dw XT_DROP
000cc0 047d          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
000cc1 ff06          .dw $ff06
000cc2 6361
000cc3 6563
000cc4 7470          .db "accept"
000cc5 0ca1          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000cc6 0108          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
000cc7 0537
000cc8 0605
000cc9 069d
000cca 0537              .DW XT_OVER,XT_PLUS,XT_1MINUS,XT_OVER
000ccb 09d7
000ccc 0519
000ccd 0d07
000cce 0582
000ccf 0496      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
000cd0 0cf9              DEST(ACC5)
000cd1 0519
000cd2 049d
000cd3 0008
000cd4 1216
000cd5 0496              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
000cd6 0ce9              DEST(ACC3)
000cd7 0541
000cd8 0549
000cd9 099d
000cda 05e0
000cdb 0567
000cdc 0549
000cdd 0549
000cde 055e
000cdf 0496              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
000ce0 0ce7      	DEST(ACC6)
000ce1 0cff
000ce2 069d
000ce3 0567
000ce4 0537
000ce5 055e
000ce6 014c      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
000ce7 048c      ACC6:   .DW XT_DOBRANCH
000ce8 0cf7              DEST(ACC4)
                     
                 
                 ACC3:    ; check for remaining control characters, replace them with blank
000ce9 0519      	.dw XT_DUP            ; ( -- addr k k )
000cea 0a28              .dw XT_BL
000ceb 05d6              .dw XT_LESS
000cec 0496              .dw XT_DOCONDBRANCH
000ced 0cf0              DEST(PFA_ACCEPT6)
000cee 0541              .dw XT_DROP
000cef 0a28              .dw XT_BL
                 PFA_ACCEPT6:
000cf0 0519
000cf1 09c6
000cf2 0537
000cf3 04f5
000cf4 0697
000cf5 0537
000cf6 0158      	.DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
000cf7 048c      ACC4:   .DW XT_DOBRANCH
000cf8 0ccb              DEST(ACC1)
000cf9 0541
000cfa 0558
000cfb 052c
000cfc 05fb
000cfd 0c12
000cfe 047d      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_CR,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
000cff 0108          .dw DO_COLON
                 .endif
000d00 049d          .dw XT_DOLITERAL
000d01 0008          .dw 8
000d02 0519          .dw XT_DUP
000d03 09c6          .dw XT_EMIT
000d04 0c1f          .dw XT_SPACE
000d05 09c6          .dw XT_EMIT
000d06 047d          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
000d07 0108          .dw DO_COLON
                 .endif
000d08 0519          .dw XT_DUP
000d09 049d          .dw XT_DOLITERAL
000d0a 000d          .dw 13
000d0b 1216          .dw XT_EQUAL
000d0c 052c          .dw XT_SWAP
000d0d 049d          .dw XT_DOLITERAL
000d0e 000a          .dw 10
000d0f 1216          .dw XT_EQUAL
000d10 0684          .dw XT_OR
000d11 047d          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILL:
000d12 ff06          .dw $ff06
000d13 6572
000d14 6966
000d15 6c6c          .db "refill"
000d16 0cc1          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
000d17 1022          .dw PFA_DODEFER1
                 PFA_REFILL:
                 .endif
000d18 001a          .dw USER_REFILL
000d19 0feb          .dw XT_UDEFERFETCH
000d1a 0ff7          .dw XT_UDEFERSTORE
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
000d1b ff04          .dw $ff04
000d1c 6863
000d1d 7261          .db "char"
000d1e 0d12          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
000d1f 0108          .dw DO_COLON
                 PFA_CHAR:
                 .endif
000d20 0dea          .dw XT_PARSENAME
000d21 0541          .dw XT_DROP
000d22 0500          .dw XT_CFETCH
000d23 047d          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
000d24 ff06          .dw $ff06
000d25 756e
000d26 626d
000d27 7265          .db "number"
000d28 0d1b          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
000d29 0108          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
000d2a 0988          .dw XT_BASE
000d2b 04e1          .dw XT_FETCH
000d2c 0567          .dw XT_TO_R
000d2d 0d6d          .dw XT_QSIGN
000d2e 0567          .dw XT_TO_R
000d2f 0d80          .dw XT_SET_BASE
000d30 0d6d          .dw XT_QSIGN
000d31 055e          .dw XT_R_FROM
000d32 0684          .dw XT_OR
000d33 0567          .dw XT_TO_R
                     ; check whether something is left
000d34 0519          .dw XT_DUP
000d35 0582          .dw XT_ZEROEQUAL
000d36 0496          .dw XT_DOCONDBRANCH
000d37 0d40          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
000d38 09a6            .dw XT_2DROP
000d39 055e            .dw XT_R_FROM
000d3a 0541            .dw XT_DROP
000d3b 055e            .dw XT_R_FROM
000d3c 0988            .dw XT_BASE
000d3d 04e9            .dw XT_STORE
000d3e 05bc            .dw XT_ZERO
000d3f 047d            .dw XT_EXIT
                 PFA_NUMBER0:
000d40 077b          .dw XT_2TO_R
000d41 05bc          .dw XT_ZERO       ; starting value
000d42 05bc          .dw XT_ZERO
000d43 078a          .dw XT_2R_FROM
000d44 0d9e          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
000d45 0521          .dw XT_QDUP
000d46 0496          .dw XT_DOCONDBRANCH
000d47 0d62          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
000d48 121d          .dw XT_ONE
000d49 1216          .dw XT_EQUAL
000d4a 0496          .dw XT_DOCONDBRANCH
000d4b 0d59          DEST(PFA_NUMBER2)
                 	; excatly one character is left
000d4c 0500      	.dw XT_CFETCH
000d4d 049d      	.dw XT_DOLITERAL
000d4e 002e      	.dw 46 ; .
000d4f 1216      	.dw XT_EQUAL
000d50 0496      	.dw XT_DOCONDBRANCH
000d51 0d5a      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
000d52 055e      	.dw XT_R_FROM
000d53 0496              .dw XT_DOCONDBRANCH
000d54 0d56      	DEST(PFA_NUMBER3)
000d55 10f0              .dw XT_DNEGATE
                 PFA_NUMBER3:
000d56 1222      	.dw XT_TWO
000d57 048c      	.dw XT_DOBRANCH
000d58 0d68      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
000d59 0541      	.dw XT_DROP
                 PFA_NUMBER6:
000d5a 09a6      	.dw XT_2DROP
000d5b 055e      	.dw XT_R_FROM
000d5c 0541      	.dw XT_DROP
000d5d 055e              .dw XT_R_FROM
000d5e 0988              .dw XT_BASE
000d5f 04e9              .dw XT_STORE
000d60 05bc      	.dw XT_ZERO
000d61 047d      	.dw XT_EXIT
                 PFA_NUMBER1:
000d62 09a6          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
000d63 055e          .dw XT_R_FROM
000d64 0496          .dw XT_DOCONDBRANCH
000d65 0d67          DEST(PFA_NUMBER4)
000d66 0a78          .dw XT_NEGATE
                 PFA_NUMBER4:
000d67 121d          .dw XT_ONE
                 PFA_NUMBER5:
000d68 055e          .dw XT_R_FROM
000d69 0988          .dw XT_BASE
000d6a 04e9          .dw XT_STORE
000d6b 05b3          .dw XT_TRUE
000d6c 047d          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
000d6d 0108          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
000d6e 0537          .dw XT_OVER    ; ( -- addr len addr )
000d6f 0500          .dw XT_CFETCH
000d70 049d          .dw XT_DOLITERAL
000d71 002d          .dw '-'
000d72 1216          .dw XT_EQUAL  ; ( -- addr len flag )
000d73 0519          .dw XT_DUP
000d74 0567          .dw XT_TO_R
000d75 0496          .dw XT_DOCONDBRANCH
000d76 0d79          DEST(PFA_NUMBERSIGN_DONE)
000d77 121d          .dw XT_ONE    ; skip sign character
000d78 0ddb          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
000d79 055e          .dw XT_R_FROM
000d7a 047d          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
000d7b 04b8          .dw PFA_DOCONSTANT
                 .endif
000d7c 000a
000d7d 0010
000d7e 0002
000d7f 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
000d80 0108          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
000d81 0537          .dw XT_OVER
000d82 0500          .dw XT_CFETCH
000d83 049d          .dw XT_DOLITERAL
000d84 0023          .dw 35
000d85 05fb          .dw XT_MINUS
000d86 0519          .dw XT_DUP
000d87 05bc          .dw XT_ZERO
000d88 049d          .dw XT_DOLITERAL
000d89 0004          .dw 4
000d8a 0ab4          .dw XT_WITHIN
000d8b 0496          .dw XT_DOCONDBRANCH
000d8c 0d96          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
000d8d 0d7b      	.dw XT_BASES
000d8e 0605      	.dw XT_PLUS
000d8f 07ef      	.dw XT_FETCHI
000d90 0988      	.dw XT_BASE
000d91 04e9      	.dw XT_STORE
000d92 121d      	.dw XT_ONE
000d93 0ddb      	.dw XT_SLASHSTRING
000d94 048c      	.dw XT_DOBRANCH
000d95 0d97      	DEST(SET_BASE2)
                 SET_BASE1:
000d96 0541      	.dw XT_DROP
                 SET_BASE2:
000d97 047d          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
000d98 ff07          .dw $ff07
000d99 6e3e
000d9a 6d75
000d9b 6562
000d9c 0072          .db ">number",0
000d9d 0d24          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
000d9e 0108          .dw DO_COLON
                 
                 .endif
                 
000d9f 0519
000da0 0496      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
000da1 0db7              DEST(TONUM3)
000da2 0537
000da3 0500
000da4 0b90              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
000da5 0582
000da6 0496              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
000da7 0daa              DEST(TONUM2)
000da8 0541
000da9 047d              .DW XT_DROP,XT_EXIT
000daa 0567
000dab 1115
000dac 0988
000dad 04e1
000dae 013d      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
000daf 055e
000db0 0135
000db1 1115              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
000db2 049d
000db3 0001
000db4 0ddb
000db5 048c              .DW XT_DOLITERAL,1,XT_SLASHSTRING,XT_DOBRANCH
000db6 0d9f              DEST(TONUM1)
000db7 047d      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
000db8 ff05          .dw $ff05
000db9 6170
000dba 7372
000dbb 0065          .db "parse",0
000dbc 0d98          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
000dbd 0108          .dw DO_COLON
                 PFA_PARSE:
                 .endif
000dbe 0567          .dw XT_TO_R     ; ( -- )
000dbf 0dd1          .dw XT_SOURCE   ; ( -- addr len)
000dc0 09b6          .dw XT_TO_IN     ; ( -- addr len >in)
000dc1 04e1          .dw XT_FETCH
000dc2 0ddb          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
000dc3 055e          .dw XT_R_FROM      ; ( -- addr' len' c)
000dc4 0ca6          .dw XT_CSCAN       ; ( -- addr' len'')
000dc5 0519          .dw XT_DUP         ; ( -- addr' len'' len'')
000dc6 0697          .dw XT_1PLUS
000dc7 09b6          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
000dc8 06c1          .dw XT_PLUSSTORE   ; ( -- addr' len')
000dc9 121d          .dw XT_ONE
000dca 0ddb          .dw XT_SLASHSTRING
000dcb 047d          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCE:
000dcc ff06          .dw $FF06
000dcd 6f73
000dce 7275
000dcf 6563          .db "source"
000dd0 0db8          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
000dd1 1022          .dw PFA_DODEFER1
                 PFA_SOURCE:
                 .endif
000dd2 0016          .dw USER_SOURCE
000dd3 0feb          .dw XT_UDEFERFETCH
000dd4 0ff7          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
000dd5 ff07          .dw $ff07
000dd6 732f
000dd7 7274
000dd8 6e69
000dd9 0067          .db "/string",0
000dda 0dcc          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
000ddb 0108          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
000ddc 0549          .dw XT_ROT
000ddd 0537          .dw XT_OVER
000dde 0605          .dw XT_PLUS
000ddf 0549          .dw XT_ROT
000de0 0549          .dw XT_ROT
000de1 05fb          .dw XT_MINUS
000de2 047d          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
000de3 ff0a          .dw $FF0A 
000de4 6170
000de5 7372
000de6 2d65
000de7 616e
000de8 656d          .db "parse-name"
000de9 0dd5          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
000dea 0108          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
000deb 0a28          .dw XT_BL
000dec 0dee          .dw XT_SKIPSCANCHAR
000ded 047d          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
000dee 0108          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
000def 0567          .dw XT_TO_R
000df0 0dd1          .dw XT_SOURCE 
000df1 09b6          .dw XT_TO_IN 
000df2 04e1          .dw XT_FETCH 
000df3 0ddb          .dw XT_SLASHSTRING 
                 
000df4 0570          .dw XT_R_FETCH
000df5 0c8f          .dw XT_CSKIP
000df6 055e          .dw XT_R_FROM
000df7 0ca6          .dw XT_CSCAN
                 
                     ; adjust >IN
000df8 099d          .dw XT_2DUP
000df9 0605          .dw XT_PLUS
000dfa 0dd1          .dw XT_SOURCE 
000dfb 0541          .dw XT_DROP
000dfc 05fb          .dw XT_MINUS
000dfd 09b6          .dw XT_TO_IN
000dfe 04e9          .dw XT_STORE
000dff 047d          .dw XT_EXIT
                 .include "words/find-name.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the name from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDNAME:
000e00 ff09          .dw $ff09
000e01 6966
000e02 646e
000e03 6e2d
000e04 6d61
000e05 0065          .db "find-name",0
000e06 0de3          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDNAME
                 XT_FINDNAME:
000e07 0108          .dw DO_COLON
                 PFA_FINDNAME:
                 .endif
000e08 049d          .dw XT_DOLITERAL
000e09 0e13          .dw XT_FINDNAMEA
000e0a 049d          .dw XT_DOLITERAL
000e0b 0086          .dw CFG_ORDERLISTLEN
000e0c 03f4          .dw XT_MAPSTACK
000e0d 0582          .dw XT_ZEROEQUAL
000e0e 0496          .dw XT_DOCONDBRANCH
000e0f 0e12          DEST(PFA_FINDNAME1)
000e10 09a6            .dw XT_2DROP
000e11 05bc            .dw XT_ZERO
                 PFA_FINDNAME1:
000e12 047d          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDNAMEA:
000e13 0108          .dw DO_COLON
                 PFA_FINDNAMEA:
                 .endif
000e14 0567          .dw XT_TO_R
000e15 099d          .dw XT_2DUP
000e16 055e          .dw XT_R_FROM
000e17 1034          .dw XT_SEARCH_WORDLIST
000e18 0519          .dw XT_DUP
000e19 0496          .dw XT_DOCONDBRANCH
000e1a 0e20          DEST(PFA_FINDNAMEA1)
000e1b 0567            .dw XT_TO_R
000e1c 0558            .dw XT_NIP
000e1d 0558            .dw XT_NIP
000e1e 055e            .dw XT_R_FROM
000e1f 05b3            .dw XT_TRUE
                 PFA_FINDNAMEA1:
000e20 047d          .dw XT_EXIT
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000e21 0108          .dw DO_COLON
                 PFA_PROMPTOK:
000e22 0baa          .dw XT_DOSLITERAL
000e23 0003          .dw 3
000e24 6f20
000e25 006b          .db " ok",0
                 .endif
000e26 0bdd          .dw XT_ITYPE
000e27 047d          .dw XT_EXIT
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_PROMPTREADY:
000e28 0108          .dw DO_COLON
                 PFA_PROMPTREADY:
000e29 0baa          .dw XT_DOSLITERAL
000e2a 0002          .dw 2
000e2b 203e          .db "> "
                 .endif
000e2c 0c12          .dw XT_CR
000e2d 0bdd          .dw XT_ITYPE
000e2e 047d          .dw XT_EXIT
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
000e2f 0108          .dw DO_COLON
                 PFA_PROMPTERROR:
000e30 0baa      	.dw XT_DOSLITERAL
000e31 0004          .dw 4
000e32 3f20
000e33 203f          .db " ?? "
                 .endif
000e34 0bdd          .dw XT_ITYPE
000e35 0988          .dw XT_BASE
000e36 04e1          .dw XT_FETCH
000e37 0567          .dw XT_TO_R
000e38 0a15          .dw XT_DECIMAL
000e39 0b5f          .dw XT_DOT
000e3a 09b6          .dw XT_TO_IN
000e3b 04e1          .dw XT_FETCH
000e3c 0b5f          .dw XT_DOT
000e3d 055e          .dw XT_R_FROM
000e3e 0988          .dw XT_BASE
000e3f 04e9          .dw XT_STORE
000e40 047d          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
000e41 ff04          .dw $ff04
000e42 7571
000e43 7469          .db "quit"
000e44 0e00          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
000e45 0108          .dw DO_COLON
                 PFA_QUIT:
                 .endif
                 PFA_QUIT1:
000e46 02b0
000e47 02b7
000e48 04e9          .dw XT_LP0,XT_LP,XT_STORE
000e49 0ea6          .dw XT_SP0
000e4a 06f2          .dw XT_SP_STORE
000e4b 0eb3          .dw XT_RP0
000e4c 06dc          .dw XT_RP_STORE
000e4d 0345          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000e4e 0982          .dw XT_STATE
000e4f 04e1          .dw XT_FETCH
000e50 0582          .dw XT_ZEROEQUAL
000e51 0496          .dw XT_DOCONDBRANCH
000e52 0e54          DEST(PFA_QUIT4)
000e53 0e28          .dw XT_PROMPTREADY
                 PFA_QUIT4:
000e54 0d17          .dw XT_REFILL
000e55 0496          .dw XT_DOCONDBRANCH
000e56 0e4e          DEST(PFA_QUIT2)
000e57 049d          .dw XT_DOLITERAL
000e58 0ecc          .dw XT_INTERPRET
000e59 0c60          .dw XT_CATCH
000e5a 0521          .dw XT_QDUP
000e5b 0496          .dw XT_DOCONDBRANCH
000e5c 0e66          DEST(PFA_QUIT3)
000e5d 0519      	.dw XT_DUP
000e5e 049d      	.dw XT_DOLITERAL
000e5f fffe      	.dw -2
000e60 05d6      	.dw XT_LESS
000e61 0496      	.dw XT_DOCONDBRANCH
000e62 0e64      	DEST(PFA_QUIT5)
000e63 0e2f      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000e64 048c      	.dw XT_DOBRANCH
000e65 0e46      	DEST(PFA_QUIT1)
                 PFA_QUIT3:
000e66 0e21          .dw XT_PROMPTOK
000e67 048c          .dw XT_DOBRANCH
000e68 0e4e          DEST(PFA_QUIT2)
000e69 047d          .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000e6a ff05          .dw $ff05
000e6b 6170
000e6c 7375
000e6d 0065          .db "pause",0
000e6e 0e41          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000e6f 1022          .dw PFA_DODEFER1
                 PFA_PAUSE:
000e70 0223          .dw ram_pause
000e71 0fd7          .dw XT_RDEFERFETCH
000e72 0fe1          .dw XT_RDEFERSTORE
                 
                 .dseg
000223           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000e73 ff04          .dw $ff04
000e74 6f63
000e75 646c          .db "cold"
000e76 0e6a          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000e77 0e78          .dw PFA_COLD
                 PFA_COLD:
000e78 b6a4          in_ mcu_boot, MCUSR
000e79 2422          clr zerol
000e7a 2433          clr zeroh
000e7b be24          out_ MCUSR, zerol
                     ; clear RAM
000e7c e0e0          ldi zl, low(ramstart)
000e7d e0f2          ldi zh, high(ramstart)
                 clearloop:
000e7e 9221          st Z+, zerol
000e7f 30e0          cpi zl, low(sram_size+ramstart)
000e80 f7e9          brne clearloop
000e81 32f2          cpi zh, high(sram_size+ramstart)
000e82 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000225           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000e83 e2e5          ldi zl, low(ram_user1)
000e84 e0f2          ldi zh, high(ram_user1)
000e85 012f          movw upl, zl
                     ; init return stack pointer
000e86 ef0f          ldi temp0,low(rstackstart)
000e87 bf0d          out_ SPL,temp0
000e88 8304          std Z+4, temp0
000e89 e211          ldi temp1,high(rstackstart)
000e8a bf1e          out_ SPH,temp1
000e8b 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000e8c eacf          ldi yl,low(stackstart)
000e8d 83c6          std Z+6, yl
000e8e e2d1          ldi yh,high(stackstart)
000e8f 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000e90 e9a9          ldi XL, low(PFA_WARM)
000e91 e0be          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000e92 940c 010c     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WARM:
000e94 ff04          .dw $ff04
000e95 6177
000e96 6d72          .db "warm"
000e97 0e73          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000e98 0108          .dw DO_COLON
                 PFA_WARM:
                 .endif
000e99 1160          .dw XT_INIT_RAM
000e9a 049d          .dw XT_DOLITERAL
000e9b 0f8e          .dw XT_NOOP
000e9c 049d          .dw XT_DOLITERAL
000e9d 0e6f          .dw XT_PAUSE
000e9e 1002          .dw XT_DEFERSTORE
000e9f 0345          .dw XT_LBRACKET
000ea0 0a30          .dw XT_TURNKEY
000ea1 0e45          .dw XT_QUIT     ; never returns
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000ea2 ff03          .dw $ff03
000ea3 7073
000ea4 0030          .db "sp0",0
000ea5 0e94          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
000ea6 04d8          .dw PFA_DOVALUE1
                 PFA_SP0:
000ea7 0006          .dw USER_SP0
000ea8 0feb          .dw XT_UDEFERFETCH
000ea9 0ff7          .dw XT_UDEFERSTORE
                 
                 ; ( -- addr) 
                 ; Stack
                 ; address of user variable to store top-of-stack for inactive tasks
                 VE_SP:
000eaa ff02          .dw $ff02
000eab 7073          .db "sp"
000eac 0ea2          .dw VE_HEAD
                     .set VE_HEAD = VE_SP
                 XT_SP:
000ead 04be          .dw PFA_DOUSER
                 PFA_SP:
000eae 0008          .dw USER_SP
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000eaf ff03          .dw $ff03
000eb0 7072
000eb1 0030          .db "rp0",0
000eb2 0eaa          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
000eb3 0108          .dw DO_COLON
                 PFA_RP0:
000eb4 0eb7          .dw XT_DORP0
000eb5 04e1          .dw XT_FETCH
000eb6 047d          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
000eb7 04be          .dw PFA_DOUSER
                 PFA_DORP0:
000eb8 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
000eb9 ff05          .dw $ff05
000eba 6564
000ebb 7470
000ebc 0068          .db "depth",0
000ebd 0eaf          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
000ebe 0108          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
000ebf 0ea6          .dw XT_SP0
000ec0 06e9          .dw XT_SP_FETCH
000ec1 05fb          .dw XT_MINUS
000ec2 066c          .dw XT_2SLASH
000ec3 069d          .dw XT_1MINUS
000ec4 047d          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
000ec5 ff09          .dw $ff09
000ec6 6e69
000ec7 6574
000ec8 7072
000ec9 6572
000eca 0074          .db "interpret",0
000ecb 0eb9          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000ecc 0108          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
000ecd 0dea          .dw XT_PARSENAME ; ( -- addr len )
000ece 0519          .dw XT_DUP   ; ( -- addr len flag)
000ecf 0496          .dw XT_DOCONDBRANCH
000ed0 0edc          DEST(PFA_INTERPRET2)
000ed1 0ee7            .dw XT_DORECOGNIZER
000ed2 0982            .dw XT_STATE
000ed3 04e1            .dw XT_FETCH
000ed4 0496            .dw XT_DOCONDBRANCH
000ed5 0ed7          DEST(PFA_INTERPRET1)
000ed6 0fba            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
000ed7 07ef            .dw XT_FETCHI
000ed8 0487            .dw XT_EXECUTE
000ed9 0f66            .dw XT_QSTACK
000eda 048c          .dw XT_DOBRANCH
000edb 0ecd          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
000edc 09a6          .dw XT_2DROP
000edd 047d          .dw XT_EXIT
                 .include "words/do-recognizer.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DORECOGNIZER:
000ede ff0d          .dw $ff0d
000edf 6f64
000ee0 722d
000ee1 6365
000ee2 676f
000ee3 696e
000ee4 657a
000ee5 0072          .db "do-recognizer",0
000ee6 0ec5          .dw VE_HEAD
                     .set VE_HEAD = VE_DORECOGNIZER
                 XT_DORECOGNIZER:
000ee7 0108          .dw DO_COLON
                 PFA_DORECOGNIZER:
                 .endif
000ee8 049d          .dw XT_DOLITERAL
000ee9 0ef3          .dw XT_DORECOGNIZER_A
000eea 049d          .dw XT_DOLITERAL
000eeb 0098          .dw CFG_RECOGNIZERLISTLEN
000eec 03f4          .dw XT_MAPSTACK
000eed 0582          .dw XT_ZEROEQUAL
000eee 0496          .dw XT_DOCONDBRANCH
000eef 0ef2          DEST(PFA_DORECOGNIZER1)
000ef0 09a6            .dw XT_2DROP
000ef1 0f59            .dw XT_R_FAIL
                 PFA_DORECOGNIZER1:
000ef2 047d          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ; ( addr len XT -- addr len [ r:table -1 | 0 ] )
                 XT_DORECOGNIZER_A:
000ef3 0108         .dw DO_COLON
                 PFA_DORECOGNIZER_A:
                 .endif
000ef4 0549         .dw XT_ROT  ; -- len xt addr
000ef5 0549         .dw XT_ROT  ; -- xt addr len
000ef6 099d         .dw XT_2DUP 
000ef7 077b         .dw XT_2TO_R
000ef8 0549         .dw XT_ROT  ; -- addr len xt
000ef9 0487         .dw XT_EXECUTE ; -- i*x r:foo | r:fail
000efa 078a         .dw XT_2R_FROM
000efb 0549         .dw XT_ROT
000efc 0519         .dw XT_DUP
000efd 0f59         .dw XT_R_FAIL
000efe 1216         .dw XT_EQUAL
000eff 0496         .dw XT_DOCONDBRANCH
000f00 0f04         DEST(PFA_DORECOGNIZER_A1)
000f01 0541           .dw XT_DROP
000f02 05bc           .dw XT_ZERO
000f03 047d           .dw XT_EXIT
                 PFA_DORECOGNIZER_A1:
000f04 0558         .dw XT_NIP 
000f05 0558         .dw XT_NIP
000f06 05b3         .dw XT_TRUE
000f07 047d         .dw XT_EXIT
                 
                 ; : do-recognizer ( addr len -- i*x r:table|r:fail )
                 ;    \ ( addr len -- addr len 0 | i*x r:table -1 )
                 ;    [: rot rot 2dup 2>r rot execute 2r> rot 
                 ;          dup r:fail = ( -- addr len r:table f )
                 ;          if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    EE_RECOGNIZERLISTLEN map-stack ( -- i*x addr len r:table f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop r:fail 
                 ;    then
                 ;
                 .include "words/r-intnumber.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_NUM:
000f08 ff05          .dw $ff05
000f09 3a72
000f0a 756e
000f0b 006d          .db "r:num",0
000f0c 0ede          .dw VE_HEAD
                     .set VE_HEAD = VE_R_NUM
                 XT_R_NUM:
000f0d 04b8          .dw PFA_DOCONSTANT
                 PFA_R_NUM:
                 .endif
000f0e 0f8e          .dw XT_NOOP    ; interpret
000f0f 01d1          .dw XT_LITERAL ; compile
000f10 01d1          .dw XT_LITERAL ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_DNUM:
000f11 ff06          .dw $ff06
000f12 3a72
000f13 6e64
000f14 6d75          .db "r:dnum"
000f15 0f08          .dw VE_HEAD
                     .set VE_HEAD = VE_R_DNUM
                 XT_R_DNUM:
000f16 04b8          .dw PFA_DOCONSTANT
                 PFA_R_DNUM:
                 .endif
000f17 0f8e          .dw XT_NOOP     ; interpret
000f18 120e          .dw XT_2LITERAL ; compile
000f19 120e          .dw XT_2LITERAL ; postpone
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
000f1a ff07          .dw $ff07
000f1b 6572
000f1c 3a63
000f1d 756e
000f1e 006d          .db "rec:num",0
000f1f 0f11          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
000f20 0108          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
000f21 0d29          .dw XT_NUMBER
000f22 0496          .dw XT_DOCONDBRANCH
000f23 0f2c          DEST(PFA_REC_NONUMBER)
000f24 121d          .dw XT_ONE
000f25 1216          .dw XT_EQUAL
000f26 0496          .dw XT_DOCONDBRANCH
000f27 0f2a          DEST(PFA_REC_INTNUM2)
000f28 0f0d            .dw XT_R_NUM
000f29 047d            .dw XT_EXIT
                 PFA_REC_INTNUM2:
000f2a 0f16            .dw XT_R_DNUM
000f2b 047d            .dw XT_EXIT
                 PFA_REC_NONUMBER:
000f2c 0f59          .dw XT_R_FAIL
000f2d 047d          .dw XT_EXIT
                 .include "words/r-word.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_WORD:
000f2e ff08          .dw $ff08
000f2f 6572
000f30 3a63
000f31 6f77
000f32 6472          .db "rec:word"
000f33 0f1a          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_WORD
                 XT_REC_WORD:
000f34 0108          .dw DO_COLON
                 PFA_REC_WORD:
                 .endif
000f35 0e07          .DW XT_FINDNAME
000f36 0519          .dw XT_DUP
000f37 0582          .dw XT_ZEROEQUAL
000f38 0496          .dw XT_DOCONDBRANCH
000f39 0f3d          DEST(PFA_REC_WORD_FOUND)
000f3a 0541              .dw XT_DROP
000f3b 0f59      	.dw XT_R_FAIL
000f3c 047d      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
000f3d 0f44          .dw XT_R_WORD
                 
000f3e 047d          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_WORD:
000f3f ff06          .dw $ff06
000f40 3a72
000f41 6f77
000f42 6472          .db "r:word"
000f43 0f2e          .dw VE_HEAD
                     .set VE_HEAD = VE_R_WORD
                 XT_R_WORD:
000f44 04b8          .dw PFA_DOCONSTANT
                 PFA_R_WORD:
                 .endif
000f45 0f48          .dw XT_R_WORD_INTERPRET
000f46 0f4c          .dw XT_R_WORD_COMPILE
000f47 120e          .dw XT_2LITERAL
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
000f48 0108          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
000f49 0541          .dw XT_DROP ; the flags are in the way
000f4a 0487          .dw XT_EXECUTE
000f4b 047d          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
000f4c 0108          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
000f4d 0589          .dw XT_ZEROLESS
000f4e 0496          .dw XT_DOCONDBRANCH
000f4f 0f52          DEST(PFA_R_WORD_COMPILE1)
000f50 01bb      	.dw XT_COMMA
000f51 047d              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
000f52 0487              .dw XT_EXECUTE
000f53 047d          .dw XT_EXIT
                 .include "words/r-fail.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_R_FAIL:
000f54 ff06          .dw $ff06
000f55 3a72
000f56 6166
000f57 6c69          .db "r:fail"
000f58 0f3f          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FAIL
                 XT_R_FAIL:
000f59 04b8          .dw PFA_DOCONSTANT
                 PFA_R_FAIL:
                 .endif
000f5a 0f5d          .dw XT_FAIL  ; interpret
000f5b 0f5d          .dw XT_FAIL  ; compile
000f5c 0f5d          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
000f5d 0108          .dw DO_COLON
                 PFA_FAIL:
                 .endif
000f5e 049d          .dw XT_DOLITERAL
000f5f fff3          .dw -13
000f60 0c76          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
000f61 ff06          .dw $ff06
000f62 733f
000f63 6174
000f64 6b63          .db "?stack"
000f65 0f54          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000f66 0108          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
000f67 0ebe          .dw XT_DEPTH
000f68 0589          .dw XT_ZEROLESS
000f69 0496          .dw XT_DOCONDBRANCH
000f6a 0f6e          DEST(PFA_QSTACK1)
000f6b 049d            .dw XT_DOLITERAL
000f6c fffc            .dw -4
000f6d 0c76            .dw XT_THROW
                 PFA_QSTACK1:
000f6e 047d          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
000f6f ff03          .dw $ff03
000f70 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
000f71 0072          .db "ver"
000f72 0f61          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
000f73 0108          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
000f74 0944          .dw XT_ENV_FORTHNAME
000f75 0bdd          .dw XT_ITYPE
000f76 0c1f          .dw XT_SPACE
000f77 0988          .dw XT_BASE
000f78 04e1          .dw XT_FETCH
                 
000f79 0952          .dw XT_ENV_FORTHVERSION
000f7a 0a15          .dw XT_DECIMAL
000f7b 11fe          .dw XT_S2D
000f7c 0afb          .dw XT_L_SHARP
000f7d 0b03          .dw XT_SHARP
000f7e 049d          .dw XT_DOLITERAL
000f7f 002e          .dw '.'
000f80 0aec          .dw XT_HOLD
000f81 0b19          .dw XT_SHARP_S
000f82 0b24          .dw XT_SHARP_G
000f83 0c38          .dw XT_TYPE
000f84 0988          .dw XT_BASE
000f85 04e9          .dw XT_STORE
000f86 0c1f          .dw XT_SPACE
000f87 095a          .dw XT_ENV_CPU
000f88 0bdd          .dw XT_ITYPE
                 
000f89 047d          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOOP:
000f8a ff04          .dw $ff04
000f8b 6f6e
000f8c 706f          .db "noop"
000f8d 0f6f          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000f8e 0108          .dw DO_COLON
                 PFA_NOOP:
                 .endif
000f8f 047d         .DW XT_EXIT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000f90 ff06          .dw $ff06
000f91 6e75
000f92 7375
000f93 6465          .db "unused"
000f94 0f8a          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000f95 0108          .dw DO_COLON
                 PFA_UNUSED:
000f96 06e9          .dw XT_SP_FETCH
000f97 09f7          .dw XT_HERE
000f98 05fb          .dw XT_MINUS
000f99 047d          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
000f9a 0002          .dw $0002
000f9b 6f74          .db "to"
000f9c 0f90          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000f9d 0108          .dw DO_COLON
                 PFA_TO:
                 .endif
000f9e 0c47          .dw XT_TICK
000f9f 1207          .dw XT_TO_BODY
000fa0 0982          .dw XT_STATE
000fa1 04e1          .dw XT_FETCH
000fa2 0496          .dw XT_DOCONDBRANCH
000fa3 0fae          DEST(PFA_TO1)
000fa4 01b0          .dw XT_COMPILE
000fa5 0fa8          .dw XT_DOTO
000fa6 01bb          .dw XT_COMMA
000fa7 047d          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
000fa8 0108          .dw DO_COLON
                 PFA_DOTO:
                 .endif
000fa9 055e          .dw XT_R_FROM
000faa 0519          .dw XT_DUP
000fab 0fba          .dw XT_ICELLPLUS
000fac 0567          .dw XT_TO_R
000fad 07ef          .dw XT_FETCHI
                 PFA_TO1:
000fae 0519          .dw XT_DUP
000faf 0fba          .dw XT_ICELLPLUS
000fb0 0fba          .dw XT_ICELLPLUS
000fb1 07ef          .dw XT_FETCHI
000fb2 0487          .dw XT_EXECUTE
000fb3 047d          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
000fb4 ff07          .dw $FF07
000fb5 2d69
000fb6 6563
000fb7 6c6c
000fb8 002b          .db "i-cell+",0
000fb9 0f9a          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
000fba 0108          .dw DO_COLON
                 PFA_ICELLPLUS:
000fbb 0697          .dw XT_1PLUS
000fbc 047d          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
000fbd ff07          .dw $ff07
000fbe 6445
000fbf 6665
000fc0 7265
000fc1 0040          .db "Edefer@",0
000fc2 0fb4          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
000fc3 0108          .dw DO_COLON
                 PFA_EDEFERFETCH:
000fc4 07ef          .dw XT_FETCHI
000fc5 07bc          .dw XT_FETCHE
000fc6 047d          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
000fc7 ff07          .dw $ff07
000fc8 6445
000fc9 6665
000fca 7265
000fcb 0021          .db "Edefer!",0
000fcc 0fbd          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
000fcd 0108          .dw DO_COLON
                 PFA_EDEFERSTORE:
000fce 07ef          .dw XT_FETCHI
000fcf 0798          .dw XT_STOREE
000fd0 047d          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
000fd1 ff07          .dw $ff07
000fd2 6452
000fd3 6665
000fd4 7265
000fd5 0040          .db "Rdefer@",0
000fd6 0fc7          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
000fd7 0108          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
000fd8 07ef          .dw XT_FETCHI
000fd9 04e1          .dw XT_FETCH
000fda 047d          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
000fdb ff07          .dw $ff07
000fdc 6452
000fdd 6665
000fde 7265
000fdf 0021          .db "Rdefer!",0
000fe0 0fd1          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
000fe1 0108          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
000fe2 07ef          .dw XT_FETCHI
000fe3 04e9          .dw XT_STORE
000fe4 047d          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
000fe5 ff07          .dw $ff07
000fe6 6455
000fe7 6665
000fe8 7265
000fe9 0040          .db "Udefer@",0
000fea 0fdb          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
000feb 0108          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
000fec 07ef          .dw XT_FETCHI
000fed 075e          .dw XT_UP_FETCH
000fee 0605          .dw XT_PLUS
000fef 04e1          .dw XT_FETCH
000ff0 047d          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
000ff1 ff07          .dw $ff07
000ff2 6455
000ff3 6665
000ff4 7265
000ff5 0021          .db "Udefer!",0
000ff6 0fe5          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
000ff7 0108          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
000ff8 07ef          .dw XT_FETCHI
000ff9 075e          .dw XT_UP_FETCH
000ffa 0605          .dw XT_PLUS
000ffb 04e9          .dw XT_STORE
000ffc 047d          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
000ffd ff06          .dw $ff06
000ffe 6564
000fff 6566
001000 2172          .db "defer!"
001001 0ff1          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
001002 0108          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
001003 1207          .dw XT_TO_BODY
001004 0519          .dw XT_DUP
001005 0fba          .dw XT_ICELLPLUS
001006 0fba          .dw XT_ICELLPLUS
001007 07ef          .dw XT_FETCHI
001008 0487          .dw XT_EXECUTE
001009 047d          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
00100a ff06          .dw $ff06
00100b 6564
00100c 6566
00100d 4072          .db "defer@"
00100e 0ffd          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
00100f 0108          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
001010 1207          .dw XT_TO_BODY 
001011 0519          .dw XT_DUP
001012 0fba          .dw XT_ICELLPLUS
001013 07ef          .dw XT_FETCHI
001014 0487          .dw XT_EXECUTE
001015 047d          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
001016 ff07          .dw $ff07
001017 6428
001018 6665
001019 7265
00101a 0029          .db "(defer)", 0
00101b 100a          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
00101c 0108          .dw DO_COLON
                 PFA_DODEFER:
00101d 018d          .dw XT_DOCREATE
00101e 02ed          .dw XT_REVEAL
00101f 01b0          .dw XT_COMPILE
001020 1022          .dw PFA_DODEFER1
001021 047d          .dw XT_EXIT
                 PFA_DODEFER1:
001022 940e 0306     call_ DO_DODOES
001024 0519          .dw XT_DUP
001025 0fba          .dw XT_ICELLPLUS
001026 07ef          .dw XT_FETCHI
001027 0487          .dw XT_EXECUTE 
001028 0487          .dw XT_EXECUTE
001029 047d          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
00102a ff0f          .dw $ff0f
00102b 6573
00102c 7261
00102d 6863
00102e 772d
00102f 726f
001030 6c64
001031 7369
001032 0074          .db "search-wordlist",0
001033 1016          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
001034 0108          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
001035 0567          .dw XT_TO_R
001036 05bc          .dw XT_ZERO
001037 049d          .dw XT_DOLITERAL
001038 1049          .dw XT_ISWORD
001039 055e          .dw XT_R_FROM
00103a 1066          .dw XT_TRAVERSEWORDLIST
00103b 0519          .dw XT_DUP
00103c 0582          .dw XT_ZEROEQUAL
00103d 0496          .dw XT_DOCONDBRANCH
00103e 1043          DEST(PFA_SEARCH_WORDLIST1)
00103f 09a6             .dw XT_2DROP
001040 0541             .dw XT_DROP
001041 05bc             .dw XT_ZERO
001042 047d             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
001043 0519            .dw XT_DUP
001044 108d            .dw XT_NFA2CFA
                       ; .. and get the header flag
001045 052c            .dw XT_SWAP
001046 0173            .dw XT_NAME2FLAGS
001047 0160            .dw XT_IMMEDIATEQ
001048 047d          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
001049 0108          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
00104a 0567          .dw XT_TO_R
00104b 0541          .dw XT_DROP
00104c 099d          .dw XT_2DUP
00104d 0570          .dw XT_R_FETCH  ; -- addr len addr len nt
00104e 1081          .dw XT_NAME2STRING
00104f 1097          .dw XT_ICOMPARE      ; (-- addr len f )
001050 0496          .dw XT_DOCONDBRANCH
001051 1057          DEST(PFA_ISWORD3)
                       ; not now
001052 055e            .dw XT_R_FROM
001053 0541            .dw XT_DROP
001054 05bc            .dw XT_ZERO
001055 05b3            .dw XT_TRUE         ; maybe next word
001056 047d            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
001057 09a6            .dw XT_2DROP
001058 055e            .dw XT_R_FROM
001059 05bc            .dw XT_ZERO       ; finish traverse-wordlist
00105a 047d            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
00105b ff11          .dw $ff11
00105c 7274
00105d 7661
00105e 7265
00105f 6573
001060 772d
001061 726f
001062 6c64
001063 7369
001064 0074          .db "traverse-wordlist",0
001065 102a          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
001066 0108          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
001067 07bc          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
001068 0519          .dw XT_DUP           ; ( -- xt nt nt )
001069 0496          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
00106a 1077          DEST(PFA_TRAVERSEWORDLIST2)
00106b 099d          .dw XT_2DUP
00106c 077b          .dw XT_2TO_R
00106d 052c          .dw XT_SWAP
00106e 0487          .dw XT_EXECUTE
00106f 078a          .dw XT_2R_FROM
001070 0549          .dw XT_ROT
001071 0496          .dw XT_DOCONDBRANCH
001072 1077          DEST(PFA_TRAVERSEWORDLIST2)
001073 0459          .dw XT_NFA2LFA
001074 07ef          .dw XT_FETCHI
001075 048c          .dw XT_DOBRANCH      ; ( -- addr )
001076 1068          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
001077 09a6          .dw XT_2DROP
001078 047d          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                 ;        begin @ dup
                 ;        while
                 ;          2dup 2>r
                 ;          swap execute ( i*x nt -- i*x' f )
                 ;          2r> rot
                 ;        while
                 ;          nfa>lfa @i
                 ;        repeat then 2drop ;
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
001079 ff0b          .dw $ff0b
00107a 616e
00107b 656d
00107c 733e
00107d 7274
00107e 6e69
00107f 0067          .db "name>string",0
001080 105b          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
001081 0108          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
001082 0c09          .dw XT_ICOUNT   ; ( -- addr n )
001083 049d          .dw XT_DOLITERAL
001084 00ff          .dw 255
001085 067b          .dw XT_AND      ; mask immediate bit
001086 047d          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
001087 ff07          .dw $ff07
001088 666e
001089 3e61
00108a 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
00108b 0061          .db "nfa>cfa"
00108c 1079          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
00108d 0108          .dw DO_COLON
                 PFA_NFA2CFA:
00108e 0459          .dw XT_NFA2LFA ; skip to link field
00108f 0697          .dw XT_1PLUS   ; next is the execution token
001090 047d          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
001091 ff08          .dw $ff08
001092 6369
001093 6d6f
001094 6170
001095 6572          .db "icompare"
001096 1087          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
001097 0108          .dw DO_COLON
                 PFA_ICOMPARE:
001098 0567          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
001099 0537          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
00109a 055e          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
00109b 057b          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
00109c 0496          .dw XT_DOCONDBRANCH
00109d 10a2          .dw PFA_ICOMPARE_SAMELEN
00109e 09a6            .dw XT_2DROP
00109f 0541            .dw XT_DROP
0010a0 05b3            .dw XT_TRUE
0010a1 047d            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
0010a2 052c          .dw XT_SWAP ; ( -- r-addr f-addr len )
0010a3 05bc          .dw XT_ZERO
0010a4 027a          .dw XT_QDOCHECK
0010a5 0496          .dw XT_DOCONDBRANCH
0010a6 10c5          .dw PFA_ICOMPARE_DONE
0010a7 06f7          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
0010a8 0537          .dw XT_OVER
0010a9 04e1          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
0010aa 0537          .dw XT_OVER
0010ab 07ef          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
0010ac 0519          .dw XT_DUP
                     ;.dw XT_BYTESWAP
0010ad 049d          .dw XT_DOLITERAL
0010ae 0100          .dw $100
0010af 05c4          .dw XT_ULESS
0010b0 0496          .dw XT_DOCONDBRANCH
0010b1 10b6          .dw PFA_ICOMPARE_LASTCELL
0010b2 052c          .dw XT_SWAP
0010b3 049d          .dw XT_DOLITERAL
0010b4 00ff          .dw $00FF
0010b5 067b          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
0010b6 057b          .dw XT_NOTEQUAL
0010b7 0496          .dw XT_DOCONDBRANCH
0010b8 10bd          .dw PFA_ICOMPARE_NEXTLOOP
0010b9 09a6          .dw XT_2DROP
0010ba 05b3          .dw XT_TRUE
0010bb 0730          .dw XT_UNLOOP
0010bc 047d          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
0010bd 0697          .dw XT_1PLUS
0010be 052c          .dw XT_SWAP
0010bf 0995          .dw XT_CELLPLUS
0010c0 052c          .dw XT_SWAP
0010c1 049d          .dw XT_DOLITERAL
0010c2 0002          .dw 2
0010c3 0716          .dw XT_DOPLUSLOOP
0010c4 10a8          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
0010c5 09a6          .dw XT_2DROP
0010c6 05bc          .dw XT_ZERO
0010c7 047d          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
0010c8 ff01          .dw $ff01
0010c9 002a          .db "*",0
0010ca 1091          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
0010cb 0108          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
0010cc 060e          .dw XT_MSTAR
0010cd 0541          .dw XT_DROP
0010ce 047d          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
0010cf ff01          .dw $FF01
0010d0 006a          .db "j",0
0010d1 10c8          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
0010d2 0108          .dw DO_COLON
                 PFA_J:
0010d3 06d2          .dw XT_RP_FETCH
0010d4 049d          .dw XT_DOLITERAL
0010d5 0007          .dw 7
0010d6 0605          .dw XT_PLUS
0010d7 04e1          .dw XT_FETCH
0010d8 06d2          .dw XT_RP_FETCH
0010d9 049d          .dw XT_DOLITERAL
0010da 0009          .dw 9
0010db 0605          .dw XT_PLUS
0010dc 04e1          .dw XT_FETCH
0010dd 0605          .dw XT_PLUS
0010de 047d          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
0010df ff04          .dw $ff04
0010e0 6164
0010e1 7362          .db "dabs"
0010e2 10cf          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
0010e3 0108          .dw DO_COLON
                 PFA_DABS:
0010e4 0519          .dw XT_DUP
0010e5 0589          .dw XT_ZEROLESS
0010e6 0496          .dw XT_DOCONDBRANCH
0010e7 10e9          .dw PFA_DABS1
0010e8 10f0          .dw XT_DNEGATE
                 PFA_DABS1:
0010e9 047d          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
0010ea ff07          .dw $ff07
0010eb 6e64
0010ec 6765
0010ed 7461
0010ee 0065          .db "dnegate",0
0010ef 10df          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
0010f0 0108          .dw DO_COLON
                 PFA_DNEGATE:
0010f1 0862          .dw XT_DINVERT
0010f2 049d          .dw XT_DOLITERAL
0010f3 0001          .dw 1
0010f4 05bc          .dw XT_ZERO
0010f5 083c          .dw XT_DPLUS
0010f6 047d          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
0010f7 ff05          .dw $ff05
0010f8 6d63
0010f9 766f
0010fa 0065          .db "cmove",0
0010fb 10ea          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
0010fc 10fd          .dw PFA_CMOVE
                 PFA_CMOVE:
0010fd 93bf          push xh
0010fe 93af          push xl
0010ff 91e9          ld zl, Y+
001100 91f9          ld zh, Y+ ; addr-to
001101 91a9          ld xl, Y+
001102 91b9          ld xh, Y+ ; addr-from
001103 2f09          mov temp0, tosh
001104 2b08          or temp0, tosl
001105 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
001106 911d          ld temp1, X+
001107 9311          st Z+, temp1
001108 9701          sbiw tosl, 1
001109 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
00110a 91af          pop xl
00110b 91bf          pop xh
00110c 9189
00110d 9199          loadtos
00110e 940c 010c     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
001110 ff05          .dw $ff05
001111 7332
001112 6177
001113 0070          .db "2swap",0
001114 10f7          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
001115 0108          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
001116 0549          .dw XT_ROT
001117 0567          .dw XT_TO_R
001118 0549          .dw XT_ROT
001119 055e          .dw XT_R_FROM
00111a 047d          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System
                 ; refills the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILLTIB:
00111b ff0a          .dw $ff0a
00111c 6572
00111d 6966
00111e 6c6c
00111f 742d
001120 6269          .db "refill-tib"
001121 1110          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
001122 0108          .dw DO_COLON
                 PFA_REFILLTIB:
                 .endif
001123 113e          .dw XT_TIB
001124 049d          .dw XT_DOLITERAL
001125 005a          .dw TIB_SIZE
001126 0cc6          .dw XT_ACCEPT
001127 1144          .dw XT_NUMBERTIB
001128 04e9          .dw XT_STORE
001129 05bc          .dw XT_ZERO
00112a 09b6          .dw XT_TO_IN
00112b 04e9          .dw XT_STORE
00112c 05b3          .dw XT_TRUE ; -1
00112d 047d          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCETIB:
00112e ff0a          .dw $FF0A
00112f 6f73
001130 7275
001131 6563
001132 742d
001133 6269          .db "source-tib"
001134 111b          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
001135 0108          .dw DO_COLON
                 PFA_SOURCETIB:
                 .endif
001136 113e          .dw XT_TIB
001137 1144          .dw XT_NUMBERTIB
001138 04e1          .dw XT_FETCH
001139 047d          .dw XT_EXIT
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; terminal input buffer address
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TIB:
00113a ff03          .dw $ff03
00113b 6974
00113c 0062          .db "tib",0
00113d 112e          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
00113e 04ab          .dw PFA_DOVARIABLE
                 PFA_TIB:
00113f 024b          .dw ram_tib
                 .dseg
00024b           ram_tib: .byte TIB_SIZE
                 .cseg
                 .endif
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBERTIB:
001140 ff04          .dw $ff04
001141 7423
001142 6269          .db "#tib"
001143 113a          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
001144 04ab          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
001145 02a5          .dw ram_sharptib
                 .dseg
0002a5           ram_sharptib: .byte 2
                 .cseg
                 .endif
                 
                 .include "words/init-ram.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
001146 ff06        .dw $ff06
001147 6565
001148 723e
001149 6d61        .db "ee>ram"
00114a 1140        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
00114b 0108        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
00114c 05bc          .dw XT_ZERO
00114d 06f7          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
00114e 0537          .dw XT_OVER
00114f 07bc          .dw XT_FETCHE
001150 0537          .dw XT_OVER
001151 04e9          .dw XT_STORE
001152 0995          .dw XT_CELLPLUS
001153 052c          .dw XT_SWAP
001154 0995          .dw XT_CELLPLUS
001155 052c          .dw XT_SWAP
001156 0725          .dw XT_DOLOOP
001157 114e          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
001158 09a6          .dw XT_2DROP
001159 047d          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INIT_RAM:
00115a ff08        .dw $ff08
00115b 6e69
00115c 7469
00115d 722d
00115e 6d61        .db "init-ram"
00115f 1146        .dw VE_HEAD
                   .set VE_HEAD = VE_INIT_RAM
                 XT_INIT_RAM:
001160 0108        .dw DO_COLON
                 PFA_INI_RAM:          ; ( -- )
001161 049d          .dw XT_DOLITERAL
001162 00a6          .dw EE_INITUSER
001163 075e          .dw XT_UP_FETCH
001164 049d          .dw XT_DOLITERAL
001165 001c          .dw SYSUSERSIZE
001166 066c          .dw XT_2SLASH
001167 114b          .dw XT_EE2RAM
001168 047d          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
001169 ff0b          .dw $ff0b
00116a 6573
00116b 2d74
00116c 7563
00116d 7272
00116e 6e65
00116f 0074          .db "set-current",0
001170 115a          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
001171 0108          .dw DO_COLON
                 PFA_SET_CURRENT:
001172 049d          .dw XT_DOLITERAL
001173 0082          .dw CFG_CURRENT
001174 0798          .dw XT_STOREE
001175 047d          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
001176 ff08          .dw $ff08
001177 6f77
001178 6472
001179 696c
00117a 7473          .db "wordlist"
00117b 1169          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
00117c 0108          .dw DO_COLON
                 PFA_WORDLIST:
00117d 09ef          .dw XT_EHERE
00117e 05bc          .dw XT_ZERO
00117f 0537          .dw XT_OVER
001180 0798          .dw XT_STOREE
001181 0519          .dw XT_DUP
001182 0995          .dw XT_CELLPLUS
001183 0fa8          .dw XT_DOTO
001184 09f0          .dw PFA_EHERE
001185 047d          .dw XT_EXIT
                 
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTHWORDLIST:
001186 ff0e          .dw $ff0e
001187 6f66
001188 7472
001189 2d68
00118a 6f77
00118b 6472
00118c 696c
00118d 7473          .db "forth-wordlist"
00118e 1176          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHWORDLIST
                 XT_FORTHWORDLIST:
00118f 04ab          .dw PFA_DOVARIABLE
                 PFA_FORTHWORDLIST:
001190 0084          .dw CFG_FORTHWORDLIST
                 .include "words/set-order.asm"
                 
                 ; Search Order
                 ; replace the search order list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_ORDER:
001191 ff09          .dw $ff09
001192 6573
001193 2d74
001194 726f
001195 6564
001196 0072          .db "set-order",0
001197 1186          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_ORDER
                 XT_SET_ORDER:
001198 0108          .dw DO_COLON
                 PFA_SET_ORDER:
                 .endif
001199 049d          .dw XT_DOLITERAL
00119a 0086          .dw CFG_ORDERLISTLEN
00119b 03dd          .dw XT_SET_STACK
00119c 047d          .dw XT_EXIT
                 
                 .include "words/set-recognizer.asm"
                 
                 ; Interpreter
                 ; replace the recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_RECOGNIZERS:
00119d ff0f          .dw $ff0f
00119e 6573
00119f 2d74
0011a0 6572
0011a1 6f63
0011a2 6e67
0011a3 7a69
0011a4 7265
0011a5 0073          .db "set-recognizers",0
0011a6 1191          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_RECOGNIZERS
                 XT_SET_RECOGNIZERS:
0011a7 0108          .dw DO_COLON
                 PFA_SET_RECOGNIZERS:
                 .endif
0011a8 049d          .dw XT_DOLITERAL
0011a9 0098          .dw CFG_RECOGNIZERLISTLEN
0011aa 03dd          .dw XT_SET_STACK
0011ab 047d          .dw XT_EXIT
                 
                 .include "words/get-recognizer.asm"
                 
                 ; Interpreter
                 ; Get the current recognizer list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_RECOGNIZERS:
0011ac ff0f          .dw $ff0f
0011ad 6567
0011ae 2d74
0011af 6572
0011b0 6f63
0011b1 6e67
0011b2 7a69
0011b3 7265
0011b4 0073          .db "get-recognizers",0
0011b5 119d          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_RECOGNIZERS
                 XT_GET_RECOGNIZERS:
0011b6 0108          .dw DO_COLON
                 PFA_GET_RECOGNIZERS:
                 .endif
0011b7 049d          .dw XT_DOLITERAL
0011b8 0098          .dw CFG_RECOGNIZERLISTLEN
0011b9 03bc          .dw XT_GET_STACK
0011ba 047d          .dw XT_EXIT
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
0011bb ff04          .dw $ff04
0011bc 6f63
0011bd 6564          .db "code"
0011be 11ac          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
0011bf 0108          .dw DO_COLON
                 PFA_CODE:
0011c0 018d          .dw XT_DOCREATE
0011c1 02ed          .dw XT_REVEAL
0011c2 09e6          .dw XT_DP
0011c3 0fba          .dw XT_ICELLPLUS
0011c4 01bb          .dw XT_COMMA
0011c5 047d          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
0011c6 ff08          .dw $ff08
0011c7 6e65
0011c8 2d64
0011c9 6f63
0011ca 6564          .db "end-code"
0011cb 11bb          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
0011cc 0108          .dw DO_COLON
                 PFA_ENDCODE:
0011cd 01b0          .dw XT_COMPILE
0011ce 940c          .dw $940c
0011cf 01b0          .dw XT_COMPILE
0011d0 010c          .dw DO_NEXT
0011d1 047d          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
0011d2 ff08          .dw $ff08
0011d3 6d28
0011d4 7261
0011d5 656b
0011d6 2972          .db "(marker)"
0011d7 11c6          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
0011d8 04d8          .dw PFA_DOVALUE1
                 PFA_MARKER:
0011d9 00a4          .dw EE_MARKER
0011da 0fc3          .dw XT_EDEFERFETCH
0011db 0fcd          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
0011dc 0008          .dw $0008
0011dd 6f70
0011de 7473
0011df 6f70
0011e0 656e          .db "postpone"
0011e1 11d2          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
0011e2 0108          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
0011e3 0dea          .dw XT_PARSENAME
0011e4 0ee7          .dw XT_DORECOGNIZER
0011e5 0519          .dw XT_DUP
0011e6 0567          .dw XT_TO_R
0011e7 0fba          .dw XT_ICELLPLUS
0011e8 0fba          .dw XT_ICELLPLUS
0011e9 07ef          .dw XT_FETCHI
0011ea 0487          .dw XT_EXECUTE
0011eb 055e          .dw XT_R_FROM
0011ec 0fba          .dw XT_ICELLPLUS
0011ed 07ef          .dw XT_FETCHI
0011ee 01bb          .dw XT_COMMA
0011ef 047d          .dw XT_EXIT
                 .endif
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
0011f0 ff06          .dw $ff06
0011f1 6f62
0011f2 6e75
0011f3 7364          .db "bounds"
0011f4 11dc          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
0011f5 0108          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
0011f6 0537          .dw XT_OVER
0011f7 0605          .dw XT_PLUS
0011f8 052c          .dw XT_SWAP
0011f9 047d          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
0011fa ff03          .dw $ff03
0011fb 3e73
0011fc 0064          .db "s>d",0
0011fd 11f0          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
0011fe 0108          .dw DO_COLON
                 PFA_S2D:
                 .endif
0011ff 0519          .dw XT_DUP
001200 0589          .dw XT_ZEROLESS
001201 047d          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
001202 ff05          .dw $ff05
001203 623e
001204 646f
001205 0079          .db ">body",0
001206 11fa          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
001207 0698          .dw PFA_1PLUS
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 ; now colon words
                 ;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2LITERAL:
001208 0008          .dw $0008
001209 6c32
00120a 7469
00120b 7265
00120c 6c61          .db "2literal"
00120d 1202          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
00120e 0108          .dw DO_COLON
                 PFA_2LITERAL:
                 .endif
00120f 052c          .dw XT_SWAP
001210 01d1          .dw XT_LITERAL
001211 01d1          .dw XT_LITERAL
001212 047d          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
001213 ff01          .dw $ff01
001214 003d          .db "=",0
001215 1208          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
001216 0108          .dw DO_COLON
                 PFA_EQUAL:
001217 05fb          .dw XT_MINUS
001218 0582          .dw XT_ZEROEQUAL
001219 047d          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
00121a ff01          .dw $ff01
00121b 0031          .db "1",0
00121c 1213          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
00121d 04ab          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
00121e 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
00121f ff01          .dw $ff01
001220 0032          .db "2",0
001221 121a          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
001222 04ab          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
001223 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
001224 ff02          .dw $ff02
001225 312d          .db "-1"
001226 121f          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
001227 04ab          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
001228 ffff              .DW -1
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 
                 .set DPSTART = pc
                 .set flashlast = pc
                 
                 .dseg
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000072 ff ff     
                 ; some configs
000074 29 12     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
000076 a7 02     EE_HERE:     .dw HERESTART       ; Memory Allocation
000078 c4 00     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
00007a 1b 04     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
                 ; LEAVE stack is between data stack and return stack.
00007c b0 21     CFG_LP0:     .dw stackstart+1
00007e 67 04     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
000080 69 09     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
000082 84 00     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
000084 24 12     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
000086 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000088 84 00         .dw CFG_FORTHWORDLIST      ; get/set-order
00008a               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
000098 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
00009a 34 0f         .dw XT_REC_WORD
00009c 20 0f         .dw XT_REC_NUM
00009e               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_STOREI:
0000a2 d8 07         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
0000a4 a4 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
0000a6 00 00         .dw 0  ; USER_STATE
0000a8 00 00         .dw 0  ; USER_FOLLOWER
0000aa ff 21         .dw rstackstart  ; USER_RP
0000ac af 21         .dw stackstart   ; USER_SP0
0000ae af 21         .dw stackstart   ; USER_SP
                     
0000b0 00 00         .dw 0  ; USER_HANDLER
0000b2 0a 00         .dw 10 ; USER_BASE
                     
0000b4 ce 00         .dw XT_TX  ; USER_EMIT
0000b6 dc 00         .dw XT_TXQ ; USER_EMITQ
0000b8 a4 00         .dw XT_RX  ; USER_KEY
0000ba be 00         .dw XT_RXQ ; USER_KEYQ
0000bc 35 11         .dw XT_SOURCETIB ; USER_SKEY
0000be 00 00         .dw 0            ; USER_G_IN
0000c0 22 11         .dw XT_REFILLTIB ; USER_REFILL  
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
0000c2 17 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega2561" register use summary:
r0 :  21 r1 :   5 r2 :   8 r3 :  11 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   0 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  75 r17:  52 r18:  52 r19:  37 r20:  13 r21:  38 r22:  11 r23:   4 
r24: 185 r25: 132 r26:  39 r27:  21 r28:   7 r29:   4 r30:  79 r31:  39 
x  :   4 y  : 199 z  :  39 
Registers used: 28 out of 35 (80.0%)

"ATmega2561" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  21 add   :  16 adiw  :  18 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   6 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  12 brpl  :   1 brsh  :   0 brtc  :   0 brts  :   1 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   1 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  18 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :  16 cp    :  10 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 eicall:   1 eijmp :   0 elpm  :  16 
eor   :   3 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 
in    :  15 inc   :   2 jmp   :   8 ld    : 133 ldd   :   4 ldi   :  29 
lds   :   2 lpm   :   0 lsl   :  14 lsr   :   1 mov   :  11 movw  :  65 
mul   :   5 muls  :   1 mulsu :   2 neg   :   0 nop   :   1 or    :   9 
ori   :   0 out   :  27 pop   :  50 push  :  42 rcall :  69 ret   :   6 
reti  :   2 rjmp  : 103 rol   :  32 ror   :   5 sbc   :   9 sbci  :   3 
sbi   :   3 sbic  :   3 sbis  :   0 sbiw  :   7 sbr   :   0 sbrc  :   4 
sbrs  :   3 sec   :   1 seh   :   0 sei   :   1 sen   :   0 ser   :   3 
ses   :   0 set   :   2 sev   :   0 sez   :   0 sleep :   0 spm   :   2 
st    :  71 std   :   8 sts   :   3 sub   :   6 subi  :   3 swap  :   0 
tst   :   1 wdr   :   0 
Instructions used: 76 out of 116 (65.5%)

"ATmega2561" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x03e07e   1970  12588  14558  262144   5.6%
[.dseg] 0x000200 0x0002a7      0    167    167    8192   2.0%
[.eseg] 0x000000 0x0000c4      0    196    196    4096   4.8%

Assembly complete, 0 errors, 5 warnings
